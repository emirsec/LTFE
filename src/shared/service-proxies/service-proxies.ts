/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { DateTime } from 'luxon';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResetPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailActivationLink(body: SendEmailActivationLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonate(body: ImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegatedImpersonate(body: DelegatedImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/DelegatedImpersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processDelegatedImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchToLinkedAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class AssetInformationAppserviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param assetId (optional) 
     * @return Success
     */
    getAllAssetInformationInfo(assetId: number | null | undefined): Observable<GetAssetInformationDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetInformationAppservice/GetAllAssetInformationInfo?";
        if (assetId !== undefined && assetId !== null)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetInformationInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetInformationInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetInformationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetInformationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetInformationInfo(response: HttpResponseBase): Observable<GetAssetInformationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetInformationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetInformationDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateAssetinformation(body: GetAssetInformationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetInformationAppservice/CreateOrUpdateAssetinformation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateAssetinformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateAssetinformation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateAssetinformation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllAssetinformationList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAssetInformationListDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetInformationAppservice/GetAllAssetinformationList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetinformationList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetinformationList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAssetInformationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAssetInformationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetinformationList(response: HttpResponseBase): Observable<PagedResultDtoOfGetAssetInformationListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAssetInformationListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAssetInformationListDto>(<any>null);
    }

    /**
     * @param assetId (optional) 
     * @return Success
     */
    removeAssetInformation(assetId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetInformationAppservice/RemoveAssetInformation?";
        if (assetId === null)
            throw new Error("The parameter 'assetId' cannot be null.");
        else if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAssetInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAssetInformation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveAssetInformation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeItService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetInformationAppservice/RemoveItService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveItService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessProcess(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetInformationAppservice/RemoveBusinessProcess?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessProcess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessProcess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetInformationAppservice/RemoveBusinessService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AuditServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param auditId (optional) 
     * @return Success
     */
    getAllAuditInfoDetails(auditId: number | null | undefined): Observable<AuditDto> {
        let url_ = this.baseUrl + "/api/services/app/Audit/GetAllAuditInfoDetails?";
        if (auditId !== undefined && auditId !== null)
            url_ += "auditId=" + encodeURIComponent("" + auditId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAuditInfoDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAuditInfoDetails(<any>response_);
                } catch (e) {
                    return <Observable<AuditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAuditInfoDetails(response: HttpResponseBase): Observable<AuditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateAudit(body: AuditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Audit/CreateOrUpdateAudit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllAuditList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAuditListDto> {
        let url_ = this.baseUrl + "/api/services/app/Audit/GetAllAuditList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAuditList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAuditList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAuditListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAuditListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAuditList(response: HttpResponseBase): Observable<PagedResultDtoOfGetAuditListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAuditListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAuditListDto>(<any>null);
    }

    /**
     * @param hardwareAssetId (optional) 
     * @return Success
     */
    removeAudit(hardwareAssetId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Audit/RemoveAudit?";
        if (hardwareAssetId === null)
            throw new Error("The parameter 'hardwareAssetId' cannot be null.");
        else if (hardwareAssetId !== undefined)
            url_ += "hardwareAssetId=" + encodeURIComponent("" + hardwareAssetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedAuditAttachments(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Audit/RemovedAuditAttachments?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedAuditAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedAuditAttachments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedAuditAttachments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedAuditAuditors(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Audit/RemovedAuditAuditors?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedAuditAuditors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedAuditAuditors(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedAuditAuditors(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedAuditBusinessProcess(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Audit/RemovedAuditBusinessProcess?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedAuditBusinessProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedAuditBusinessProcess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedAuditBusinessProcess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedAuditBusinessServices(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Audit/RemovedAuditBusinessServices?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedAuditBusinessServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedAuditBusinessServices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedAuditBusinessServices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedAuditFacilitieDatacenters(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Audit/RemovedAuditFacilitieDatacenters?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedAuditFacilitieDatacenters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedAuditFacilitieDatacenters(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedAuditFacilitieDatacenters(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedAuditFindings(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Audit/RemovedAuditFindings?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedAuditFindings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedAuditFindings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedAuditFindings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedAuditTeams(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Audit/RemovedAuditTeams?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedAuditTeams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedAuditTeams(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedAuditTeams(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedAuditVendors(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Audit/RemovedAuditVendors?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedAuditVendors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedAuditVendors(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedAuditVendors(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName !== undefined && serviceName !== null)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName !== undefined && methodName !== null)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo !== undefined && browserInfo !== null)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException !== undefined && hasException !== null)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration !== undefined && minExecutionDuration !== null)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration !== undefined && maxExecutionDuration !== null)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAuditLogListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName !== undefined && serviceName !== null)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName !== undefined && methodName !== null)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo !== undefined && browserInfo !== null)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException !== undefined && hasException !== null)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration !== undefined && minExecutionDuration !== null)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration !== undefined && maxExecutionDuration !== null)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName !== undefined && entityTypeFullName !== null)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | null | undefined, entityId: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName !== undefined && entityTypeFullName !== null)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (entityId !== undefined && entityId !== null)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName !== undefined && entityTypeFullName !== null)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' cannot be null.");
        else if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class BusinessProcessServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param businessProcessId (optional) 
     * @return Success
     */
    getAllBusinessprocessInfo(businessProcessId: number | null | undefined): Observable<BusinessProcessDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProcess/GetAllBusinessprocessInfo?";
        if (businessProcessId !== undefined && businessProcessId !== null)
            url_ += "businessProcessId=" + encodeURIComponent("" + businessProcessId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessprocessInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessprocessInfo(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBusinessprocessInfo(response: HttpResponseBase): Observable<BusinessProcessDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllBusinessProcessList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBusinessProcessListDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProcess/GetAllBusinessProcessList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessProcessList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessProcessList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBusinessProcessListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBusinessProcessListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBusinessProcessList(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessProcessListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessProcessListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBusinessProcessListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateBusinessProcess(body: BusinessProcessDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProcess/CreateOrUpdateBusinessProcess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateBusinessProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateBusinessProcess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateBusinessProcess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProcess/RemoveBusinessUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProcess/RemoveBusinessService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessAuthorativeDocument(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProcess/RemoveBusinessAuthorativeDocument?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessAuthorativeDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessAuthorativeDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessAuthorativeDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param businessProcessId (optional) 
     * @return Success
     */
    removeBusinesProcess(businessProcessId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProcess/RemoveBusinesProcess?";
        if (businessProcessId === null)
            throw new Error("The parameter 'businessProcessId' cannot be null.");
        else if (businessProcessId !== undefined)
            url_ += "BusinessProcessId=" + encodeURIComponent("" + businessProcessId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinesProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinesProcess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinesProcess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessProcessForEdit(id: number | undefined): Observable<GetBusinessProcessForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProcess/GetBusinessProcessForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessProcessForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessProcessForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBusinessProcessForEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBusinessProcessForEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessProcessForEdit(response: HttpResponseBase): Observable<GetBusinessProcessForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessProcessForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBusinessProcessForEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getNextBusinessProcessId(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProcess/GetNextBusinessProcessId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextBusinessProcessId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextBusinessProcessId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextBusinessProcessId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class BusinessServicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param serviceId (optional) 
     * @return Success
     */
    getBusinessSerivceInfo(serviceId: number | null | undefined): Observable<BusinessServiceDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessServices/GetBusinessSerivceInfo?";
        if (serviceId !== undefined && serviceId !== null)
            url_ += "ServiceId=" + encodeURIComponent("" + serviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessSerivceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessSerivceInfo(<any>response_);
                } catch (e) {
                    return <Observable<BusinessServiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessServiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessSerivceInfo(response: HttpResponseBase): Observable<BusinessServiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessServiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessServiceDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllBusinessServicesList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBusinessServicesListDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessServices/GetAllBusinessServicesList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessServicesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessServicesList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBusinessServicesListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBusinessServicesListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBusinessServicesList(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessServicesListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessServicesListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBusinessServicesListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateBusinessServices(body: BusinessServiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessServices/CreateOrUpdateBusinessServices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateBusinessServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateBusinessServices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateBusinessServices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeItService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessServices/RemoveItService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveItService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessServices/RemoveBusinessUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessServiceForEdit(id: number | undefined): Observable<GetBusinessServicesForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessServices/GetBusinessServiceForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessServiceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessServiceForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBusinessServicesForEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBusinessServicesForEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessServiceForEdit(response: HttpResponseBase): Observable<GetBusinessServicesForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessServicesForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBusinessServicesForEditDto>(<any>null);
    }

    /**
     * @param serviceId (optional) 
     * @return Success
     */
    removeBusinessService(serviceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessServices/RemoveBusinessService?";
        if (serviceId === null)
            throw new Error("The parameter 'serviceId' cannot be null.");
        else if (serviceId !== undefined)
            url_ += "ServiceId=" + encodeURIComponent("" + serviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BusinessUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param unitType (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllBusinessUnits(filter: string | null | undefined, organizationId: number | null | undefined, unitType: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBusinessUnitListDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetAllBusinessUnits?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (unitType !== undefined && unitType !== null)
            url_ += "UnitType=" + encodeURIComponent("" + unitType) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessUnits(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBusinessUnitListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBusinessUnitListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBusinessUnits(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessUnitListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessUnitListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBusinessUnitListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateBusinessUnit(body: CreateOrUpdateBusinessUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/CreateOrUpdateBusinessUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateBusinessUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateBusinessUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateBusinessUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteBusinessUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/DeleteBusinessUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBusinessUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBusinessUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBusinessUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessUnitForEdit(id: number | undefined): Observable<GetBusinessUnitForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetBusinessUnitForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessUnitForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessUnitForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBusinessUnitForEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBusinessUnitForEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessUnitForEdit(response: HttpResponseBase): Observable<GetBusinessUnitForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessUnitForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBusinessUnitForEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getNextBusinessUnitId(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetNextBusinessUnitId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextBusinessUnitId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextBusinessUnitId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextBusinessUnitId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getAllOrganizationUnits(): Observable<UpdateOrganizationUnitInput[]> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetAllOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<UpdateOrganizationUnitInput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateOrganizationUnitInput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOrganizationUnits(response: HttpResponseBase): Observable<UpdateOrganizationUnitInput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UpdateOrganizationUnitInput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateOrganizationUnitInput[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllOraganization(): Observable<GetLockThreatOrganizationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetAllOraganization";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOraganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOraganization(<any>response_);
                } catch (e) {
                    return <Observable<GetLockThreatOrganizationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLockThreatOrganizationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOraganization(response: HttpResponseBase): Observable<GetLockThreatOrganizationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetLockThreatOrganizationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLockThreatOrganizationDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getUnitType(): Observable<UnitTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetUnitType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitType(<any>response_);
                } catch (e) {
                    return <Observable<UnitTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitType(response: HttpResponseBase): Observable<UnitTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UnitTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitTypeDto[]>(<any>null);
    }

    /**
     * @param unitTypeId (optional) 
     * @param oraganizationId (optional) 
     * @return Success
     */
    getAllparentUnit(unitTypeId: number[] | null | undefined, oraganizationId: number | null | undefined): Observable<BusinessUnitListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetAllparentUnit?";
        if (unitTypeId !== undefined && unitTypeId !== null)
            unitTypeId && unitTypeId.forEach(item => { url_ += "UnitTypeId=" + encodeURIComponent("" + item) + "&"; });
        if (oraganizationId !== undefined && oraganizationId !== null)
            url_ += "OraganizationId=" + encodeURIComponent("" + oraganizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllparentUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllparentUnit(<any>response_);
                } catch (e) {
                    return <Observable<BusinessUnitListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessUnitListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllparentUnit(response: HttpResponseBase): Observable<BusinessUnitListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BusinessUnitListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessUnitListDto[]>(<any>null);
    }

    /**
     * @param unitTypeId (optional) 
     * @param oraganizationId (optional) 
     * @return Success
     */
    getUnittypeWiesParent(unitTypeId: number[] | null | undefined, oraganizationId: number | null | undefined): Observable<ParentUnit[]> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetUnittypeWiesParent?";
        if (unitTypeId !== undefined && unitTypeId !== null)
            unitTypeId && unitTypeId.forEach(item => { url_ += "UnitTypeId=" + encodeURIComponent("" + item) + "&"; });
        if (oraganizationId !== undefined && oraganizationId !== null)
            url_ += "OraganizationId=" + encodeURIComponent("" + oraganizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnittypeWiesParent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnittypeWiesParent(<any>response_);
                } catch (e) {
                    return <Observable<ParentUnit[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParentUnit[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnittypeWiesParent(response: HttpResponseBase): Observable<ParentUnit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ParentUnit.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParentUnit[]>(<any>null);
    }

    /**
     * @param oraganizationId (optional) 
     * @return Success
     */
    getAllBusinessUnit(oraganizationId: number | undefined): Observable<BusinessUnitDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetAllBusinessUnit?";
        if (oraganizationId === null)
            throw new Error("The parameter 'oraganizationId' cannot be null.");
        else if (oraganizationId !== undefined)
            url_ += "OraganizationId=" + encodeURIComponent("" + oraganizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessUnit(<any>response_);
                } catch (e) {
                    return <Observable<BusinessUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBusinessUnit(response: HttpResponseBase): Observable<BusinessUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BusinessUnitDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessUnitDto[]>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfCacheDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearCache(body: EntityDtoOfString | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserChatFriendsWithSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (minMessageId !== undefined && minMessageId !== null)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfChatMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(body: MarkAllUnreadMessagesOfUserAsReadInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CodeGeneratorCommonAppserviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param title (optional) 
     * @param code (optional) 
     * @return Success
     */
    codeCreate(title: string | null | undefined, code: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CodeGeneratorCommonAppservice/CodeCreate?";
        if (title !== undefined && title !== null)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCodeCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCodeCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCodeCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param title (optional) 
     * @param code (optional) 
     * @return Success
     */
    getNextId(title: string | null | undefined, code: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CodeGeneratorCommonAppservice/GetNextId?";
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDefaultEditionNameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class ContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getAllContactsInfo(contactId: number | null | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/GetAllContactsInfo?";
        if (contactId !== undefined && contactId !== null)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContactsInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContactsInfo(<any>response_);
                } catch (e) {
                    return <Observable<ContactInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllContactsInfo(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateContact(body: ContactInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contact/CreateOrUpdateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param contactId (optional) 
     * @param firstName (optional) 
     * @param jobTitle (optional) 
     * @param phoneNumber (optional) 
     * @param mobileNo (optional) 
     * @param email (optional) 
     * @param loginUserFilter (optional) 
     * @param lockThreatOrganizationFilter (optional) 
     * @param vendorFilter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllContactList(filter: string | null | undefined, organizationId: number | null | undefined, contactId: string | null | undefined, firstName: string | null | undefined, jobTitle: string | null | undefined, phoneNumber: string | null | undefined, mobileNo: string | null | undefined, email: string | null | undefined, loginUserFilter: string | null | undefined, lockThreatOrganizationFilter: string | null | undefined, vendorFilter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfContactListViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/GetAllContactList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (contactId !== undefined && contactId !== null)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (jobTitle !== undefined && jobTitle !== null)
            url_ += "jobTitle=" + encodeURIComponent("" + jobTitle) + "&";
        if (phoneNumber !== undefined && phoneNumber !== null)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (mobileNo !== undefined && mobileNo !== null)
            url_ += "MobileNo=" + encodeURIComponent("" + mobileNo) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (loginUserFilter !== undefined && loginUserFilter !== null)
            url_ += "LoginUserFilter=" + encodeURIComponent("" + loginUserFilter) + "&";
        if (lockThreatOrganizationFilter !== undefined && lockThreatOrganizationFilter !== null)
            url_ += "LockThreatOrganizationFilter=" + encodeURIComponent("" + lockThreatOrganizationFilter) + "&";
        if (vendorFilter !== undefined && vendorFilter !== null)
            url_ += "VendorFilter=" + encodeURIComponent("" + vendorFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContactList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContactList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContactListViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfContactListViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllContactList(response: HttpResponseBase): Observable<PagedResultDtoOfContactListViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfContactListViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfContactListViewDto>(<any>null);
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    removeContact(contactId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contact/RemoveContact?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param contactId (optional) 
     * @param firstName (optional) 
     * @param jobTitle (optional) 
     * @param phoneNumber (optional) 
     * @param mobileNo (optional) 
     * @param email (optional) 
     * @param loginUserFilter (optional) 
     * @param lockThreatOrganizationFilter (optional) 
     * @param vendorFilter (optional) 
     * @return Success
     */
    getContactToExcel(filter: string | null | undefined, organizationId: number | null | undefined, contactId: string | null | undefined, firstName: string | null | undefined, jobTitle: string | null | undefined, phoneNumber: string | null | undefined, mobileNo: string | null | undefined, email: string | null | undefined, loginUserFilter: string | null | undefined, lockThreatOrganizationFilter: string | null | undefined, vendorFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/GetContactToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (contactId !== undefined && contactId !== null)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (jobTitle !== undefined && jobTitle !== null)
            url_ += "jobTitle=" + encodeURIComponent("" + jobTitle) + "&";
        if (phoneNumber !== undefined && phoneNumber !== null)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (mobileNo !== undefined && mobileNo !== null)
            url_ += "MobileNo=" + encodeURIComponent("" + mobileNo) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (loginUserFilter !== undefined && loginUserFilter !== null)
            url_ += "LoginUserFilter=" + encodeURIComponent("" + loginUserFilter) + "&";
        if (lockThreatOrganizationFilter !== undefined && lockThreatOrganizationFilter !== null)
            url_ += "LockThreatOrganizationFilter=" + encodeURIComponent("" + lockThreatOrganizationFilter) + "&";
        if (vendorFilter !== undefined && vendorFilter !== null)
            url_ += "VendorFilter=" + encodeURIComponent("" + vendorFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class ContractServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param contractId (optional) 
     * @return Success
     */
    getAllContractInfo(contractId: number | null | undefined): Observable<ContractDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/GetAllContractInfo?";
        if (contractId !== undefined && contractId !== null)
            url_ += "contractId=" + encodeURIComponent("" + contractId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContractInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContractInfo(<any>response_);
                } catch (e) {
                    return <Observable<ContractDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllContractInfo(response: HttpResponseBase): Observable<ContractDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateContract(body: ContractDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contract/CreateOrUpdateContract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateContract(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateContract(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateContract(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param contractId (optional) 
     * @param contractTitle (optional) 
     * @param contractReference (optional) 
     * @param description (optional) 
     * @param contractValue (optional) 
     * @param contractType (optional) 
     * @param contractCategory (optional) 
     * @param vendor (optional) 
     * @param lockThreatOrganization (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllContractList(filter: string | null | undefined, contractId: string | null | undefined, contractTitle: string | null | undefined, contractReference: string | null | undefined, description: string | null | undefined, contractValue: number | null | undefined, contractType: string | null | undefined, contractCategory: string | null | undefined, vendor: string | null | undefined, lockThreatOrganization: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfContractListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/GetAllContractList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (contractId !== undefined && contractId !== null)
            url_ += "ContractId=" + encodeURIComponent("" + contractId) + "&";
        if (contractTitle !== undefined && contractTitle !== null)
            url_ += "ContractTitle=" + encodeURIComponent("" + contractTitle) + "&";
        if (contractReference !== undefined && contractReference !== null)
            url_ += "ContractReference=" + encodeURIComponent("" + contractReference) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (contractValue !== undefined && contractValue !== null)
            url_ += "ContractValue=" + encodeURIComponent("" + contractValue) + "&";
        if (contractType !== undefined && contractType !== null)
            url_ += "ContractType=" + encodeURIComponent("" + contractType) + "&";
        if (contractCategory !== undefined && contractCategory !== null)
            url_ += "ContractCategory=" + encodeURIComponent("" + contractCategory) + "&";
        if (vendor !== undefined && vendor !== null)
            url_ += "Vendor=" + encodeURIComponent("" + vendor) + "&";
        if (lockThreatOrganization !== undefined && lockThreatOrganization !== null)
            url_ += "LockThreatOrganization=" + encodeURIComponent("" + lockThreatOrganization) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContractList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContractList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContractListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfContractListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllContractList(response: HttpResponseBase): Observable<PagedResultDtoOfContractListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfContractListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfContractListDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param contractId (optional) 
     * @param contractTitle (optional) 
     * @param contractReference (optional) 
     * @param description (optional) 
     * @param contractValue (optional) 
     * @param contractType (optional) 
     * @param contractCategory (optional) 
     * @param vendor (optional) 
     * @param lockThreatOrganization (optional) 
     * @param organizationId (optional) 
     * @return Success
     */
    getContractToExcel(filter: string | null | undefined, contractId: string | null | undefined, contractTitle: string | null | undefined, contractReference: string | null | undefined, description: string | null | undefined, contractValue: number | null | undefined, contractType: string | null | undefined, contractCategory: string | null | undefined, vendor: string | null | undefined, lockThreatOrganization: string | null | undefined, organizationId: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/GetContractToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (contractId !== undefined && contractId !== null)
            url_ += "ContractId=" + encodeURIComponent("" + contractId) + "&";
        if (contractTitle !== undefined && contractTitle !== null)
            url_ += "ContractTitle=" + encodeURIComponent("" + contractTitle) + "&";
        if (contractReference !== undefined && contractReference !== null)
            url_ += "ContractReference=" + encodeURIComponent("" + contractReference) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (contractValue !== undefined && contractValue !== null)
            url_ += "ContractValue=" + encodeURIComponent("" + contractValue) + "&";
        if (contractType !== undefined && contractType !== null)
            url_ += "ContractType=" + encodeURIComponent("" + contractType) + "&";
        if (contractCategory !== undefined && contractCategory !== null)
            url_ += "ContractCategory=" + encodeURIComponent("" + contractCategory) + "&";
        if (vendor !== undefined && vendor !== null)
            url_ += "Vendor=" + encodeURIComponent("" + vendor) + "&";
        if (lockThreatOrganization !== undefined && lockThreatOrganization !== null)
            url_ += "LockThreatOrganization=" + encodeURIComponent("" + lockThreatOrganization) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContractToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param contractId (optional) 
     * @return Success
     */
    removeContract(contractId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contract/RemoveContract?";
        if (contractId === null)
            throw new Error("The parameter 'contractId' cannot be null.");
        else if (contractId !== undefined)
            url_ += "ContractId=" + encodeURIComponent("" + contractId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveContract(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveContract(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveContract(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CountriesAppserviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CountryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllConfidentiality(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAllConfidentiality";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllConfidentiality(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllConfidentiality(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllConfidentiality(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllServiceType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAllServiceType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllServiceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllServiceType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllServiceType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllIntergrity(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAllIntergrity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIntergrity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIntergrity(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIntergrity(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllOthers(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAllOthers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOthers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOthers(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOthers(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAvailibility(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAvailibility";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailibility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailibility(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvailibility(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getIndustrySectors(): Observable<DynamicNameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetIndustrySectors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndustrySectors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndustrySectors(<any>response_);
                } catch (e) {
                    return <Observable<DynamicNameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicNameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndustrySectors(response: HttpResponseBase): Observable<DynamicNameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DynamicNameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicNameValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getComponents(): Observable<DynamicNameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetComponents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetComponents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComponents(<any>response_);
                } catch (e) {
                    return <Observable<DynamicNameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicNameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetComponents(response: HttpResponseBase): Observable<DynamicNameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DynamicNameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicNameValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllGrade(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAllGrade";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGrade(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGrade(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAllUserType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllStrategicGoal(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAllStrategicGoal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStrategicGoal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStrategicGoal(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStrategicGoal(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllStrategicType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAllStrategicType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStrategicType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStrategicType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStrategicType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllStrategicStatus(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAllStrategicStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStrategicStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStrategicStatus(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStrategicStatus(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllRiskGroup(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAllRiskGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRiskGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRiskGroup(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRiskGroup(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getKeyRiskStatus(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetKeyRiskStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyRiskStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyRiskStatus(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyRiskStatus(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getFrequency(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetFrequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFrequency(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFrequency(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getProcessType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetProcessType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSLA(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetSLA";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSLA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSLA(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSLA(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getRiviewperiod(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetRiviewperiod";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRiviewperiod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRiviewperiod(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRiviewperiod(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getProcessStatus(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetProcessStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessStatus(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessStatus(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getActivity(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivity(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getProcessPriority(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetProcessPriority";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessPriority(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessPriority(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessPriority(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getMeeetingType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetMeeetingType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMeeetingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMeeetingType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMeeetingType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getMeetingClassification(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetMeetingClassification";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMeetingClassification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMeetingClassification(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMeetingClassification(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getRiskLevel(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetRiskLevel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRiskLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRiskLevel(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRiskLevel(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTaskLinked(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetTaskLinked";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskLinked(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskLinked(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaskLinked(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTaskType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetTaskType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaskType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getFacilityType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetFacilityType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFacilityType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFacilityType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFacilityType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAssetType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAssetType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAssetCategorys(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAssetCategorys";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetCategorys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetCategorys(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetCategorys(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAssetLabels(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAssetLabels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetLabels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetLabels(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetLabels(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAuditYear(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAuditYear";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditYear(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditYear(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAuditArea(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetAuditArea";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditArea(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditArea(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getExceptionType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetExceptionType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExceptionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExceptionType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExceptionType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getExceptionReviewStatus(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetExceptionReviewStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExceptionReviewStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExceptionReviewStatus(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExceptionReviewStatus(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getFacilitieId(): Observable<FacilitieIdDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetFacilitieId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFacilitieId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFacilitieId(<any>response_);
                } catch (e) {
                    return <Observable<FacilitieIdDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FacilitieIdDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFacilitieId(response: HttpResponseBase): Observable<FacilitieIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FacilitieIdDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacilitieIdDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getVendorType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetVendorType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getIndustroy(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetIndustroy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndustroy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndustroy(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndustroy(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getVendorProductType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetVendorProductType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorProductType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorProductType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorProductType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getContactType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetContactType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getContractType(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetContractType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractType(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContractType(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getContractCategory(): Observable<GetDynamicValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CountriesAppservice/GetContractCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractCategory(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContractCategory(response: HttpResponseBase): Observable<GetDynamicValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDynamicValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueDto[]>(<any>null);
    }
}

@Injectable()
export class DashboardCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getUserDashboard(dashboardName: string | null | undefined, application: string | null | undefined): Observable<Dashboard> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetUserDashboard?";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDashboard(<any>response_);
                } catch (e) {
                    return <Observable<Dashboard>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dashboard>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDashboard(response: HttpResponseBase): Observable<Dashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dashboard>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePage(body: SavePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/SavePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSavePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renamePage(body: RenamePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/RenamePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenamePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenamePage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRenamePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewPage(body: AddNewPageInput | undefined): Observable<AddNewPageOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddNewPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewPage(<any>response_);
                } catch (e) {
                    return <Observable<AddNewPageOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddNewPageOutput>><any>_observableThrow(response_);
        }));
    }

    protected processAddNewPage(response: HttpResponseBase): Observable<AddNewPageOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddNewPageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddNewPageOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    deletePage(id: string | null | undefined, dashboardName: string | null | undefined, application: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/DeletePage?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addWidget(body: AddWidgetInput | undefined): Observable<Widget> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddWidget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWidget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWidget(<any>response_);
                } catch (e) {
                    return <Observable<Widget>><any>_observableThrow(e);
                }
            } else
                return <Observable<Widget>><any>_observableThrow(response_);
        }));
    }

    protected processAddWidget(response: HttpResponseBase): Observable<Widget> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Widget.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Widget>(<any>null);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getDashboardDefinition(dashboardName: string | null | undefined, application: string | null | undefined): Observable<DashboardOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetDashboardDefinition?";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardDefinition(<any>response_);
                } catch (e) {
                    return <Observable<DashboardOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardDefinition(response: HttpResponseBase): Observable<DashboardOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardOutput>(<any>null);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getAllWidgetDefinitions(dashboardName: string | null | undefined, application: string | null | undefined): Observable<WidgetOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetAllWidgetDefinitions?";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWidgetDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWidgetDefinitions(<any>response_);
                } catch (e) {
                    return <Observable<WidgetOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWidgetDefinitions(response: HttpResponseBase): Observable<WidgetOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetOutput[]>(<any>null);
    }

    /**
     * @param application (optional) 
     * @return Success
     */
    getSettingName(application: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetSettingName?";
        if (application !== undefined && application !== null)
            url_ += "application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingName(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettingName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: DateTime | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: DateTime | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: DateTime | null | undefined, endDate: DateTime | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(body: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(<any>null);
    }
}

@Injectable()
export class DynamicEntityPropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DynamicEntityPropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicEntityPropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicEntityPropertyDto>(<any>null);
    }

    /**
     * @param entityFullName (optional) 
     * @return Success
     */
    getAllPropertiesOfAnEntity(entityFullName: string | null | undefined): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAllPropertiesOfAnEntity?";
        if (entityFullName !== undefined && entityFullName !== null)
            url_ += "EntityFullName=" + encodeURIComponent("" + entityFullName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPropertiesOfAnEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPropertiesOfAnEntity(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDynamicEntityPropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDynamicEntityPropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPropertiesOfAnEntity(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicEntityPropertyDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDynamicEntityPropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDynamicEntityPropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicEntityPropertyDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicEntityPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicEntityPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEntitiesHasDynamicProperty(): Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAllEntitiesHasDynamicProperty";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntitiesHasDynamicProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntitiesHasDynamicProperty(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEntitiesHasDynamicProperty(response: HttpResponseBase): Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>(<any>null);
    }
}

@Injectable()
export class DynamicEntityPropertyDefinitionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllAllowedInputTypeNames(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyDefinition/GetAllAllowedInputTypeNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAllowedInputTypeNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAllowedInputTypeNames(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAllowedInputTypeNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEntities(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyDefinition/GetAllEntities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntities(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEntities(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class DynamicEntityPropertyValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicEntityPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DynamicEntityPropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicEntityPropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicEntityPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicEntityPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicEntityPropertyValueDto>(<any>null);
    }

    /**
     * @param entityId (optional) 
     * @param propertyId (optional) 
     * @return Success
     */
    getAll(entityId: string | null | undefined, propertyId: number | undefined): Observable<ListResultDtoOfDynamicEntityPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/GetAll?";
        if (entityId !== undefined && entityId !== null)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "PropertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDynamicEntityPropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDynamicEntityPropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicEntityPropertyValueDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicEntityPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicEntityPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDynamicEntityPropertyValues(entityFullName: string, entityId: string): Observable<GetAllDynamicEntityPropertyValuesOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/GetAllDynamicEntityPropertyValues?";
        if (entityFullName === undefined || entityFullName === null)
            throw new Error("The parameter 'entityFullName' must be defined and cannot be null.");
        else
            url_ += "EntityFullName=" + encodeURIComponent("" + entityFullName) + "&";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDynamicEntityPropertyValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDynamicEntityPropertyValues(<any>response_);
                } catch (e) {
                    return <Observable<GetAllDynamicEntityPropertyValuesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllDynamicEntityPropertyValuesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDynamicEntityPropertyValues(response: HttpResponseBase): Observable<GetAllDynamicEntityPropertyValuesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllDynamicEntityPropertyValuesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllDynamicEntityPropertyValuesOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdateAllValues(body: InsertOrUpdateAllValuesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/InsertOrUpdateAllValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertOrUpdateAllValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertOrUpdateAllValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertOrUpdateAllValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cleanValues(body: CleanValuesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/CleanValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCleanValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCleanValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCleanValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DynamicPropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DynamicPropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicPropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPropertyDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ListResultDtoOfDynamicPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDynamicPropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDynamicPropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicPropertyDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    findAllowedInputType(name: string | null | undefined): Observable<IInputType> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/FindAllowedInputType?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindAllowedInputType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindAllowedInputType(<any>response_);
                } catch (e) {
                    return <Observable<IInputType>><any>_observableThrow(e);
                }
            } else
                return <Observable<IInputType>><any>_observableThrow(response_);
        }));
    }

    protected processFindAllowedInputType(response: HttpResponseBase): Observable<IInputType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IInputType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IInputType>(<any>null);
    }
}

@Injectable()
export class DynamicPropertyValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DynamicPropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicPropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPropertyValueDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllValuesOfDynamicProperty(id: number | undefined): Observable<ListResultDtoOfDynamicPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/GetAllValuesOfDynamicProperty?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllValuesOfDynamicProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllValuesOfDynamicProperty(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDynamicPropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDynamicPropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllValuesOfDynamicProperty(response: HttpResponseBase): Observable<ListResultDtoOfDynamicPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicPropertyValueDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfEditionListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEdition(body: CreateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEdition(body: UpdateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(body: MoveTenantsToAnotherEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | undefined, onlyFreeItems: boolean | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined && selectedEditionId !== null)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&";
        if (addAllItem === null)
            throw new Error("The parameter 'addAllItem' cannot be null.");
        else if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class EmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllEmployees(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEmployeeListDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetAllEmployees?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployees(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEmployeeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEmployeeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmployees(response: HttpResponseBase): Observable<PagedResultDtoOfEmployeeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEmployeeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEmployeeListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateEmployees(body: CreateOrUpdateEmployeesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Employee/CreateOrUpdateEmployees";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateEmployees(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateEmployees(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: CreateOrUpdateEmployeesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Employee/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmployeesForEdit(id: number | undefined): Observable<GetEmployeeForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetEmployeesForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEmployeeForEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmployeeForEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeesForEdit(response: HttpResponseBase): Observable<GetEmployeeForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmployeeForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeeForEditDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEmployee(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Employee/DeleteEmployee?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployee(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEmployee(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNextEmployeeId(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetNextEmployeeId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextEmployeeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextEmployeeId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextEmployeeId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllEmployeeOraganization(id: number | null | undefined): Observable<ProgramUser[]> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetAllEmployeeOraganization?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployeeOraganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployeeOraganization(<any>response_);
                } catch (e) {
                    return <Observable<ProgramUser[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramUser[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmployeeOraganization(response: HttpResponseBase): Observable<ProgramUser[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProgramUser.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramUser[]>(<any>null);
    }

    /**
     * @param orgId (optional) 
     * @return Success
     */
    getEmployeeForOraganization(orgId: number | undefined): Observable<GetEmployeeUnderOraganizationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetEmployeeForOraganization?";
        if (orgId === null)
            throw new Error("The parameter 'orgId' cannot be null.");
        else if (orgId !== undefined)
            url_ += "orgId=" + encodeURIComponent("" + orgId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeForOraganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeForOraganization(<any>response_);
                } catch (e) {
                    return <Observable<GetEmployeeUnderOraganizationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmployeeUnderOraganizationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeForOraganization(response: HttpResponseBase): Observable<GetEmployeeUnderOraganizationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetEmployeeUnderOraganizationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeeUnderOraganizationDto[]>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @return Success
     */
    checkUserAvailable(userName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Employee/CheckUserAvailable?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUserAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUserAvailable(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckUserAvailable(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ExceptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllExceptionList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetExceptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Exception/GetAllExceptionList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExceptionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExceptionList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetExceptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetExceptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllExceptionList(response: HttpResponseBase): Observable<PagedResultDtoOfGetExceptionListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetExceptionListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetExceptionListDto>(<any>null);
    }

    /**
     * @param exceptionId (optional) 
     * @return Success
     */
    getAllException(exceptionId: number | null | undefined): Observable<GetExceptionInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Exception/GetAllException?";
        if (exceptionId !== undefined && exceptionId !== null)
            url_ += "exceptionId=" + encodeURIComponent("" + exceptionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllException(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllException(<any>response_);
                } catch (e) {
                    return <Observable<GetExceptionInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetExceptionInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllException(response: HttpResponseBase): Observable<GetExceptionInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExceptionInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExceptionInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateException(body: GetExceptionInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exception/CreateOrUpdateException";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateException(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateException(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateException(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedExceptionAuditingControl(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exception/RemovedExceptionAuditingControl?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedExceptionAuditingControl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedExceptionAuditingControl(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedExceptionAuditingControl(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedExceptionAuthoratativeDocument(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exception/RemovedExceptionAuthoratativeDocument?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedExceptionAuthoratativeDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedExceptionAuthoratativeDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedExceptionAuthoratativeDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedExceptionCitation(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exception/RemovedExceptionCitation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedExceptionCitation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedExceptionCitation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedExceptionCitation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedExceptionCitationLibrary(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exception/RemovedExceptionCitationLibrary?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedExceptionCitationLibrary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedExceptionCitationLibrary(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedExceptionCitationLibrary(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedExceptionBusinessUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exception/RemovedExceptionBusinessUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedExceptionBusinessUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedExceptionBusinessUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedExceptionBusinessUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedExceptionDocument(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exception/RemovedExceptionDocument?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedExceptionDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedExceptionDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedExceptionDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedExceptionOrganization(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exception/RemovedExceptionOrganization?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedExceptionOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedExceptionOrganization(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedExceptionOrganization(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedExceptionRemediation(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exception/RemovedExceptionRemediation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedExceptionRemediation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedExceptionRemediation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedExceptionRemediation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedExceptionRiskManagement(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exception/RemovedExceptionRiskManagement?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedExceptionRiskManagement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedExceptionRiskManagement(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedExceptionRiskManagement(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param exceptionId (optional) 
     * @return Success
     */
    removeException(exceptionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exception/RemoveException?";
        if (exceptionId === null)
            throw new Error("The parameter 'exceptionId' cannot be null.");
        else if (exceptionId !== undefined)
            url_ += "exceptionId=" + encodeURIComponent("" + exceptionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveException(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveException(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveException(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FacilitieDatacenterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param facilitieDatacenterId (optional) 
     * @return Success
     */
    getAllFacilitieDatacenterInfo(facilitieDatacenterId: number | null | undefined): Observable<FacilitieDatacenterDto> {
        let url_ = this.baseUrl + "/api/services/app/FacilitieDatacenter/GetAllFacilitieDatacenterInfo?";
        if (facilitieDatacenterId !== undefined && facilitieDatacenterId !== null)
            url_ += "facilitieDatacenterId=" + encodeURIComponent("" + facilitieDatacenterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFacilitieDatacenterInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFacilitieDatacenterInfo(<any>response_);
                } catch (e) {
                    return <Observable<FacilitieDatacenterDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FacilitieDatacenterDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFacilitieDatacenterInfo(response: HttpResponseBase): Observable<FacilitieDatacenterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacilitieDatacenterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacilitieDatacenterDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateFacilitieDatacenter(body: FacilitieDatacenterDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FacilitieDatacenter/CreateOrUpdateFacilitieDatacenter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateFacilitieDatacenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateFacilitieDatacenter(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateFacilitieDatacenter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllFacilitiesDatacenterList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetFacilitiesDatacenterListDto> {
        let url_ = this.baseUrl + "/api/services/app/FacilitieDatacenter/GetAllFacilitiesDatacenterList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFacilitiesDatacenterList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFacilitiesDatacenterList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetFacilitiesDatacenterListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetFacilitiesDatacenterListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFacilitiesDatacenterList(response: HttpResponseBase): Observable<PagedResultDtoOfGetFacilitiesDatacenterListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetFacilitiesDatacenterListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetFacilitiesDatacenterListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeItService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FacilitieDatacenter/RemoveItService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveItService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessProcess(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FacilitieDatacenter/RemoveBusinessProcess?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessProcess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessProcess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FacilitieDatacenter/RemoveBusinessService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param facilitieDatacenterId (optional) 
     * @return Success
     */
    removeFacilitieDatacenter(facilitieDatacenterId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FacilitieDatacenter/RemoveFacilitieDatacenter?";
        if (facilitieDatacenterId === null)
            throw new Error("The parameter 'facilitieDatacenterId' cannot be null.");
        else if (facilitieDatacenterId !== undefined)
            url_ += "facilitieDatacenterId=" + encodeURIComponent("" + facilitieDatacenterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFacilitieDatacenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFacilitieDatacenter(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveFacilitieDatacenter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FileUploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getConnectionString(): Observable<CloudStorageAccount> {
        let url_ = this.baseUrl + "/api/services/app/FileUpload/GetConnectionString";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConnectionString(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConnectionString(<any>response_);
                } catch (e) {
                    return <Observable<CloudStorageAccount>><any>_observableThrow(e);
                }
            } else
                return <Observable<CloudStorageAccount>><any>_observableThrow(response_);
        }));
    }

    protected processGetConnectionString(response: HttpResponseBase): Observable<CloudStorageAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CloudStorageAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CloudStorageAccount>(<any>null);
    }

    /**
     * @return Success
     */
    getCloudBlobContainer(): Observable<CloudBlobContainer> {
        let url_ = this.baseUrl + "/api/services/app/FileUpload/GetCloudBlobContainer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCloudBlobContainer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCloudBlobContainer(<any>response_);
                } catch (e) {
                    return <Observable<CloudBlobContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<CloudBlobContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetCloudBlobContainer(response: HttpResponseBase): Observable<CloudBlobContainer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CloudBlobContainer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CloudBlobContainer>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadFiles(body: UploadFileDto[] | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/FileUpload/UploadFiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFiles(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFiles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param fileName (optional) 
     * @param newFileName (optional) 
     * @param credentia (optional) 
     * @return Success
     */
    renameImage(fileName: string | null | undefined, newFileName: string | null | undefined, credentia: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FileUpload/RenameImage?";
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (newFileName !== undefined && newFileName !== null)
            url_ += "newFileName=" + encodeURIComponent("" + newFileName) + "&";
        if (credentia !== undefined && credentia !== null)
            url_ += "credentia=" + encodeURIComponent("" + credentia) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenameImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenameImage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRenameImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param imageName (optional) 
     * @param credentia (optional) 
     * @return Success
     */
    downloadFileFromBlob(imageName: string | null | undefined, credentia: string | null | undefined): Observable<TupleOfMemoryStreamString> {
        let url_ = this.baseUrl + "/api/services/app/FileUpload/DownloadFileFromBlob?";
        if (imageName !== undefined && imageName !== null)
            url_ += "imageName=" + encodeURIComponent("" + imageName) + "&";
        if (credentia !== undefined && credentia !== null)
            url_ += "credentia=" + encodeURIComponent("" + credentia) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileFromBlob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileFromBlob(<any>response_);
                } catch (e) {
                    return <Observable<TupleOfMemoryStreamString>><any>_observableThrow(e);
                }
            } else
                return <Observable<TupleOfMemoryStreamString>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileFromBlob(response: HttpResponseBase): Observable<TupleOfMemoryStreamString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TupleOfMemoryStreamString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TupleOfMemoryStreamString>(<any>null);
    }

    /**
     * @param fileNames (optional) 
     * @return Success
     */
    deleteFiles(fileNames: string[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/FileUpload/DeleteFiles?";
        if (fileNames !== undefined && fileNames !== null)
            fileNames && fileNames.forEach(item => { url_ += "fileNames=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFiles(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFiles(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param credentia (optional) 
     * @return Success
     */
    deleteAllBlobs(credentia: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/FileUpload/DeleteAllBlobs?";
        if (credentia !== undefined && credentia !== null)
            url_ += "credentia=" + encodeURIComponent("" + credentia) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllBlobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllBlobs(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAllBlobs(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class FindingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllFindingList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfFindingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Finding/GetAllFindingList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFindingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFindingList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfFindingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfFindingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFindingList(response: HttpResponseBase): Observable<PagedResultDtoOfFindingListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfFindingListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfFindingListDto>(<any>null);
    }

    /**
     * @param findingId (optional) 
     * @return Success
     */
    getAllfindingInfo(findingId: number | null | undefined): Observable<FindingInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Finding/GetAllfindingInfo?";
        if (findingId !== undefined && findingId !== null)
            url_ += "findingId=" + encodeURIComponent("" + findingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllfindingInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllfindingInfo(<any>response_);
                } catch (e) {
                    return <Observable<FindingInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FindingInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllfindingInfo(response: HttpResponseBase): Observable<FindingInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindingInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FindingInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateFinding(body: FindingInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Finding/CreateOrUpdateFinding";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateFinding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateFinding(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateFinding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param findingId (optional) 
     * @return Success
     */
    removeFinding(findingId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Finding/RemoveFinding?";
        if (findingId === null)
            throw new Error("The parameter 'findingId' cannot be null.");
        else if (findingId !== undefined)
            url_ += "findingId=" + encodeURIComponent("" + findingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFinding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFinding(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveFinding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequest(body: CreateFriendshipRequestInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(body: CreateFriendshipRequestByUserNameInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blockUser(body: BlockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unblockUser(body: UnblockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptFriendshipRequest(body: AcceptFriendshipRequestInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HardWareAssetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param hardwareAssetId (optional) 
     * @return Success
     */
    getAllhardwareAssetInfo(hardwareAssetId: number | null | undefined): Observable<HardwareAssetDto> {
        let url_ = this.baseUrl + "/api/services/app/HardWareAsset/GetAllhardwareAssetInfo?";
        if (hardwareAssetId !== undefined && hardwareAssetId !== null)
            url_ += "hardwareAssetId=" + encodeURIComponent("" + hardwareAssetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllhardwareAssetInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllhardwareAssetInfo(<any>response_);
                } catch (e) {
                    return <Observable<HardwareAssetDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HardwareAssetDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllhardwareAssetInfo(response: HttpResponseBase): Observable<HardwareAssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HardwareAssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HardwareAssetDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateHardwareAsset(body: HardwareAssetDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HardWareAsset/CreateOrUpdateHardwareAsset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateHardwareAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateHardwareAsset(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateHardwareAsset(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllHardwareAssetList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfHardwareAssetListDto> {
        let url_ = this.baseUrl + "/api/services/app/HardWareAsset/GetAllHardwareAssetList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHardwareAssetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHardwareAssetList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHardwareAssetListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHardwareAssetListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHardwareAssetList(response: HttpResponseBase): Observable<PagedResultDtoOfHardwareAssetListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfHardwareAssetListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHardwareAssetListDto>(<any>null);
    }

    /**
     * @param hardwareAssetId (optional) 
     * @return Success
     */
    removehardwareAsset(hardwareAssetId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HardWareAsset/RemovehardwareAsset?";
        if (hardwareAssetId === null)
            throw new Error("The parameter 'hardwareAssetId' cannot be null.");
        else if (hardwareAssetId !== undefined)
            url_ += "hardwareAssetId=" + encodeURIComponent("" + hardwareAssetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovehardwareAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovehardwareAsset(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovehardwareAsset(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeItService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HardWareAsset/RemoveItService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveItService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessProcess(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HardWareAsset/RemoveBusinessProcess?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessProcess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessProcess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HardWareAsset/RemoveBusinessService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getTopStatsData(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<TopStatsData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetTopStatsData?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStatsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStatsData(<any>response_);
                } catch (e) {
                    return <Observable<TopStatsData>><any>_observableThrow(e);
                }
            } else
                return <Observable<TopStatsData>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopStatsData(response: HttpResponseBase): Observable<TopStatsData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TopStatsData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TopStatsData>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentTenantsData(): Observable<GetRecentTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetRecentTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentTenantsData(<any>response_);
                } catch (e) {
                    return <Observable<GetRecentTenantsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRecentTenantsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentTenantsData(response: HttpResponseBase): Observable<GetRecentTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRecentTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRecentTenantsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSubscriptionExpiringTenantsData(): Observable<GetExpiringTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetSubscriptionExpiringTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionExpiringTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionExpiringTenantsData(<any>response_);
                } catch (e) {
                    return <Observable<GetExpiringTenantsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetExpiringTenantsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionExpiringTenantsData(response: HttpResponseBase): Observable<GetExpiringTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExpiringTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExpiringTenantsOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncomeStatisticsDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionTenantStatisticsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnabledSocialLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnabledSocialLoginSettings(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginSettingsDto>(<any>null);
    }
}

@Injectable()
export class IndustrySectorsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<IndustrySectorDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IndustrySectors/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<IndustrySectorDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IndustrySectorDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IndustrySectorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IndustrySectorDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndustrySectorDto[]>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setup(body: InstallDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingsJsonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckDatabaseOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvoice(body: CreateInvoiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ITServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param orgId (optional) 
     * @return Success
     */
    getAllITserviceUnderOraganization(orgId: number | undefined): Observable<GetITserviceForBusinessServiceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ITService/GetAllITserviceUnderOraganization?";
        if (orgId === null)
            throw new Error("The parameter 'orgId' cannot be null.");
        else if (orgId !== undefined)
            url_ += "OrgId=" + encodeURIComponent("" + orgId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllITserviceUnderOraganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllITserviceUnderOraganization(<any>response_);
                } catch (e) {
                    return <Observable<GetITserviceForBusinessServiceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetITserviceForBusinessServiceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllITserviceUnderOraganization(response: HttpResponseBase): Observable<GetITserviceForBusinessServiceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetITserviceForBusinessServiceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetITserviceForBusinessServiceDto[]>(<any>null);
    }

    /**
     * @param iTserviceId (optional) 
     * @return Success
     */
    getITserviceInfo(iTserviceId: number | null | undefined): Observable<ITserviceDto> {
        let url_ = this.baseUrl + "/api/services/app/ITService/GetITserviceInfo?";
        if (iTserviceId !== undefined && iTserviceId !== null)
            url_ += "ITserviceId=" + encodeURIComponent("" + iTserviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetITserviceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetITserviceInfo(<any>response_);
                } catch (e) {
                    return <Observable<ITserviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ITserviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetITserviceInfo(response: HttpResponseBase): Observable<ITserviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ITserviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ITserviceDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllITServiceList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetITserviceListDto> {
        let url_ = this.baseUrl + "/api/services/app/ITService/GetAllITServiceList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllITServiceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllITServiceList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetITserviceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetITserviceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllITServiceList(response: HttpResponseBase): Observable<PagedResultDtoOfGetITserviceListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetITserviceListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetITserviceListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateITservice(body: ITserviceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ITService/CreateOrUpdateITservice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateITservice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateITservice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateITservice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ITService/RemoveBusinessUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ITService/RemoveBusinessService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param iTserviceId (optional) 
     * @return Success
     */
    removeITService(iTserviceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ITService/RemoveITService?";
        if (iTserviceId === null)
            throw new Error("The parameter 'iTserviceId' cannot be null.");
        else if (iTserviceId !== undefined)
            url_ += "ITserviceId=" + encodeURIComponent("" + iTserviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveITService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveITService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveITService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class KeyPerformanceIndicatorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyPerformanceId (optional) 
     * @return Success
     */
    getKeyperformanceInfo(keyPerformanceId: number | null | undefined): Observable<KeyPerformanceDto> {
        let url_ = this.baseUrl + "/api/services/app/KeyPerformanceIndicator/GetKeyperformanceInfo?";
        if (keyPerformanceId !== undefined && keyPerformanceId !== null)
            url_ += "KeyPerformanceId=" + encodeURIComponent("" + keyPerformanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyperformanceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyperformanceInfo(<any>response_);
                } catch (e) {
                    return <Observable<KeyPerformanceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KeyPerformanceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyperformanceInfo(response: HttpResponseBase): Observable<KeyPerformanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KeyPerformanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KeyPerformanceDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllKeyperformanceList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfKeyPerformanceIndicatorListDto> {
        let url_ = this.baseUrl + "/api/services/app/KeyPerformanceIndicator/GetAllKeyperformanceList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKeyperformanceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKeyperformanceList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfKeyPerformanceIndicatorListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfKeyPerformanceIndicatorListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllKeyperformanceList(response: HttpResponseBase): Observable<PagedResultDtoOfKeyPerformanceIndicatorListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfKeyPerformanceIndicatorListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfKeyPerformanceIndicatorListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorUpdateKeyPerformance(body: KeyPerformanceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KeyPerformanceIndicator/CreateorUpdateKeyPerformance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorUpdateKeyPerformance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorUpdateKeyPerformance(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateorUpdateKeyPerformance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeAdministrators(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KeyPerformanceIndicator/RemoveAdministrators?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAdministrators(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAdministrators(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveAdministrators(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KeyPerformanceIndicator/RemoveBusinessUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyPerformanceId (optional) 
     * @return Success
     */
    removeKeyPerformances(keyPerformanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KeyPerformanceIndicator/RemoveKeyPerformances?";
        if (keyPerformanceId === null)
            throw new Error("The parameter 'keyPerformanceId' cannot be null.");
        else if (keyPerformanceId !== undefined)
            url_ += "KeyPerformanceId=" + encodeURIComponent("" + keyPerformanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveKeyPerformances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveKeyPerformances(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveKeyPerformances(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class KeyRiskIndicatorsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyRiskIndicatorsId (optional) 
     * @return Success
     */
    getKeyRiskIndicatorInfo(keyRiskIndicatorsId: number | null | undefined): Observable<KeyRiskIndicatorDto> {
        let url_ = this.baseUrl + "/api/services/app/KeyRiskIndicators/GetKeyRiskIndicatorInfo?";
        if (keyRiskIndicatorsId !== undefined && keyRiskIndicatorsId !== null)
            url_ += "KeyRiskIndicatorsId=" + encodeURIComponent("" + keyRiskIndicatorsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyRiskIndicatorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyRiskIndicatorInfo(<any>response_);
                } catch (e) {
                    return <Observable<KeyRiskIndicatorDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KeyRiskIndicatorDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyRiskIndicatorInfo(response: HttpResponseBase): Observable<KeyRiskIndicatorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KeyRiskIndicatorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KeyRiskIndicatorDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getKeyRiskIndicatorList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfKeyRiskIndicatorListDto> {
        let url_ = this.baseUrl + "/api/services/app/KeyRiskIndicators/GetKeyRiskIndicatorList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyRiskIndicatorList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyRiskIndicatorList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfKeyRiskIndicatorListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfKeyRiskIndicatorListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyRiskIndicatorList(response: HttpResponseBase): Observable<PagedResultDtoOfKeyRiskIndicatorListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfKeyRiskIndicatorListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfKeyRiskIndicatorListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorUpdateKeyRiskIndicator(body: KeyRiskIndicatorDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KeyRiskIndicators/CreateorUpdateKeyRiskIndicator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorUpdateKeyRiskIndicator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorUpdateKeyRiskIndicator(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateorUpdateKeyRiskIndicator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessunit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KeyRiskIndicators/RemoveBusinessunit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessunit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessunit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessunit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyRiskIndicatorId (optional) 
     * @return Success
     */
    removeKeyRiskIndicator(keyRiskIndicatorId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KeyRiskIndicators/RemoveKeyRiskIndicator?";
        if (keyRiskIndicatorId === null)
            throw new Error("The parameter 'keyRiskIndicatorId' cannot be null.");
        else if (keyRiskIndicatorId !== undefined)
            url_ += "keyRiskIndicatorId=" + encodeURIComponent("" + keyRiskIndicatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveKeyRiskIndicator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveKeyRiskIndicator(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveKeyRiskIndicator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguagesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&";
        if (baseLanguageName !== undefined && baseLanguageName !== null)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&";
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&";
        if (targetValueFilter !== undefined && targetValueFilter !== null)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&";
        if (filterText !== undefined && filterText !== null)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLanguageTextListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MeetingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param meetingId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllMeetingList(filter: string | null | undefined, meetingId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMeetingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Meeting/GetAllMeetingList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (meetingId !== undefined && meetingId !== null)
            url_ += "MeetingId=" + encodeURIComponent("" + meetingId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMeetingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMeetingList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMeetingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMeetingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMeetingList(response: HttpResponseBase): Observable<PagedResultDtoOfMeetingListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMeetingListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMeetingListDto>(<any>null);
    }

    /**
     * @param meetingId (optional) 
     * @return Success
     */
    getMeetingInfo(meetingId: number | null | undefined): Observable<MeetingInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Meeting/GetMeetingInfo?";
        if (meetingId !== undefined && meetingId !== null)
            url_ += "MeetingId=" + encodeURIComponent("" + meetingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMeetingInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMeetingInfo(<any>response_);
                } catch (e) {
                    return <Observable<MeetingInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MeetingInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMeetingInfo(response: HttpResponseBase): Observable<MeetingInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MeetingInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MeetingInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorUpdateMeeting(body: MeetingInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Meeting/CreateorUpdateMeeting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorUpdateMeeting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorUpdateMeeting(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateorUpdateMeeting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeMeetingAttendUsers(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Meeting/RemoveMeetingAttendUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveMeetingAttendUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveMeetingAttendUsers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveMeetingAttendUsers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeMeetingAbsenteeUsers(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Meeting/RemoveMeetingAbsenteeUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveMeetingAbsenteeUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveMeetingAbsenteeUsers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveMeetingAbsenteeUsers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param meetingId (optional) 
     * @return Success
     */
    removeMeetings(meetingId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Meeting/RemoveMeetings?";
        if (meetingId === null)
            throw new Error("The parameter 'meetingId' cannot be null.");
        else if (meetingId !== undefined)
            url_ += "MeetingId=" + encodeURIComponent("" + meetingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveMeetings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveMeetings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveMeetings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | undefined, startDate: DateTime | null | undefined, endDate: DateTime | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setNotificationAsRead(body: EntityDtoOfGuid | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    deleteAllUserNotifications(state: UserNotificationState | undefined, startDate: DateTime | null | undefined, endDate: DateTime | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteAllUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAllUserNotifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationDashboardCount(): Observable<OrganizationCountDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationDashboard/GetOrganizationDashboardCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationDashboardCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationDashboardCount(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationCountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationCountDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationDashboardCount(response: HttpResponseBase): Observable<OrganizationCountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationCountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationCountDto>(<any>null);
    }
}

@Injectable()
export class OrganizationSetupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllOrgnizationSetup(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationSetupListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationSetup/GetAllOrgnizationSetup?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrgnizationSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrgnizationSetup(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationSetupListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationSetupListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOrgnizationSetup(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationSetupListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationSetupListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationSetupListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateOrganizationSetup(body: CreateOrUpdateOrganizationSetupInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationSetup/CreateOrUpdateOrganizationSetup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateOrganizationSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateOrganizationSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateOrganizationSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOrganizationForEdit(id: number | undefined): Observable<GetOrganizationForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationSetup/GetOrganizationForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetOrganizationForEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOrganizationForEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationForEdit(response: HttpResponseBase): Observable<GetOrganizationForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetOrganizationForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOrganizationForEditDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOrganizationByOrganizationUnitId(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationSetup/GetOrganizationByOrganizationUnitId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationByOrganizationUnitId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationByOrganizationUnitId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationByOrganizationUnitId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getNextCompanyId(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationSetup/GetNextCompanyId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextCompanyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextCompanyId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextCompanyId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getAllOrganization(): Observable<GetOrganizationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationSetup/GetAllOrganization";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganization(<any>response_);
                } catch (e) {
                    return <Observable<GetOrganizationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOrganizationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOrganization(response: HttpResponseBase): Observable<GetOrganizationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetOrganizationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOrganizationDto[]>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfOrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(body: RolesToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findRoles(body: FindOrganizationUnitRolesInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined && upgradeEditionId !== null)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPayment(body: CreatePaymentDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelPayment(body: CancelPaymentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | null | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled !== undefined && recurringPaymentsEnabled !== null)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(<any>response_);
                } catch (e) {
                    return <Observable<PaymentGatewayModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentGatewayModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentGatewayModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentGatewayModel[]>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPayment(paymentId: number | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    switchBetweenFreeEditions(upgradeEditionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/SwitchBetweenFreeEditions?";
        if (upgradeEditionId === null)
            throw new Error("The parameter 'upgradeEditionId' cannot be null.");
        else if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchBetweenFreeEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchBetweenFreeEditions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchBetweenFreeEditions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    upgradeSubscriptionCostsLessThenMinAmount(editionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSubscriptionCostsLessThenMinAmount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSubscriptionCostsLessThenMinAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSubscriptionCostsLessThenMinAmount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeSubscriptionCostsLessThenMinAmount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    hasAnyPayment(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Payment/HasAnyPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHasAnyPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHasAnyPayment(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processHasAnyPayment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalOrderId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | undefined, paypalOrderId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        if (paypalOrderId !== undefined && paypalOrderId !== null)
            url_ += "paypalOrderId=" + encodeURIComponent("" + paypalOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<PayPalConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayPalConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalConfigurationDto>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentUserProfileEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    disableGoogleAuthenticator(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/DisableGoogleAuthenticator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableGoogleAuthenticator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableGoogleAuthenticator(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableGoogleAuthenticator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendVerificationSms(body: SendVerificationSmsInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifySmsCode(body: VerifySmsCodeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfilePicture(body: UpdateProfilePictureInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPasswordComplexitySettingOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    getProfilePictureByUserName(username: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureByUserName?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByUserName(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureByUserName(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePicture(userId: number | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePicture?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getProfilePictureByUser(userId: number | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureByUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByUser(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureByUser(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProgramServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param programId (optional) 
     * @return Success
     */
    getProgramInfo(programId: number | null | undefined): Observable<ProgramDto> {
        let url_ = this.baseUrl + "/api/services/app/Program/GetProgramInfo?";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgramInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgramInfo(<any>response_);
                } catch (e) {
                    return <Observable<ProgramDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProgramInfo(response: HttpResponseBase): Observable<ProgramDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addorEditProgram(body: ProgramDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Program/AddorEditProgram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddorEditProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddorEditProgram(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddorEditProgram(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNextPrgramId(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Program/GetNextPrgramId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextPrgramId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextPrgramId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextPrgramId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeProgramTeamMember(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Program/RemoveProgramTeamMember?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProgramTeamMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProgramTeamMember(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProgramTeamMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeProgramCoordinator(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Program/RemoveProgramCoordinator?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProgramCoordinator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProgramCoordinator(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProgramCoordinator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param programId (optional) 
     * @return Success
     */
    removeProgram(programId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Program/RemoveProgram?";
        if (programId === null)
            throw new Error("The parameter 'programId' cannot be null.");
        else if (programId !== undefined)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProgram(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProgram(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeProgramAuthoratativeDocument(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Program/RemoveProgramAuthoratativeDocument?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProgramAuthoratativeDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProgramAuthoratativeDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProgramAuthoratativeDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeProgramCountry(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Program/RemoveProgramCountry?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProgramCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProgramCountry(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProgramCountry(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param isLoggedInUserPrograms (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPrograms(filter: string | null | undefined, isLoggedInUserPrograms: boolean | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProgramListDto> {
        let url_ = this.baseUrl + "/api/services/app/Program/GetAllPrograms?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (isLoggedInUserPrograms === null)
            throw new Error("The parameter 'isLoggedInUserPrograms' cannot be null.");
        else if (isLoggedInUserPrograms !== undefined)
            url_ += "IsLoggedInUserPrograms=" + encodeURIComponent("" + isLoggedInUserPrograms) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPrograms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPrograms(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProgramListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProgramListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPrograms(response: HttpResponseBase): Observable<PagedResultDtoOfProgramListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProgramListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProgramListDto>(<any>null);
    }
}

@Injectable()
export class ProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getNextProjectId(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Project/GetNextProjectId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextProjectId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextProjectId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addorEditProject(body: ProjectDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Project/AddorEditProject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddorEditProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddorEditProject(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddorEditProject(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param isLoggedInUserProjects (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllProjects(filter: string | null | undefined, isLoggedInUserProjects: boolean | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/Project/GetAllProjects?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (isLoggedInUserProjects === null)
            throw new Error("The parameter 'isLoggedInUserProjects' cannot be null.");
        else if (isLoggedInUserProjects !== undefined)
            url_ += "IsLoggedInUserProjects=" + encodeURIComponent("" + isLoggedInUserProjects) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjects(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProjects(response: HttpResponseBase): Observable<PagedResultDtoOfProjectListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProjectListDto>(<any>null);
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getProjectInfo(projectId: number | null | undefined): Observable<ProjectDto> {
        let url_ = this.baseUrl + "/api/services/app/Project/GetProjectInfo?";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectInfo(<any>response_);
                } catch (e) {
                    return <Observable<ProjectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectInfo(response: HttpResponseBase): Observable<ProjectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectDto>(<any>null);
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    removeProject(projectId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Project/RemoveProject?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProject(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProject(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeProjectAuthoratativeDocument(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Project/RemoveProjectAuthoratativeDocument?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProjectAuthoratativeDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProjectAuthoratativeDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProjectAuthoratativeDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeProjectCountry(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Project/RemoveProjectCountry?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProjectCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProjectCountry(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProjectCountry(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeProjectTeamMember(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Project/RemoveProjectTeamMember?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProjectTeamMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProjectTeamMember(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProjectTeamMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeProjectTeamMemberExternal(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Project/RemoveProjectTeamMemberExternal?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProjectTeamMemberExternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProjectTeamMemberExternal(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProjectTeamMemberExternal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeProjectTeamMemberInternal(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Project/RemoveProjectTeamMemberInternal?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProjectTeamMemberInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProjectTeamMemberInternal(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProjectTeamMemberInternal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeProjectComponents(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Project/RemoveProjectComponents?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProjectComponents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProjectComponents(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProjectComponents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param permissions (optional) 
     * @return Success
     */
    getRoles(permissions: string[] | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permissions !== undefined && permissions !== null)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateRole(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateUserSignInTokenOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class StrategicObjectivesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param strategicObjectiveId (optional) 
     * @return Success
     */
    getStrategicObjectiveInfo(strategicObjectiveId: number | null | undefined): Observable<StrategicObjectiveDto> {
        let url_ = this.baseUrl + "/api/services/app/StrategicObjectives/GetStrategicObjectiveInfo?";
        if (strategicObjectiveId !== undefined && strategicObjectiveId !== null)
            url_ += "StrategicObjectiveId=" + encodeURIComponent("" + strategicObjectiveId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStrategicObjectiveInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStrategicObjectiveInfo(<any>response_);
                } catch (e) {
                    return <Observable<StrategicObjectiveDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StrategicObjectiveDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStrategicObjectiveInfo(response: HttpResponseBase): Observable<StrategicObjectiveDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StrategicObjectiveDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StrategicObjectiveDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllGoal(): Observable<OranizationGoalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/StrategicObjectives/GetAllGoal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGoal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGoal(<any>response_);
                } catch (e) {
                    return <Observable<OranizationGoalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OranizationGoalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGoal(response: HttpResponseBase): Observable<OranizationGoalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OranizationGoalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OranizationGoalDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllStrategicObjectives(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfStrategicObjectiveListDto> {
        let url_ = this.baseUrl + "/api/services/app/StrategicObjectives/GetAllStrategicObjectives?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStrategicObjectives(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStrategicObjectives(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfStrategicObjectiveListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfStrategicObjectiveListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStrategicObjectives(response: HttpResponseBase): Observable<PagedResultDtoOfStrategicObjectiveListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStrategicObjectiveListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfStrategicObjectiveListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateStrategicObjectives(body: StrategicObjectiveDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StrategicObjectives/CreateOrUpdateStrategicObjectives";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateStrategicObjectives(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateStrategicObjectives(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateStrategicObjectives(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteStrategicObjective(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StrategicObjectives/DeleteStrategicObjective?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStrategicObjective(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStrategicObjective(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteStrategicObjective(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStrategicObjectiveEdit(id: number | undefined): Observable<GetEditStrategicObjectiveDto> {
        let url_ = this.baseUrl + "/api/services/app/StrategicObjectives/GetStrategicObjectiveEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStrategicObjectiveEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStrategicObjectiveEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditStrategicObjectiveDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditStrategicObjectiveDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStrategicObjectiveEdit(response: HttpResponseBase): Observable<GetEditStrategicObjectiveDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditStrategicObjectiveDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditStrategicObjectiveDto>(<any>null);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<StripeConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripeConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripeConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeConfigurationDto>(<any>null);
    }

    /**
     * @param stripeSessionId (optional) 
     * @return Success
     */
    getPayment(stripeSessionId: string | null | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetPayment?";
        if (stripeSessionId !== undefined && stripeSessionId !== null)
            url_ += "StripeSessionId=" + encodeURIComponent("" + stripeSessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPaymentSession(body: StripeCreatePaymentSessionInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreatePaymentSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaymentSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaymentSession(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePaymentSession(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPaymentResult(paymentId: number | undefined): Observable<StripePaymentResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetPaymentResult?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "PaymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentResult(<any>response_);
                } catch (e) {
                    return <Observable<StripePaymentResultOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripePaymentResultOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentResult(response: HttpResponseBase): Observable<StripePaymentResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripePaymentResultOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripePaymentResultOutput>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SystemApplicationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param assetId (optional) 
     * @return Success
     */
    getAllSystemApplication(assetId: number | null | undefined): Observable<SystemApplicationDto> {
        let url_ = this.baseUrl + "/api/services/app/SystemApplication/GetAllSystemApplication?";
        if (assetId !== undefined && assetId !== null)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSystemApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSystemApplication(<any>response_);
                } catch (e) {
                    return <Observable<SystemApplicationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemApplicationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSystemApplication(response: HttpResponseBase): Observable<SystemApplicationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemApplicationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemApplicationDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateSystemApplication(body: SystemApplicationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SystemApplication/CreateOrUpdateSystemApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateSystemApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateSystemApplication(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateSystemApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSysteamApplicationList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSystemApplicationListDto> {
        let url_ = this.baseUrl + "/api/services/app/SystemApplication/GetAllSysteamApplicationList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysteamApplicationList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysteamApplicationList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSystemApplicationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSystemApplicationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysteamApplicationList(response: HttpResponseBase): Observable<PagedResultDtoOfSystemApplicationListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSystemApplicationListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSystemApplicationListDto>(<any>null);
    }

    /**
     * @param assetId (optional) 
     * @return Success
     */
    removeSysteamApplication(assetId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SystemApplication/RemoveSysteamApplication?";
        if (assetId === null)
            throw new Error("The parameter 'assetId' cannot be null.");
        else if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveSysteamApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveSysteamApplication(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveSysteamApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeItService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SystemApplication/RemoveItService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveItService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessProcess(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SystemApplication/RemoveBusinessProcess?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessProcess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessProcess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SystemApplication/RemoveBusinessService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TaskServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param taskId (optional) 
     * @return Success
     */
    getTaskinfo(taskId: number | null | undefined): Observable<TaskinfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Task/GetTaskinfo?";
        if (taskId !== undefined && taskId !== null)
            url_ += "TaskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskinfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskinfo(<any>response_);
                } catch (e) {
                    return <Observable<TaskinfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaskinfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaskinfo(response: HttpResponseBase): Observable<TaskinfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaskinfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaskinfoDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllTasksList(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTaskListDto> {
        let url_ = this.baseUrl + "/api/services/app/Task/GetAllTasksList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTasksList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTasksList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTaskListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTaskListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTasksList(response: HttpResponseBase): Observable<PagedResultDtoOfTaskListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTaskListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTaskListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorEditTask(body: TaskinfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Task/CreateorEditTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorEditTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorEditTask(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateorEditTask(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedAssociatedProjects(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Task/RemovedAssociatedProjects?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedAssociatedProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedAssociatedProjects(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedAssociatedProjects(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedMeetingTasks(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Task/RemovedMeetingTasks?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedMeetingTasks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedMeetingTasks(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedMeetingTasks(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedNotifications(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Task/RemovedNotifications?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedNotifications(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedNotifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedRelatedMembers(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Task/RemovedRelatedMembers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedRelatedMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedRelatedMembers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedRelatedMembers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removedTaskTaskAttachments(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Task/RemovedTaskTaskAttachments?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedTaskTaskAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedTaskTaskAttachments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedTaskTaskAttachments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param taskId (optional) 
     * @return Success
     */
    removeTask(taskId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Task/RemoveTask?";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTask(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveTask(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: DateTime | null | undefined, subscriptionEndDateEnd: DateTime | null | undefined, creationDateStart: DateTime | null | undefined, creationDateEnd: DateTime | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (subscriptionEndDateStart !== undefined && subscriptionEndDateStart !== null)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&";
        if (subscriptionEndDateEnd !== undefined && subscriptionEndDateEnd !== null)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&";
        if (creationDateStart !== undefined && creationDateStart !== null)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&";
        if (creationDateEnd !== undefined && creationDateEnd !== null)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&";
        if (editionId !== undefined && editionId !== null)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&";
        if (editionIdSpecified === null)
            throw new Error("The parameter 'editionIdSpecified' cannot be null.");
        else if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTenantListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTenant(body: CreateTenantInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenant(body: TenantEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockTenantAdmin(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberActivityOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDashboardDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getTopStats(): Observable<GetTopStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetTopStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStats(<any>response_);
                } catch (e) {
                    return <Observable<GetTopStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTopStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopStats(response: HttpResponseBase): Observable<GetTopStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTopStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTopStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfitShare(): Observable<GetProfitShareOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetProfitShare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfitShare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfitShare(<any>response_);
                } catch (e) {
                    return <Observable<GetProfitShareOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfitShareOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfitShare(response: HttpResponseBase): Observable<GetProfitShareOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfitShareOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfitShareOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDailySales(): Observable<GetDailySalesOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDailySales";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDailySales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDailySales(<any>response_);
                } catch (e) {
                    return <Observable<GetDailySalesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDailySalesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDailySales(response: HttpResponseBase): Observable<GetDailySalesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDailySalesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDailySalesOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSalesSummaryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRegionalStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTenant(body: RegisterTenantInput | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterTenantOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionsSelectOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: TenantSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnabledSocialLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnabledSocialLoginSettings(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginSettingsDto>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined && selectedTimezoneId !== null)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | null | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken !== undefined && refreshToken !== null)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<RefreshTokenResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RefreshTokenResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RefreshTokenResult>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(body: SendTwoFactorAuthCodeModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined && impersonationToken !== null)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param userDelegationId (optional) 
     * @param impersonationToken (optional) 
     * @return Success
     */
    delegatedImpersonatedAuthenticate(userDelegationId: number | undefined, impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/DelegatedImpersonatedAuthenticate?";
        if (userDelegationId === null)
            throw new Error("The parameter 'userDelegationId' cannot be null.");
        else if (userDelegationId !== undefined)
            url_ += "userDelegationId=" + encodeURIComponent("" + userDelegationId) + "&";
        if (impersonationToken !== undefined && impersonationToken !== null)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processDelegatedImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined && switchAccountToken !== null)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchedAccountAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (severity !== undefined && severity !== null)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TwitterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRequestToken(): Observable<TwitterGetRequestTokenResponse> {
        let url_ = this.baseUrl + "/api/Twitter/GetRequestToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestToken(<any>response_);
                } catch (e) {
                    return <Observable<TwitterGetRequestTokenResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<TwitterGetRequestTokenResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestToken(response: HttpResponseBase): Observable<TwitterGetRequestTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwitterGetRequestTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TwitterGetRequestTokenResponse>(<any>null);
    }

    /**
     * @param token (optional) 
     * @param verifier (optional) 
     * @return Success
     */
    getAccessToken(token: string | null | undefined, verifier: string | null | undefined): Observable<TwitterGetAccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Twitter/GetAccessToken?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (verifier !== undefined && verifier !== null)
            url_ += "verifier=" + encodeURIComponent("" + verifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessToken(<any>response_);
                } catch (e) {
                    return <Observable<TwitterGetAccessTokenResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<TwitterGetAccessTokenResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccessToken(response: HttpResponseBase): Observable<TwitterGetAccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwitterGetAccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TwitterGetAccessTokenResponse>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<ThemeSettingsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThemeSettingsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThemeSettingsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThemeSettingsDto[]>(<any>null);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName !== undefined && themeName !== null)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (permissions !== undefined && permissions !== null)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined && role !== null)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getUsersToExcel(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | undefined, sorting: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (permissions !== undefined && permissions !== null)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined && role !== null)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPermissionsForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserPermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUser(body: CreateOrUpdateUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockUser(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserDelegationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getDelegatedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfUserDelegationDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/GetDelegatedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDelegatedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDelegatedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDelegationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDelegationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDelegatedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserDelegationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDelegationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDelegationDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegateNewUser(body: CreateUserDelegationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/DelegateNewUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegateNewUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegateNewUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelegateNewUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeDelegation(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/RemoveDelegation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveDelegation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveDelegation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveDelegation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getActiveUserDelegations(): Observable<UserDelegationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/GetActiveUserDelegations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveUserDelegations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveUserDelegations(<any>response_);
                } catch (e) {
                    return <Observable<UserDelegationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDelegationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveUserDelegations(response: HttpResponseBase): Observable<UserDelegationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDelegationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDelegationDto[]>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    linkToUser(body: LinkToUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class VendorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param vendorId (optional) 
     * @param vendorName (optional) 
     * @param contactFirstName (optional) 
     * @param contactLastName (optional) 
     * @param email (optional) 
     * @param cellPhoneNumber (optional) 
     * @param address (optional) 
     * @param vendorType (optional) 
     * @param industry (optional) 
     * @param vendorCriticalRating (optional) 
     * @param vendorInitialRating (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllVendorList(filter: string | null | undefined, vendorId: string | null | undefined, vendorName: string | null | undefined, contactFirstName: string | null | undefined, contactLastName: string | null | undefined, email: string | null | undefined, cellPhoneNumber: string | null | undefined, address: string | null | undefined, vendorType: string | null | undefined, industry: string | null | undefined, vendorCriticalRating: string | null | undefined, vendorInitialRating: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetVendorListDto> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/GetAllVendorList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorName !== undefined && vendorName !== null)
            url_ += "VendorName=" + encodeURIComponent("" + vendorName) + "&";
        if (contactFirstName !== undefined && contactFirstName !== null)
            url_ += "ContactFirstName=" + encodeURIComponent("" + contactFirstName) + "&";
        if (contactLastName !== undefined && contactLastName !== null)
            url_ += "ContactLastName=" + encodeURIComponent("" + contactLastName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (cellPhoneNumber !== undefined && cellPhoneNumber !== null)
            url_ += "CellPhoneNumber=" + encodeURIComponent("" + cellPhoneNumber) + "&";
        if (address !== undefined && address !== null)
            url_ += "Address=" + encodeURIComponent("" + address) + "&";
        if (vendorType !== undefined && vendorType !== null)
            url_ += "VendorType=" + encodeURIComponent("" + vendorType) + "&";
        if (industry !== undefined && industry !== null)
            url_ += "Industry=" + encodeURIComponent("" + industry) + "&";
        if (vendorCriticalRating !== undefined && vendorCriticalRating !== null)
            url_ += "VendorCriticalRating=" + encodeURIComponent("" + vendorCriticalRating) + "&";
        if (vendorInitialRating !== undefined && vendorInitialRating !== null)
            url_ += "VendorInitialRating=" + encodeURIComponent("" + vendorInitialRating) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendorList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendorList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetVendorListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetVendorListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendorList(response: HttpResponseBase): Observable<PagedResultDtoOfGetVendorListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetVendorListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetVendorListDto>(<any>null);
    }

    /**
     * @param vendorId (optional) 
     * @return Success
     */
    getAllVendorInfo(vendorId: number | null | undefined): Observable<VendorInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/GetAllVendorInfo?";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendorInfo(<any>response_);
                } catch (e) {
                    return <Observable<VendorInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendorInfo(response: HttpResponseBase): Observable<VendorInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateVendor(body: VendorInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/CreateOrUpdateVendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateVendor(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateVendor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeVendorProdutType(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/RemoveVendorProdutType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveVendorProdutType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveVendorProdutType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveVendorProdutType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param vendorId (optional) 
     * @return Success
     */
    removedVendor(vendorId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/RemovedVendor?";
        if (vendorId === null)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else if (vendorId !== undefined)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovedVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovedVendor(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovedVendor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param vendorId (optional) 
     * @param vendorName (optional) 
     * @param contactFirstName (optional) 
     * @param contactLastName (optional) 
     * @param email (optional) 
     * @param cellPhoneNumber (optional) 
     * @param address (optional) 
     * @param vendorType (optional) 
     * @param industry (optional) 
     * @param vendorCriticalRating (optional) 
     * @param vendorInitialRating (optional) 
     * @return Success
     */
    getVendorExcel(filter: string | null | undefined, vendorId: string | null | undefined, vendorName: string | null | undefined, contactFirstName: string | null | undefined, contactLastName: string | null | undefined, email: string | null | undefined, cellPhoneNumber: string | null | undefined, address: string | null | undefined, vendorType: string | null | undefined, industry: string | null | undefined, vendorCriticalRating: string | null | undefined, vendorInitialRating: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/GetVendorExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorName !== undefined && vendorName !== null)
            url_ += "VendorName=" + encodeURIComponent("" + vendorName) + "&";
        if (contactFirstName !== undefined && contactFirstName !== null)
            url_ += "ContactFirstName=" + encodeURIComponent("" + contactFirstName) + "&";
        if (contactLastName !== undefined && contactLastName !== null)
            url_ += "ContactLastName=" + encodeURIComponent("" + contactLastName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (cellPhoneNumber !== undefined && cellPhoneNumber !== null)
            url_ += "CellPhoneNumber=" + encodeURIComponent("" + cellPhoneNumber) + "&";
        if (address !== undefined && address !== null)
            url_ += "Address=" + encodeURIComponent("" + address) + "&";
        if (vendorType !== undefined && vendorType !== null)
            url_ += "VendorType=" + encodeURIComponent("" + vendorType) + "&";
        if (industry !== undefined && industry !== null)
            url_ += "Industry=" + encodeURIComponent("" + industry) + "&";
        if (vendorCriticalRating !== undefined && vendorCriticalRating !== null)
            url_ += "VendorCriticalRating=" + encodeURIComponent("" + vendorCriticalRating) + "&";
        if (vendorInitialRating !== undefined && vendorInitialRating !== null)
            url_ += "VendorInitialRating=" + encodeURIComponent("" + vendorInitialRating) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class VirtualAssetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param virtualAssetId (optional) 
     * @return Success
     */
    getAllVirtualAssetInfo(virtualAssetId: number | null | undefined): Observable<VirtualAssetDto> {
        let url_ = this.baseUrl + "/api/services/app/VirtualAsset/GetAllVirtualAssetInfo?";
        if (virtualAssetId !== undefined && virtualAssetId !== null)
            url_ += "virtualAssetId=" + encodeURIComponent("" + virtualAssetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVirtualAssetInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVirtualAssetInfo(<any>response_);
                } catch (e) {
                    return <Observable<VirtualAssetDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VirtualAssetDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVirtualAssetInfo(response: HttpResponseBase): Observable<VirtualAssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VirtualAssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VirtualAssetDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateVirtualAsset(body: VirtualAssetDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VirtualAsset/CreateOrUpdateVirtualAsset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateVirtualAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateVirtualAsset(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateVirtualAsset(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param organizationId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllVirtualAssetList(filter: string | null | undefined, organizationId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfVirtualAssetListDto> {
        let url_ = this.baseUrl + "/api/services/app/VirtualAsset/GetAllVirtualAssetList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVirtualAssetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVirtualAssetList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfVirtualAssetListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfVirtualAssetListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVirtualAssetList(response: HttpResponseBase): Observable<PagedResultDtoOfVirtualAssetListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVirtualAssetListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfVirtualAssetListDto>(<any>null);
    }

    /**
     * @param virtualAssetId (optional) 
     * @return Success
     */
    removeVirtualAsset(virtualAssetId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VirtualAsset/RemoveVirtualAsset?";
        if (virtualAssetId === null)
            throw new Error("The parameter 'virtualAssetId' cannot be null.");
        else if (virtualAssetId !== undefined)
            url_ += "virtualAssetId=" + encodeURIComponent("" + virtualAssetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveVirtualAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveVirtualAsset(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveVirtualAsset(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeItService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VirtualAsset/RemoveItService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveItService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessProcess(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VirtualAsset/RemoveBusinessProcess?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessProcess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessProcess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeBusinessService(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VirtualAsset/RemoveBusinessService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBusinessService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBusinessService(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBusinessService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WebhookEventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<WebhookEvent> {
        let url_ = this.baseUrl + "/api/services/app/WebhookEvent/Get?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WebhookEvent>><any>_observableThrow(e);
                }
            } else
                return <Observable<WebhookEvent>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WebhookEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WebhookEvent>(<any>null);
    }
}

@Injectable()
export class WebhookSendAttemptServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subscriptionId (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSendAttempts(subscriptionId: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttempts?";
        if (subscriptionId !== undefined && subscriptionId !== null)
            url_ += "SubscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSendAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSendAttempts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAllSendAttemptsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAllSendAttemptsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSendAttempts(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllSendAttemptsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAllSendAttemptsOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllSendAttemptsOfWebhookEvent(id: string | null | undefined): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttemptsOfWebhookEvent?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSendAttemptsOfWebhookEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSendAttemptsOfWebhookEvent(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSendAttemptsOfWebhookEvent(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>(<any>null);
    }

    /**
     * @param sendAttemptId (optional) 
     * @return Success
     */
    resend(sendAttemptId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/Resend?";
        if (sendAttemptId !== undefined && sendAttemptId !== null)
            url_ += "sendAttemptId=" + encodeURIComponent("" + sendAttemptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResend(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WebhookSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    publishTestWebhook(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/PublishTestWebhook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishTestWebhook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishTestWebhook(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPublishTestWebhook(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getAllSubscriptions(): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubscriptions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllSubscriptionsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllSubscriptionsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubscriptions(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllSubscriptionsOutput>(<any>null);
    }

    /**
     * @param subscriptionId (optional) 
     * @return Success
     */
    getSubscription(subscriptionId: string | null | undefined): Observable<WebhookSubscription> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetSubscription?";
        if (subscriptionId !== undefined && subscriptionId !== null)
            url_ += "subscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscription(<any>response_);
                } catch (e) {
                    return <Observable<WebhookSubscription>><any>_observableThrow(e);
                }
            } else
                return <Observable<WebhookSubscription>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscription(response: HttpResponseBase): Observable<WebhookSubscription> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookSubscription.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WebhookSubscription>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSubscription(body: WebhookSubscription | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/AddSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubscription(body: WebhookSubscription | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateWebhookSubscription(body: ActivateWebhookSubscriptionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/ActivateWebhookSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateWebhookSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateWebhookSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateWebhookSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    isSubscribed(webhookName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/IsSubscribed?";
        if (webhookName !== undefined && webhookName !== null)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsSubscribed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsSubscribed(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsSubscribed(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    getAllSubscriptionsIfFeaturesGranted(webhookName: string | null | undefined): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptionsIfFeaturesGranted?";
        if (webhookName !== undefined && webhookName !== null)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubscriptionsIfFeaturesGranted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubscriptionsIfFeaturesGranted(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllSubscriptionsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllSubscriptionsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubscriptionsIfFeaturesGranted(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllSubscriptionsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getAllAvailableWebhooks(): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllAvailableWebhooks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAvailableWebhooks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAvailableWebhooks(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAvailableWebhooks(response: HttpResponseBase): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllAvailableWebhooksOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllAvailableWebhooksOutput>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLatestWebLogsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    Available = 1,
    InActive = 2,
    NotFound = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.serverRootAddress = _data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number;
    resetCode!: string | undefined;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resetCode = _data["resetCode"];
            this.password = _data["password"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data; 
    }
}

export interface IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.confirmationCode = _data["confirmationCode"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.impersonationToken = _data["impersonationToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class DelegatedImpersonateInput implements IDelegatedImpersonateInput {
    userDelegationId!: number;

    constructor(data?: IDelegatedImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userDelegationId = _data["userDelegationId"];
        }
    }

    static fromJS(data: any): DelegatedImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new DelegatedImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDelegationId"] = this.userDelegationId;
        return data; 
    }
}

export interface IDelegatedImpersonateInput {
    userDelegationId: number;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetTenantId = _data["targetTenantId"];
            this.targetUserId = _data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.switchAccountToken = _data["switchAccountToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class CountryDto implements ICountryDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICountryDto {
    id: number;
    name: string | undefined;
}

export class GetDynamicValueDto implements IGetDynamicValueDto {
    id!: number;
    value!: string | undefined;

    constructor(data?: IGetDynamicValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GetDynamicValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDynamicValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data; 
    }
}

export interface IGetDynamicValueDto {
    id: number;
    value: string | undefined;
}

export class GetOrganizationDto implements IGetOrganizationDto {
    id!: number;
    companyName!: string | undefined;
    companyId!: string | undefined;

    constructor(data?: IGetOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): GetOrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["companyId"] = this.companyId;
        return data; 
    }
}

export interface IGetOrganizationDto {
    id: number;
    companyName: string | undefined;
    companyId: string | undefined;
}

export class BusinessUnitPrimaryDto implements IBusinessUnitPrimaryDto {
    id!: number;
    businessUnitTitle!: string | undefined;
    lockThreatOrganizationId!: number | undefined;

    constructor(data?: IBusinessUnitPrimaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessUnitTitle = _data["businessUnitTitle"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
        }
    }

    static fromJS(data: any): BusinessUnitPrimaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUnitPrimaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessUnitTitle"] = this.businessUnitTitle;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        return data; 
    }
}

export interface IBusinessUnitPrimaryDto {
    id: number;
    businessUnitTitle: string | undefined;
    lockThreatOrganizationId: number | undefined;
}

export class BusinessUnitGaurdianDto implements IBusinessUnitGaurdianDto {
    id!: number;
    businessUnitTitle!: string | undefined;
    lockThreatOrganizationId!: number | undefined;

    constructor(data?: IBusinessUnitGaurdianDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessUnitTitle = _data["businessUnitTitle"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
        }
    }

    static fromJS(data: any): BusinessUnitGaurdianDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUnitGaurdianDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessUnitTitle"] = this.businessUnitTitle;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        return data; 
    }
}

export interface IBusinessUnitGaurdianDto {
    id: number;
    businessUnitTitle: string | undefined;
    lockThreatOrganizationId: number | undefined;
}

export class BusinessServiceOwner implements IBusinessServiceOwner {
    id!: number;
    employeeName!: string | undefined;
    organizationId!: number;

    constructor(data?: IBusinessServiceOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeName = _data["employeeName"];
            this.organizationId = _data["organizationId"];
        }
    }

    static fromJS(data: any): BusinessServiceOwner {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessServiceOwner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeName"] = this.employeeName;
        data["organizationId"] = this.organizationId;
        return data; 
    }
}

export interface IBusinessServiceOwner {
    id: number;
    employeeName: string | undefined;
    organizationId: number;
}

export class ITserviceListDto implements IITserviceListDto {
    id!: number;
    itServicesId!: string | undefined;
    itServiceName!: string | undefined;

    constructor(data?: IITserviceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itServicesId = _data["itServicesId"];
            this.itServiceName = _data["itServiceName"];
        }
    }

    static fromJS(data: any): ITserviceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ITserviceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itServicesId"] = this.itServicesId;
        data["itServiceName"] = this.itServiceName;
        return data; 
    }
}

export interface IITserviceListDto {
    id: number;
    itServicesId: string | undefined;
    itServiceName: string | undefined;
}

export class BusinessServiceSDto implements IBusinessServiceSDto {
    id!: number | undefined;
    businessServiceName!: string | undefined;

    constructor(data?: IBusinessServiceSDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessServiceName = _data["businessServiceName"];
        }
    }

    static fromJS(data: any): BusinessServiceSDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessServiceSDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessServiceName"] = this.businessServiceName;
        return data; 
    }
}

export interface IBusinessServiceSDto {
    id: number | undefined;
    businessServiceName: string | undefined;
}

export class BusinessProcessDetailDto implements IBusinessProcessDetailDto {
    id!: number;
    businessProcessName!: string | undefined;

    constructor(data?: IBusinessProcessDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessProcessName = _data["businessProcessName"];
        }
    }

    static fromJS(data: any): BusinessProcessDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessProcessName"] = this.businessProcessName;
        return data; 
    }
}

export interface IBusinessProcessDetailDto {
    id: number;
    businessProcessName: string | undefined;
}

export class AssetInformationITserviceDto implements IAssetInformationITserviceDto {
    id!: number;
    assetInformatinId!: number | undefined;
    itServiceId!: number | undefined;

    constructor(data?: IAssetInformationITserviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetInformatinId = _data["assetInformatinId"];
            this.itServiceId = _data["itServiceId"];
        }
    }

    static fromJS(data: any): AssetInformationITserviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetInformationITserviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetInformatinId"] = this.assetInformatinId;
        data["itServiceId"] = this.itServiceId;
        return data; 
    }
}

export interface IAssetInformationITserviceDto {
    id: number;
    assetInformatinId: number | undefined;
    itServiceId: number | undefined;
}

export class AssetInformationBusinessprocessDto implements IAssetInformationBusinessprocessDto {
    id!: number;
    assetInformatinId!: number | undefined;
    businessProcessId!: number | undefined;

    constructor(data?: IAssetInformationBusinessprocessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetInformatinId = _data["assetInformatinId"];
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static fromJS(data: any): AssetInformationBusinessprocessDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetInformationBusinessprocessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetInformatinId"] = this.assetInformatinId;
        data["businessProcessId"] = this.businessProcessId;
        return data; 
    }
}

export interface IAssetInformationBusinessprocessDto {
    id: number;
    assetInformatinId: number | undefined;
    businessProcessId: number | undefined;
}

export class AssetInformationBusinessServiceDto implements IAssetInformationBusinessServiceDto {
    id!: number;
    assetInformatinId!: number | undefined;
    businessServiceId!: number | undefined;

    constructor(data?: IAssetInformationBusinessServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetInformatinId = _data["assetInformatinId"];
            this.businessServiceId = _data["businessServiceId"];
        }
    }

    static fromJS(data: any): AssetInformationBusinessServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetInformationBusinessServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetInformatinId"] = this.assetInformatinId;
        data["businessServiceId"] = this.businessServiceId;
        return data; 
    }
}

export interface IAssetInformationBusinessServiceDto {
    id: number;
    assetInformatinId: number | undefined;
    businessServiceId: number | undefined;
}

export class GetAssetInformationDto implements IGetAssetInformationDto {
    tenantId!: number | undefined;
    assetId!: string | undefined;
    assetTitle!: string | undefined;
    addressLineOne!: string | undefined;
    addressLineTwo!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number | undefined;
    countries!: CountryDto[] | undefined;
    assetIdLV!: number | undefined;
    assetTypeId!: number | undefined;
    assetTypes!: GetDynamicValueDto[] | undefined;
    assetCategoryId!: number | undefined;
    assetCategorys!: GetDynamicValueDto[] | undefined;
    assetLabelId!: number | undefined;
    assetLabels!: GetDynamicValueDto[] | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    businessUnitOwnerId!: number | undefined;
    businessUnitOwners!: BusinessUnitPrimaryDto[] | undefined;
    businessUnitGaurdianId!: number | undefined;
    businessUnitGaurdians!: BusinessUnitGaurdianDto[] | undefined;
    employeeId!: number | undefined;
    employeesList!: BusinessServiceOwner[] | undefined;
    confidentialityId!: number | undefined;
    confidentialitys!: GetDynamicValueDto[] | undefined;
    availibilityId!: number | undefined;
    availibilitys!: GetDynamicValueDto[] | undefined;
    integrityId!: number | undefined;
    integritys!: GetDynamicValueDto[] | undefined;
    otherId!: number | undefined;
    otheres!: GetDynamicValueDto[] | undefined;
    iTserviceLists!: ITserviceListDto[] | undefined;
    businessServices!: BusinessServiceSDto[] | undefined;
    businessProcess!: BusinessProcessDetailDto[] | undefined;
    selectedAssetInformationITservices!: AssetInformationITserviceDto[] | undefined;
    selectedAssetInformationBusinessprocess!: AssetInformationBusinessprocessDto[] | undefined;
    selectedAssetInformationBusinessServices!: AssetInformationBusinessServiceDto[] | undefined;
    removedAssetInformationITservice!: number[] | undefined;
    removedAssetInformationBusinessprocess!: number[] | undefined;
    removedAssetInformationBusinessService!: number[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IGetAssetInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.assetId = _data["assetId"];
            this.assetTitle = _data["assetTitle"];
            this.addressLineOne = _data["addressLineOne"];
            this.addressLineTwo = _data["addressLineTwo"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(CountryDto.fromJS(item));
            }
            this.assetIdLV = _data["assetIdLV"];
            this.assetTypeId = _data["assetTypeId"];
            if (Array.isArray(_data["assetTypes"])) {
                this.assetTypes = [] as any;
                for (let item of _data["assetTypes"])
                    this.assetTypes!.push(GetDynamicValueDto.fromJS(item));
            }
            this.assetCategoryId = _data["assetCategoryId"];
            if (Array.isArray(_data["assetCategorys"])) {
                this.assetCategorys = [] as any;
                for (let item of _data["assetCategorys"])
                    this.assetCategorys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.assetLabelId = _data["assetLabelId"];
            if (Array.isArray(_data["assetLabels"])) {
                this.assetLabels = [] as any;
                for (let item of _data["assetLabels"])
                    this.assetLabels!.push(GetDynamicValueDto.fromJS(item));
            }
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            this.businessUnitOwnerId = _data["businessUnitOwnerId"];
            if (Array.isArray(_data["businessUnitOwners"])) {
                this.businessUnitOwners = [] as any;
                for (let item of _data["businessUnitOwners"])
                    this.businessUnitOwners!.push(BusinessUnitPrimaryDto.fromJS(item));
            }
            this.businessUnitGaurdianId = _data["businessUnitGaurdianId"];
            if (Array.isArray(_data["businessUnitGaurdians"])) {
                this.businessUnitGaurdians = [] as any;
                for (let item of _data["businessUnitGaurdians"])
                    this.businessUnitGaurdians!.push(BusinessUnitGaurdianDto.fromJS(item));
            }
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["employeesList"])) {
                this.employeesList = [] as any;
                for (let item of _data["employeesList"])
                    this.employeesList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.confidentialityId = _data["confidentialityId"];
            if (Array.isArray(_data["confidentialitys"])) {
                this.confidentialitys = [] as any;
                for (let item of _data["confidentialitys"])
                    this.confidentialitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.availibilityId = _data["availibilityId"];
            if (Array.isArray(_data["availibilitys"])) {
                this.availibilitys = [] as any;
                for (let item of _data["availibilitys"])
                    this.availibilitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.integrityId = _data["integrityId"];
            if (Array.isArray(_data["integritys"])) {
                this.integritys = [] as any;
                for (let item of _data["integritys"])
                    this.integritys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.otherId = _data["otherId"];
            if (Array.isArray(_data["otheres"])) {
                this.otheres = [] as any;
                for (let item of _data["otheres"])
                    this.otheres!.push(GetDynamicValueDto.fromJS(item));
            }
            if (Array.isArray(_data["iTserviceLists"])) {
                this.iTserviceLists = [] as any;
                for (let item of _data["iTserviceLists"])
                    this.iTserviceLists!.push(ITserviceListDto.fromJS(item));
            }
            if (Array.isArray(_data["businessServices"])) {
                this.businessServices = [] as any;
                for (let item of _data["businessServices"])
                    this.businessServices!.push(BusinessServiceSDto.fromJS(item));
            }
            if (Array.isArray(_data["businessProcess"])) {
                this.businessProcess = [] as any;
                for (let item of _data["businessProcess"])
                    this.businessProcess!.push(BusinessProcessDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAssetInformationITservices"])) {
                this.selectedAssetInformationITservices = [] as any;
                for (let item of _data["selectedAssetInformationITservices"])
                    this.selectedAssetInformationITservices!.push(AssetInformationITserviceDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAssetInformationBusinessprocess"])) {
                this.selectedAssetInformationBusinessprocess = [] as any;
                for (let item of _data["selectedAssetInformationBusinessprocess"])
                    this.selectedAssetInformationBusinessprocess!.push(AssetInformationBusinessprocessDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAssetInformationBusinessServices"])) {
                this.selectedAssetInformationBusinessServices = [] as any;
                for (let item of _data["selectedAssetInformationBusinessServices"])
                    this.selectedAssetInformationBusinessServices!.push(AssetInformationBusinessServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["removedAssetInformationITservice"])) {
                this.removedAssetInformationITservice = [] as any;
                for (let item of _data["removedAssetInformationITservice"])
                    this.removedAssetInformationITservice!.push(item);
            }
            if (Array.isArray(_data["removedAssetInformationBusinessprocess"])) {
                this.removedAssetInformationBusinessprocess = [] as any;
                for (let item of _data["removedAssetInformationBusinessprocess"])
                    this.removedAssetInformationBusinessprocess!.push(item);
            }
            if (Array.isArray(_data["removedAssetInformationBusinessService"])) {
                this.removedAssetInformationBusinessService = [] as any;
                for (let item of _data["removedAssetInformationBusinessService"])
                    this.removedAssetInformationBusinessService!.push(item);
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAssetInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["assetId"] = this.assetId;
        data["assetTitle"] = this.assetTitle;
        data["addressLineOne"] = this.addressLineOne;
        data["addressLineTwo"] = this.addressLineTwo;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        data["assetIdLV"] = this.assetIdLV;
        data["assetTypeId"] = this.assetTypeId;
        if (Array.isArray(this.assetTypes)) {
            data["assetTypes"] = [];
            for (let item of this.assetTypes)
                data["assetTypes"].push(item.toJSON());
        }
        data["assetCategoryId"] = this.assetCategoryId;
        if (Array.isArray(this.assetCategorys)) {
            data["assetCategorys"] = [];
            for (let item of this.assetCategorys)
                data["assetCategorys"].push(item.toJSON());
        }
        data["assetLabelId"] = this.assetLabelId;
        if (Array.isArray(this.assetLabels)) {
            data["assetLabels"] = [];
            for (let item of this.assetLabels)
                data["assetLabels"].push(item.toJSON());
        }
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        data["businessUnitOwnerId"] = this.businessUnitOwnerId;
        if (Array.isArray(this.businessUnitOwners)) {
            data["businessUnitOwners"] = [];
            for (let item of this.businessUnitOwners)
                data["businessUnitOwners"].push(item.toJSON());
        }
        data["businessUnitGaurdianId"] = this.businessUnitGaurdianId;
        if (Array.isArray(this.businessUnitGaurdians)) {
            data["businessUnitGaurdians"] = [];
            for (let item of this.businessUnitGaurdians)
                data["businessUnitGaurdians"].push(item.toJSON());
        }
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.employeesList)) {
            data["employeesList"] = [];
            for (let item of this.employeesList)
                data["employeesList"].push(item.toJSON());
        }
        data["confidentialityId"] = this.confidentialityId;
        if (Array.isArray(this.confidentialitys)) {
            data["confidentialitys"] = [];
            for (let item of this.confidentialitys)
                data["confidentialitys"].push(item.toJSON());
        }
        data["availibilityId"] = this.availibilityId;
        if (Array.isArray(this.availibilitys)) {
            data["availibilitys"] = [];
            for (let item of this.availibilitys)
                data["availibilitys"].push(item.toJSON());
        }
        data["integrityId"] = this.integrityId;
        if (Array.isArray(this.integritys)) {
            data["integritys"] = [];
            for (let item of this.integritys)
                data["integritys"].push(item.toJSON());
        }
        data["otherId"] = this.otherId;
        if (Array.isArray(this.otheres)) {
            data["otheres"] = [];
            for (let item of this.otheres)
                data["otheres"].push(item.toJSON());
        }
        if (Array.isArray(this.iTserviceLists)) {
            data["iTserviceLists"] = [];
            for (let item of this.iTserviceLists)
                data["iTserviceLists"].push(item.toJSON());
        }
        if (Array.isArray(this.businessServices)) {
            data["businessServices"] = [];
            for (let item of this.businessServices)
                data["businessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.businessProcess)) {
            data["businessProcess"] = [];
            for (let item of this.businessProcess)
                data["businessProcess"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAssetInformationITservices)) {
            data["selectedAssetInformationITservices"] = [];
            for (let item of this.selectedAssetInformationITservices)
                data["selectedAssetInformationITservices"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAssetInformationBusinessprocess)) {
            data["selectedAssetInformationBusinessprocess"] = [];
            for (let item of this.selectedAssetInformationBusinessprocess)
                data["selectedAssetInformationBusinessprocess"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAssetInformationBusinessServices)) {
            data["selectedAssetInformationBusinessServices"] = [];
            for (let item of this.selectedAssetInformationBusinessServices)
                data["selectedAssetInformationBusinessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.removedAssetInformationITservice)) {
            data["removedAssetInformationITservice"] = [];
            for (let item of this.removedAssetInformationITservice)
                data["removedAssetInformationITservice"].push(item);
        }
        if (Array.isArray(this.removedAssetInformationBusinessprocess)) {
            data["removedAssetInformationBusinessprocess"] = [];
            for (let item of this.removedAssetInformationBusinessprocess)
                data["removedAssetInformationBusinessprocess"].push(item);
        }
        if (Array.isArray(this.removedAssetInformationBusinessService)) {
            data["removedAssetInformationBusinessService"] = [];
            for (let item of this.removedAssetInformationBusinessService)
                data["removedAssetInformationBusinessService"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetAssetInformationDto {
    tenantId: number | undefined;
    assetId: string | undefined;
    assetTitle: string | undefined;
    addressLineOne: string | undefined;
    addressLineTwo: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    countryId: number | undefined;
    countries: CountryDto[] | undefined;
    assetIdLV: number | undefined;
    assetTypeId: number | undefined;
    assetTypes: GetDynamicValueDto[] | undefined;
    assetCategoryId: number | undefined;
    assetCategorys: GetDynamicValueDto[] | undefined;
    assetLabelId: number | undefined;
    assetLabels: GetDynamicValueDto[] | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    businessUnitOwnerId: number | undefined;
    businessUnitOwners: BusinessUnitPrimaryDto[] | undefined;
    businessUnitGaurdianId: number | undefined;
    businessUnitGaurdians: BusinessUnitGaurdianDto[] | undefined;
    employeeId: number | undefined;
    employeesList: BusinessServiceOwner[] | undefined;
    confidentialityId: number | undefined;
    confidentialitys: GetDynamicValueDto[] | undefined;
    availibilityId: number | undefined;
    availibilitys: GetDynamicValueDto[] | undefined;
    integrityId: number | undefined;
    integritys: GetDynamicValueDto[] | undefined;
    otherId: number | undefined;
    otheres: GetDynamicValueDto[] | undefined;
    iTserviceLists: ITserviceListDto[] | undefined;
    businessServices: BusinessServiceSDto[] | undefined;
    businessProcess: BusinessProcessDetailDto[] | undefined;
    selectedAssetInformationITservices: AssetInformationITserviceDto[] | undefined;
    selectedAssetInformationBusinessprocess: AssetInformationBusinessprocessDto[] | undefined;
    selectedAssetInformationBusinessServices: AssetInformationBusinessServiceDto[] | undefined;
    removedAssetInformationITservice: number[] | undefined;
    removedAssetInformationBusinessprocess: number[] | undefined;
    removedAssetInformationBusinessService: number[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class DynamicProperty implements IDynamicProperty {
    propertyName!: string | undefined;
    displayName!: string | undefined;
    inputType!: string | undefined;
    permission!: string | undefined;
    tenantId!: number | undefined;
    dynamicPropertyValues!: DynamicPropertyValue[] | undefined;
    id!: number;

    constructor(data?: IDynamicProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.displayName = _data["displayName"];
            this.inputType = _data["inputType"];
            this.permission = _data["permission"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["dynamicPropertyValues"])) {
                this.dynamicPropertyValues = [] as any;
                for (let item of _data["dynamicPropertyValues"])
                    this.dynamicPropertyValues!.push(DynamicPropertyValue.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicProperty {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["displayName"] = this.displayName;
        data["inputType"] = this.inputType;
        data["permission"] = this.permission;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.dynamicPropertyValues)) {
            data["dynamicPropertyValues"] = [];
            for (let item of this.dynamicPropertyValues)
                data["dynamicPropertyValues"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicProperty {
    propertyName: string | undefined;
    displayName: string | undefined;
    inputType: string | undefined;
    permission: string | undefined;
    tenantId: number | undefined;
    dynamicPropertyValues: DynamicPropertyValue[] | undefined;
    id: number;
}

export class DynamicPropertyValue implements IDynamicPropertyValue {
    value!: string;
    tenantId!: number | undefined;
    dynamicPropertyId!: number;
    dynamicProperty!: DynamicProperty;
    id!: number;

    constructor(data?: IDynamicPropertyValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.dynamicPropertyId = _data["dynamicPropertyId"];
            this.dynamicProperty = _data["dynamicProperty"] ? DynamicProperty.fromJS(_data["dynamicProperty"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyValue {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["dynamicPropertyId"] = this.dynamicPropertyId;
        data["dynamicProperty"] = this.dynamicProperty ? this.dynamicProperty.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicPropertyValue {
    value: string;
    tenantId: number | undefined;
    dynamicPropertyId: number;
    dynamicProperty: DynamicProperty;
    id: number;
}

export class GetAssetInformationListDto implements IGetAssetInformationListDto {
    tenantId!: number | undefined;
    assetId!: string | undefined;
    assetTitle!: string | undefined;
    addressLineOne!: string | undefined;
    addressLineTwo!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number | undefined;
    country!: DynamicPropertyValue;
    assetIdLV!: number | undefined;
    assetTypeId!: number | undefined;
    assetType!: DynamicPropertyValue;
    assetCategoryId!: number | undefined;
    assetCategory!: DynamicPropertyValue;
    assetLabelId!: number | undefined;
    assetLabel!: DynamicPropertyValue;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationDto;
    employeeId!: number | undefined;
    employee!: BusinessServiceOwner;
    confidentialityId!: number | undefined;
    confidentiality!: DynamicPropertyValue;
    availibilityId!: number | undefined;
    availibility!: DynamicPropertyValue;
    integrityId!: number | undefined;
    integrity!: DynamicPropertyValue;
    otherId!: number | undefined;
    other!: DynamicPropertyValue;
    id!: number;

    constructor(data?: IGetAssetInformationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.assetId = _data["assetId"];
            this.assetTitle = _data["assetTitle"];
            this.addressLineOne = _data["addressLineOne"];
            this.addressLineTwo = _data["addressLineTwo"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? DynamicPropertyValue.fromJS(_data["country"]) : <any>undefined;
            this.assetIdLV = _data["assetIdLV"];
            this.assetTypeId = _data["assetTypeId"];
            this.assetType = _data["assetType"] ? DynamicPropertyValue.fromJS(_data["assetType"]) : <any>undefined;
            this.assetCategoryId = _data["assetCategoryId"];
            this.assetCategory = _data["assetCategory"] ? DynamicPropertyValue.fromJS(_data["assetCategory"]) : <any>undefined;
            this.assetLabelId = _data["assetLabelId"];
            this.assetLabel = _data["assetLabel"] ? DynamicPropertyValue.fromJS(_data["assetLabel"]) : <any>undefined;
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? BusinessServiceOwner.fromJS(_data["employee"]) : <any>undefined;
            this.confidentialityId = _data["confidentialityId"];
            this.confidentiality = _data["confidentiality"] ? DynamicPropertyValue.fromJS(_data["confidentiality"]) : <any>undefined;
            this.availibilityId = _data["availibilityId"];
            this.availibility = _data["availibility"] ? DynamicPropertyValue.fromJS(_data["availibility"]) : <any>undefined;
            this.integrityId = _data["integrityId"];
            this.integrity = _data["integrity"] ? DynamicPropertyValue.fromJS(_data["integrity"]) : <any>undefined;
            this.otherId = _data["otherId"];
            this.other = _data["other"] ? DynamicPropertyValue.fromJS(_data["other"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAssetInformationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetInformationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["assetId"] = this.assetId;
        data["assetTitle"] = this.assetTitle;
        data["addressLineOne"] = this.addressLineOne;
        data["addressLineTwo"] = this.addressLineTwo;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["assetIdLV"] = this.assetIdLV;
        data["assetTypeId"] = this.assetTypeId;
        data["assetType"] = this.assetType ? this.assetType.toJSON() : <any>undefined;
        data["assetCategoryId"] = this.assetCategoryId;
        data["assetCategory"] = this.assetCategory ? this.assetCategory.toJSON() : <any>undefined;
        data["assetLabelId"] = this.assetLabelId;
        data["assetLabel"] = this.assetLabel ? this.assetLabel.toJSON() : <any>undefined;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["confidentialityId"] = this.confidentialityId;
        data["confidentiality"] = this.confidentiality ? this.confidentiality.toJSON() : <any>undefined;
        data["availibilityId"] = this.availibilityId;
        data["availibility"] = this.availibility ? this.availibility.toJSON() : <any>undefined;
        data["integrityId"] = this.integrityId;
        data["integrity"] = this.integrity ? this.integrity.toJSON() : <any>undefined;
        data["otherId"] = this.otherId;
        data["other"] = this.other ? this.other.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetAssetInformationListDto {
    tenantId: number | undefined;
    assetId: string | undefined;
    assetTitle: string | undefined;
    addressLineOne: string | undefined;
    addressLineTwo: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    countryId: number | undefined;
    country: DynamicPropertyValue;
    assetIdLV: number | undefined;
    assetTypeId: number | undefined;
    assetType: DynamicPropertyValue;
    assetCategoryId: number | undefined;
    assetCategory: DynamicPropertyValue;
    assetLabelId: number | undefined;
    assetLabel: DynamicPropertyValue;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationDto;
    employeeId: number | undefined;
    employee: BusinessServiceOwner;
    confidentialityId: number | undefined;
    confidentiality: DynamicPropertyValue;
    availibilityId: number | undefined;
    availibility: DynamicPropertyValue;
    integrityId: number | undefined;
    integrity: DynamicPropertyValue;
    otherId: number | undefined;
    other: DynamicPropertyValue;
    id: number;
}

export class PagedResultDtoOfGetAssetInformationListDto implements IPagedResultDtoOfGetAssetInformationListDto {
    totalCount!: number;
    items!: GetAssetInformationListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAssetInformationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAssetInformationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAssetInformationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAssetInformationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAssetInformationListDto {
    totalCount: number;
    items: GetAssetInformationListDto[] | undefined;
}

export enum AuditType {
    InternalAudit = 1,
    ExternalAudit = 2,
    CertificationAudit = 3,
    RegulatoryAudit = 4,
    CustomerAudit = 5,
    SupplierAudit = 6,
    Investigation = 7,
    ComplianceAudit = 8,
    SpecialReviews = 9,
    OperationalAudit = 10,
    FinancialAudit = 11,
    PerformanceAudit = 12,
    Other = 13,
}

export class VendorListDto implements IVendorListDto {
    id!: number;
    vendorName!: string | undefined;

    constructor(data?: IVendorListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vendorName = _data["vendorName"];
        }
    }

    static fromJS(data: any): VendorListDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vendorName"] = this.vendorName;
        return data; 
    }
}

export interface IVendorListDto {
    id: number;
    vendorName: string | undefined;
}

export class ProjectListDetailsDto implements IProjectListDetailsDto {
    id!: number;
    projectName!: string | undefined;

    constructor(data?: IProjectListDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectName = _data["projectName"];
        }
    }

    static fromJS(data: any): ProjectListDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectListDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectName"] = this.projectName;
        return data; 
    }
}

export interface IProjectListDetailsDto {
    id: number;
    projectName: string | undefined;
}

export class FacilitieDatacenterListDto implements IFacilitieDatacenterListDto {
    id!: number;
    facilityName!: string | undefined;

    constructor(data?: IFacilitieDatacenterListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.facilityName = _data["facilityName"];
        }
    }

    static fromJS(data: any): FacilitieDatacenterListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FacilitieDatacenterListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["facilityName"] = this.facilityName;
        return data; 
    }
}

export interface IFacilitieDatacenterListDto {
    id: number;
    facilityName: string | undefined;
}

export class FindingDetailsDto implements IFindingDetailsDto {
    id!: number;
    findingTitle!: string | undefined;

    constructor(data?: IFindingDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingTitle = _data["findingTitle"];
        }
    }

    static fromJS(data: any): FindingDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingTitle"] = this.findingTitle;
        return data; 
    }
}

export interface IFindingDetailsDto {
    id: number;
    findingTitle: string | undefined;
}

export class SytemApplicationDto implements ISytemApplicationDto {
    id!: number;
    systemApplicationName!: string | undefined;

    constructor(data?: ISytemApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.systemApplicationName = _data["systemApplicationName"];
        }
    }

    static fromJS(data: any): SytemApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SytemApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["systemApplicationName"] = this.systemApplicationName;
        return data; 
    }
}

export interface ISytemApplicationDto {
    id: number;
    systemApplicationName: string | undefined;
}

export class AuditAuditorDto implements IAuditAuditorDto {
    id!: number;
    auditId!: number | undefined;
    employeeId!: number | undefined;

    constructor(data?: IAuditAuditorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.auditId = _data["auditId"];
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): AuditAuditorDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditAuditorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["auditId"] = this.auditId;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface IAuditAuditorDto {
    id: number;
    auditId: number | undefined;
    employeeId: number | undefined;
}

export class AuditBusinessProcessDto implements IAuditBusinessProcessDto {
    id!: number;
    auditId!: number | undefined;
    businessProcessId!: number | undefined;

    constructor(data?: IAuditBusinessProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.auditId = _data["auditId"];
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static fromJS(data: any): AuditBusinessProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditBusinessProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["auditId"] = this.auditId;
        data["businessProcessId"] = this.businessProcessId;
        return data; 
    }
}

export interface IAuditBusinessProcessDto {
    id: number;
    auditId: number | undefined;
    businessProcessId: number | undefined;
}

export class AuditBusinessServiceDto implements IAuditBusinessServiceDto {
    id!: number;
    auditId!: number | undefined;
    businessServiceId!: number | undefined;

    constructor(data?: IAuditBusinessServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.auditId = _data["auditId"];
            this.businessServiceId = _data["businessServiceId"];
        }
    }

    static fromJS(data: any): AuditBusinessServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditBusinessServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["auditId"] = this.auditId;
        data["businessServiceId"] = this.businessServiceId;
        return data; 
    }
}

export interface IAuditBusinessServiceDto {
    id: number;
    auditId: number | undefined;
    businessServiceId: number | undefined;
}

export class AuditFacilitieDatacenterDto implements IAuditFacilitieDatacenterDto {
    id!: number;
    auditId!: number | undefined;
    facilitieDatacenterId!: number | undefined;

    constructor(data?: IAuditFacilitieDatacenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.auditId = _data["auditId"];
            this.facilitieDatacenterId = _data["facilitieDatacenterId"];
        }
    }

    static fromJS(data: any): AuditFacilitieDatacenterDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditFacilitieDatacenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["auditId"] = this.auditId;
        data["facilitieDatacenterId"] = this.facilitieDatacenterId;
        return data; 
    }
}

export interface IAuditFacilitieDatacenterDto {
    id: number;
    auditId: number | undefined;
    facilitieDatacenterId: number | undefined;
}

export class AuditTeamDto implements IAuditTeamDto {
    id!: number;
    auditId!: number | undefined;
    employeeId!: number | undefined;

    constructor(data?: IAuditTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.auditId = _data["auditId"];
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): AuditTeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditTeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["auditId"] = this.auditId;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface IAuditTeamDto {
    id: number;
    auditId: number | undefined;
    employeeId: number | undefined;
}

export class AuditVendorDto implements IAuditVendorDto {
    id!: number;
    auditId!: number | undefined;
    vendorId!: number | undefined;

    constructor(data?: IAuditVendorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.auditId = _data["auditId"];
            this.vendorId = _data["vendorId"];
        }
    }

    static fromJS(data: any): AuditVendorDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditVendorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["auditId"] = this.auditId;
        data["vendorId"] = this.vendorId;
        return data; 
    }
}

export interface IAuditVendorDto {
    id: number;
    auditId: number | undefined;
    vendorId: number | undefined;
}

export class AuditAttachmentDto implements IAuditAttachmentDto {
    id!: number;
    auditId!: number | undefined;
    documents!: string | undefined;

    constructor(data?: IAuditAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.auditId = _data["auditId"];
            this.documents = _data["documents"];
        }
    }

    static fromJS(data: any): AuditAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["auditId"] = this.auditId;
        data["documents"] = this.documents;
        return data; 
    }
}

export interface IAuditAttachmentDto {
    id: number;
    auditId: number | undefined;
    documents: string | undefined;
}

export class AuditFindingDto implements IAuditFindingDto {
    id!: number;
    auditId!: number | undefined;
    findingId!: number | undefined;

    constructor(data?: IAuditFindingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.auditId = _data["auditId"];
            this.findingId = _data["findingId"];
        }
    }

    static fromJS(data: any): AuditFindingDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditFindingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["auditId"] = this.auditId;
        data["findingId"] = this.findingId;
        return data; 
    }
}

export interface IAuditFindingDto {
    id: number;
    auditId: number | undefined;
    findingId: number | undefined;
}

export class AuditSystemApplicationDto implements IAuditSystemApplicationDto {
    id!: number;
    auditId!: number | undefined;
    systemApplicationId!: number | undefined;

    constructor(data?: IAuditSystemApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.auditId = _data["auditId"];
            this.systemApplicationId = _data["systemApplicationId"];
        }
    }

    static fromJS(data: any): AuditSystemApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditSystemApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["auditId"] = this.auditId;
        data["systemApplicationId"] = this.systemApplicationId;
        return data; 
    }
}

export interface IAuditSystemApplicationDto {
    id: number;
    auditId: number | undefined;
    systemApplicationId: number | undefined;
}

export class AuditDto implements IAuditDto {
    tenantId!: number | undefined;
    auditId!: string | undefined;
    auditTitle!: string | undefined;
    auditTypes!: AuditType;
    auditTypeseother!: string | undefined;
    finacialYearId!: number | undefined;
    finacialYearList!: GetDynamicValueDto[] | undefined;
    finacialYearOther!: string | undefined;
    startDate!: DateTime | undefined;
    endDate!: DateTime | undefined;
    auditDuration!: number | undefined;
    statusId!: number | undefined;
    statusList!: GetDynamicValueDto[] | undefined;
    auditLocationAddressOne!: string | undefined;
    auditLocationAddressTwo!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number | undefined;
    countries!: CountryDto[] | undefined;
    auditAreaId!: number | undefined;
    auditAreaList!: GetDynamicValueDto[] | undefined;
    auditReference!: string | undefined;
    leadAuditorId!: number | undefined;
    leadAuditorList!: BusinessServiceOwner[] | undefined;
    auditContactId!: number | undefined;
    auditContactList!: BusinessServiceOwner[] | undefined;
    vendorId!: number | undefined;
    vendorList!: VendorListDto[] | undefined;
    budgetedHours!: number | undefined;
    projectNameId!: number | undefined;
    projectList!: ProjectListDetailsDto[] | undefined;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganizationList!: GetOrganizationDto[] | undefined;
    relatedBsinessId!: number | undefined;
    relatedBsinessList!: BusinessUnitPrimaryDto[] | undefined;
    auditScope!: string | undefined;
    auditBackground!: string | undefined;
    auditObjectives!: string | undefined;
    auditMemo!: string | undefined;
    documentChecklist!: string | undefined;
    businessServices!: BusinessServiceSDto[] | undefined;
    businessProcess!: BusinessProcessDetailDto[] | undefined;
    facilitiesDatacenterList!: FacilitieDatacenterListDto[] | undefined;
    findingList!: FindingDetailsDto[] | undefined;
    systemAplicationList!: SytemApplicationDto[] | undefined;
    selectedAuditAuditors!: AuditAuditorDto[] | undefined;
    selectedAuditBusinessProcess!: AuditBusinessProcessDto[] | undefined;
    selectedAuditBusinessServices!: AuditBusinessServiceDto[] | undefined;
    selectedAuditFacilitieDatacenters!: AuditFacilitieDatacenterDto[] | undefined;
    selectedAuditTeams!: AuditTeamDto[] | undefined;
    selectedAuditVendors!: AuditVendorDto[] | undefined;
    selectedAuditAttachments!: AuditAttachmentDto[] | undefined;
    selectedAuditFindings!: AuditFindingDto[] | undefined;
    selectedAuditSystemApplications!: AuditSystemApplicationDto[] | undefined;
    removedAuditSystemApplications!: number[] | undefined;
    removedAuditAuditors!: number[] | undefined;
    removedAuditBusinessProcess!: number[] | undefined;
    removedAuditBusinessServices!: number[] | undefined;
    removedAuditFacilitieDatacenters!: number[] | undefined;
    removedAuditTeams!: number[] | undefined;
    removedAuditVendors!: number[] | undefined;
    removedAuditAttachments!: number[] | undefined;
    removedAuditFindings!: number[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAuditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.auditId = _data["auditId"];
            this.auditTitle = _data["auditTitle"];
            this.auditTypes = _data["auditTypes"];
            this.auditTypeseother = _data["auditTypeseother"];
            this.finacialYearId = _data["finacialYearId"];
            if (Array.isArray(_data["finacialYearList"])) {
                this.finacialYearList = [] as any;
                for (let item of _data["finacialYearList"])
                    this.finacialYearList!.push(GetDynamicValueDto.fromJS(item));
            }
            this.finacialYearOther = _data["finacialYearOther"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
            this.auditDuration = _data["auditDuration"];
            this.statusId = _data["statusId"];
            if (Array.isArray(_data["statusList"])) {
                this.statusList = [] as any;
                for (let item of _data["statusList"])
                    this.statusList!.push(GetDynamicValueDto.fromJS(item));
            }
            this.auditLocationAddressOne = _data["auditLocationAddressOne"];
            this.auditLocationAddressTwo = _data["auditLocationAddressTwo"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(CountryDto.fromJS(item));
            }
            this.auditAreaId = _data["auditAreaId"];
            if (Array.isArray(_data["auditAreaList"])) {
                this.auditAreaList = [] as any;
                for (let item of _data["auditAreaList"])
                    this.auditAreaList!.push(GetDynamicValueDto.fromJS(item));
            }
            this.auditReference = _data["auditReference"];
            this.leadAuditorId = _data["leadAuditorId"];
            if (Array.isArray(_data["leadAuditorList"])) {
                this.leadAuditorList = [] as any;
                for (let item of _data["leadAuditorList"])
                    this.leadAuditorList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.auditContactId = _data["auditContactId"];
            if (Array.isArray(_data["auditContactList"])) {
                this.auditContactList = [] as any;
                for (let item of _data["auditContactList"])
                    this.auditContactList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.vendorId = _data["vendorId"];
            if (Array.isArray(_data["vendorList"])) {
                this.vendorList = [] as any;
                for (let item of _data["vendorList"])
                    this.vendorList!.push(VendorListDto.fromJS(item));
            }
            this.budgetedHours = _data["budgetedHours"];
            this.projectNameId = _data["projectNameId"];
            if (Array.isArray(_data["projectList"])) {
                this.projectList = [] as any;
                for (let item of _data["projectList"])
                    this.projectList!.push(ProjectListDetailsDto.fromJS(item));
            }
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["lockThreatOrganizationList"])) {
                this.lockThreatOrganizationList = [] as any;
                for (let item of _data["lockThreatOrganizationList"])
                    this.lockThreatOrganizationList!.push(GetOrganizationDto.fromJS(item));
            }
            this.relatedBsinessId = _data["relatedBsinessId"];
            if (Array.isArray(_data["relatedBsinessList"])) {
                this.relatedBsinessList = [] as any;
                for (let item of _data["relatedBsinessList"])
                    this.relatedBsinessList!.push(BusinessUnitPrimaryDto.fromJS(item));
            }
            this.auditScope = _data["auditScope"];
            this.auditBackground = _data["auditBackground"];
            this.auditObjectives = _data["auditObjectives"];
            this.auditMemo = _data["auditMemo"];
            this.documentChecklist = _data["documentChecklist"];
            if (Array.isArray(_data["businessServices"])) {
                this.businessServices = [] as any;
                for (let item of _data["businessServices"])
                    this.businessServices!.push(BusinessServiceSDto.fromJS(item));
            }
            if (Array.isArray(_data["businessProcess"])) {
                this.businessProcess = [] as any;
                for (let item of _data["businessProcess"])
                    this.businessProcess!.push(BusinessProcessDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["facilitiesDatacenterList"])) {
                this.facilitiesDatacenterList = [] as any;
                for (let item of _data["facilitiesDatacenterList"])
                    this.facilitiesDatacenterList!.push(FacilitieDatacenterListDto.fromJS(item));
            }
            if (Array.isArray(_data["findingList"])) {
                this.findingList = [] as any;
                for (let item of _data["findingList"])
                    this.findingList!.push(FindingDetailsDto.fromJS(item));
            }
            if (Array.isArray(_data["systemAplicationList"])) {
                this.systemAplicationList = [] as any;
                for (let item of _data["systemAplicationList"])
                    this.systemAplicationList!.push(SytemApplicationDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAuditAuditors"])) {
                this.selectedAuditAuditors = [] as any;
                for (let item of _data["selectedAuditAuditors"])
                    this.selectedAuditAuditors!.push(AuditAuditorDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAuditBusinessProcess"])) {
                this.selectedAuditBusinessProcess = [] as any;
                for (let item of _data["selectedAuditBusinessProcess"])
                    this.selectedAuditBusinessProcess!.push(AuditBusinessProcessDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAuditBusinessServices"])) {
                this.selectedAuditBusinessServices = [] as any;
                for (let item of _data["selectedAuditBusinessServices"])
                    this.selectedAuditBusinessServices!.push(AuditBusinessServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAuditFacilitieDatacenters"])) {
                this.selectedAuditFacilitieDatacenters = [] as any;
                for (let item of _data["selectedAuditFacilitieDatacenters"])
                    this.selectedAuditFacilitieDatacenters!.push(AuditFacilitieDatacenterDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAuditTeams"])) {
                this.selectedAuditTeams = [] as any;
                for (let item of _data["selectedAuditTeams"])
                    this.selectedAuditTeams!.push(AuditTeamDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAuditVendors"])) {
                this.selectedAuditVendors = [] as any;
                for (let item of _data["selectedAuditVendors"])
                    this.selectedAuditVendors!.push(AuditVendorDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAuditAttachments"])) {
                this.selectedAuditAttachments = [] as any;
                for (let item of _data["selectedAuditAttachments"])
                    this.selectedAuditAttachments!.push(AuditAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAuditFindings"])) {
                this.selectedAuditFindings = [] as any;
                for (let item of _data["selectedAuditFindings"])
                    this.selectedAuditFindings!.push(AuditFindingDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAuditSystemApplications"])) {
                this.selectedAuditSystemApplications = [] as any;
                for (let item of _data["selectedAuditSystemApplications"])
                    this.selectedAuditSystemApplications!.push(AuditSystemApplicationDto.fromJS(item));
            }
            if (Array.isArray(_data["removedAuditSystemApplications"])) {
                this.removedAuditSystemApplications = [] as any;
                for (let item of _data["removedAuditSystemApplications"])
                    this.removedAuditSystemApplications!.push(item);
            }
            if (Array.isArray(_data["removedAuditAuditors"])) {
                this.removedAuditAuditors = [] as any;
                for (let item of _data["removedAuditAuditors"])
                    this.removedAuditAuditors!.push(item);
            }
            if (Array.isArray(_data["removedAuditBusinessProcess"])) {
                this.removedAuditBusinessProcess = [] as any;
                for (let item of _data["removedAuditBusinessProcess"])
                    this.removedAuditBusinessProcess!.push(item);
            }
            if (Array.isArray(_data["removedAuditBusinessServices"])) {
                this.removedAuditBusinessServices = [] as any;
                for (let item of _data["removedAuditBusinessServices"])
                    this.removedAuditBusinessServices!.push(item);
            }
            if (Array.isArray(_data["removedAuditFacilitieDatacenters"])) {
                this.removedAuditFacilitieDatacenters = [] as any;
                for (let item of _data["removedAuditFacilitieDatacenters"])
                    this.removedAuditFacilitieDatacenters!.push(item);
            }
            if (Array.isArray(_data["removedAuditTeams"])) {
                this.removedAuditTeams = [] as any;
                for (let item of _data["removedAuditTeams"])
                    this.removedAuditTeams!.push(item);
            }
            if (Array.isArray(_data["removedAuditVendors"])) {
                this.removedAuditVendors = [] as any;
                for (let item of _data["removedAuditVendors"])
                    this.removedAuditVendors!.push(item);
            }
            if (Array.isArray(_data["removedAuditAttachments"])) {
                this.removedAuditAttachments = [] as any;
                for (let item of _data["removedAuditAttachments"])
                    this.removedAuditAttachments!.push(item);
            }
            if (Array.isArray(_data["removedAuditFindings"])) {
                this.removedAuditFindings = [] as any;
                for (let item of _data["removedAuditFindings"])
                    this.removedAuditFindings!.push(item);
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuditDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["auditId"] = this.auditId;
        data["auditTitle"] = this.auditTitle;
        data["auditTypes"] = this.auditTypes;
        data["auditTypeseother"] = this.auditTypeseother;
        data["finacialYearId"] = this.finacialYearId;
        if (Array.isArray(this.finacialYearList)) {
            data["finacialYearList"] = [];
            for (let item of this.finacialYearList)
                data["finacialYearList"].push(item.toJSON());
        }
        data["finacialYearOther"] = this.finacialYearOther;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        data["auditDuration"] = this.auditDuration;
        data["statusId"] = this.statusId;
        if (Array.isArray(this.statusList)) {
            data["statusList"] = [];
            for (let item of this.statusList)
                data["statusList"].push(item.toJSON());
        }
        data["auditLocationAddressOne"] = this.auditLocationAddressOne;
        data["auditLocationAddressTwo"] = this.auditLocationAddressTwo;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        data["auditAreaId"] = this.auditAreaId;
        if (Array.isArray(this.auditAreaList)) {
            data["auditAreaList"] = [];
            for (let item of this.auditAreaList)
                data["auditAreaList"].push(item.toJSON());
        }
        data["auditReference"] = this.auditReference;
        data["leadAuditorId"] = this.leadAuditorId;
        if (Array.isArray(this.leadAuditorList)) {
            data["leadAuditorList"] = [];
            for (let item of this.leadAuditorList)
                data["leadAuditorList"].push(item.toJSON());
        }
        data["auditContactId"] = this.auditContactId;
        if (Array.isArray(this.auditContactList)) {
            data["auditContactList"] = [];
            for (let item of this.auditContactList)
                data["auditContactList"].push(item.toJSON());
        }
        data["vendorId"] = this.vendorId;
        if (Array.isArray(this.vendorList)) {
            data["vendorList"] = [];
            for (let item of this.vendorList)
                data["vendorList"].push(item.toJSON());
        }
        data["budgetedHours"] = this.budgetedHours;
        data["projectNameId"] = this.projectNameId;
        if (Array.isArray(this.projectList)) {
            data["projectList"] = [];
            for (let item of this.projectList)
                data["projectList"].push(item.toJSON());
        }
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.lockThreatOrganizationList)) {
            data["lockThreatOrganizationList"] = [];
            for (let item of this.lockThreatOrganizationList)
                data["lockThreatOrganizationList"].push(item.toJSON());
        }
        data["relatedBsinessId"] = this.relatedBsinessId;
        if (Array.isArray(this.relatedBsinessList)) {
            data["relatedBsinessList"] = [];
            for (let item of this.relatedBsinessList)
                data["relatedBsinessList"].push(item.toJSON());
        }
        data["auditScope"] = this.auditScope;
        data["auditBackground"] = this.auditBackground;
        data["auditObjectives"] = this.auditObjectives;
        data["auditMemo"] = this.auditMemo;
        data["documentChecklist"] = this.documentChecklist;
        if (Array.isArray(this.businessServices)) {
            data["businessServices"] = [];
            for (let item of this.businessServices)
                data["businessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.businessProcess)) {
            data["businessProcess"] = [];
            for (let item of this.businessProcess)
                data["businessProcess"].push(item.toJSON());
        }
        if (Array.isArray(this.facilitiesDatacenterList)) {
            data["facilitiesDatacenterList"] = [];
            for (let item of this.facilitiesDatacenterList)
                data["facilitiesDatacenterList"].push(item.toJSON());
        }
        if (Array.isArray(this.findingList)) {
            data["findingList"] = [];
            for (let item of this.findingList)
                data["findingList"].push(item.toJSON());
        }
        if (Array.isArray(this.systemAplicationList)) {
            data["systemAplicationList"] = [];
            for (let item of this.systemAplicationList)
                data["systemAplicationList"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAuditAuditors)) {
            data["selectedAuditAuditors"] = [];
            for (let item of this.selectedAuditAuditors)
                data["selectedAuditAuditors"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAuditBusinessProcess)) {
            data["selectedAuditBusinessProcess"] = [];
            for (let item of this.selectedAuditBusinessProcess)
                data["selectedAuditBusinessProcess"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAuditBusinessServices)) {
            data["selectedAuditBusinessServices"] = [];
            for (let item of this.selectedAuditBusinessServices)
                data["selectedAuditBusinessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAuditFacilitieDatacenters)) {
            data["selectedAuditFacilitieDatacenters"] = [];
            for (let item of this.selectedAuditFacilitieDatacenters)
                data["selectedAuditFacilitieDatacenters"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAuditTeams)) {
            data["selectedAuditTeams"] = [];
            for (let item of this.selectedAuditTeams)
                data["selectedAuditTeams"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAuditVendors)) {
            data["selectedAuditVendors"] = [];
            for (let item of this.selectedAuditVendors)
                data["selectedAuditVendors"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAuditAttachments)) {
            data["selectedAuditAttachments"] = [];
            for (let item of this.selectedAuditAttachments)
                data["selectedAuditAttachments"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAuditFindings)) {
            data["selectedAuditFindings"] = [];
            for (let item of this.selectedAuditFindings)
                data["selectedAuditFindings"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAuditSystemApplications)) {
            data["selectedAuditSystemApplications"] = [];
            for (let item of this.selectedAuditSystemApplications)
                data["selectedAuditSystemApplications"].push(item.toJSON());
        }
        if (Array.isArray(this.removedAuditSystemApplications)) {
            data["removedAuditSystemApplications"] = [];
            for (let item of this.removedAuditSystemApplications)
                data["removedAuditSystemApplications"].push(item);
        }
        if (Array.isArray(this.removedAuditAuditors)) {
            data["removedAuditAuditors"] = [];
            for (let item of this.removedAuditAuditors)
                data["removedAuditAuditors"].push(item);
        }
        if (Array.isArray(this.removedAuditBusinessProcess)) {
            data["removedAuditBusinessProcess"] = [];
            for (let item of this.removedAuditBusinessProcess)
                data["removedAuditBusinessProcess"].push(item);
        }
        if (Array.isArray(this.removedAuditBusinessServices)) {
            data["removedAuditBusinessServices"] = [];
            for (let item of this.removedAuditBusinessServices)
                data["removedAuditBusinessServices"].push(item);
        }
        if (Array.isArray(this.removedAuditFacilitieDatacenters)) {
            data["removedAuditFacilitieDatacenters"] = [];
            for (let item of this.removedAuditFacilitieDatacenters)
                data["removedAuditFacilitieDatacenters"].push(item);
        }
        if (Array.isArray(this.removedAuditTeams)) {
            data["removedAuditTeams"] = [];
            for (let item of this.removedAuditTeams)
                data["removedAuditTeams"].push(item);
        }
        if (Array.isArray(this.removedAuditVendors)) {
            data["removedAuditVendors"] = [];
            for (let item of this.removedAuditVendors)
                data["removedAuditVendors"].push(item);
        }
        if (Array.isArray(this.removedAuditAttachments)) {
            data["removedAuditAttachments"] = [];
            for (let item of this.removedAuditAttachments)
                data["removedAuditAttachments"].push(item);
        }
        if (Array.isArray(this.removedAuditFindings)) {
            data["removedAuditFindings"] = [];
            for (let item of this.removedAuditFindings)
                data["removedAuditFindings"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditDto {
    tenantId: number | undefined;
    auditId: string | undefined;
    auditTitle: string | undefined;
    auditTypes: AuditType;
    auditTypeseother: string | undefined;
    finacialYearId: number | undefined;
    finacialYearList: GetDynamicValueDto[] | undefined;
    finacialYearOther: string | undefined;
    startDate: DateTime | undefined;
    endDate: DateTime | undefined;
    auditDuration: number | undefined;
    statusId: number | undefined;
    statusList: GetDynamicValueDto[] | undefined;
    auditLocationAddressOne: string | undefined;
    auditLocationAddressTwo: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    countryId: number | undefined;
    countries: CountryDto[] | undefined;
    auditAreaId: number | undefined;
    auditAreaList: GetDynamicValueDto[] | undefined;
    auditReference: string | undefined;
    leadAuditorId: number | undefined;
    leadAuditorList: BusinessServiceOwner[] | undefined;
    auditContactId: number | undefined;
    auditContactList: BusinessServiceOwner[] | undefined;
    vendorId: number | undefined;
    vendorList: VendorListDto[] | undefined;
    budgetedHours: number | undefined;
    projectNameId: number | undefined;
    projectList: ProjectListDetailsDto[] | undefined;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganizationList: GetOrganizationDto[] | undefined;
    relatedBsinessId: number | undefined;
    relatedBsinessList: BusinessUnitPrimaryDto[] | undefined;
    auditScope: string | undefined;
    auditBackground: string | undefined;
    auditObjectives: string | undefined;
    auditMemo: string | undefined;
    documentChecklist: string | undefined;
    businessServices: BusinessServiceSDto[] | undefined;
    businessProcess: BusinessProcessDetailDto[] | undefined;
    facilitiesDatacenterList: FacilitieDatacenterListDto[] | undefined;
    findingList: FindingDetailsDto[] | undefined;
    systemAplicationList: SytemApplicationDto[] | undefined;
    selectedAuditAuditors: AuditAuditorDto[] | undefined;
    selectedAuditBusinessProcess: AuditBusinessProcessDto[] | undefined;
    selectedAuditBusinessServices: AuditBusinessServiceDto[] | undefined;
    selectedAuditFacilitieDatacenters: AuditFacilitieDatacenterDto[] | undefined;
    selectedAuditTeams: AuditTeamDto[] | undefined;
    selectedAuditVendors: AuditVendorDto[] | undefined;
    selectedAuditAttachments: AuditAttachmentDto[] | undefined;
    selectedAuditFindings: AuditFindingDto[] | undefined;
    selectedAuditSystemApplications: AuditSystemApplicationDto[] | undefined;
    removedAuditSystemApplications: number[] | undefined;
    removedAuditAuditors: number[] | undefined;
    removedAuditBusinessProcess: number[] | undefined;
    removedAuditBusinessServices: number[] | undefined;
    removedAuditFacilitieDatacenters: number[] | undefined;
    removedAuditTeams: number[] | undefined;
    removedAuditVendors: number[] | undefined;
    removedAuditAttachments: number[] | undefined;
    removedAuditFindings: number[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class GetAuditListDto implements IGetAuditListDto {
    tenantId!: number | undefined;
    auditId!: string | undefined;
    auditTitle!: string | undefined;
    auditTypes!: AuditType;
    auditTypeseother!: string | undefined;
    finacialYearId!: number | undefined;
    finacialYear!: DynamicPropertyValue;
    finacialYearOther!: string | undefined;
    startDate!: DateTime | undefined;
    endDate!: DateTime | undefined;
    auditDuration!: number | undefined;
    statusId!: number | undefined;
    status!: DynamicPropertyValue;
    auditLocationAddressOne!: string | undefined;
    auditLocationAddressTwo!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number | undefined;
    country!: DynamicPropertyValue;
    auditAreaId!: number | undefined;
    auditArea!: DynamicPropertyValue;
    auditReference!: string | undefined;
    leadAuditorId!: number | undefined;
    leadAuditor!: BusinessServiceOwner;
    auditContactId!: number | undefined;
    auditContact!: BusinessServiceOwner;
    vendorId!: number | undefined;
    vendor!: VendorListDto;
    budgetedHours!: number | undefined;
    projectNameId!: number | undefined;
    projectName!: ProjectListDetailsDto;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationDto;
    relatedBsinessId!: number | undefined;
    relatedBsiness!: BusinessUnitPrimaryDto;
    auditScope!: string | undefined;
    auditBackground!: string | undefined;
    auditObjectives!: string | undefined;
    auditMemo!: string | undefined;
    documentChecklist!: string | undefined;
    id!: number;

    constructor(data?: IGetAuditListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.auditId = _data["auditId"];
            this.auditTitle = _data["auditTitle"];
            this.auditTypes = _data["auditTypes"];
            this.auditTypeseother = _data["auditTypeseother"];
            this.finacialYearId = _data["finacialYearId"];
            this.finacialYear = _data["finacialYear"] ? DynamicPropertyValue.fromJS(_data["finacialYear"]) : <any>undefined;
            this.finacialYearOther = _data["finacialYearOther"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
            this.auditDuration = _data["auditDuration"];
            this.statusId = _data["statusId"];
            this.status = _data["status"] ? DynamicPropertyValue.fromJS(_data["status"]) : <any>undefined;
            this.auditLocationAddressOne = _data["auditLocationAddressOne"];
            this.auditLocationAddressTwo = _data["auditLocationAddressTwo"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? DynamicPropertyValue.fromJS(_data["country"]) : <any>undefined;
            this.auditAreaId = _data["auditAreaId"];
            this.auditArea = _data["auditArea"] ? DynamicPropertyValue.fromJS(_data["auditArea"]) : <any>undefined;
            this.auditReference = _data["auditReference"];
            this.leadAuditorId = _data["leadAuditorId"];
            this.leadAuditor = _data["leadAuditor"] ? BusinessServiceOwner.fromJS(_data["leadAuditor"]) : <any>undefined;
            this.auditContactId = _data["auditContactId"];
            this.auditContact = _data["auditContact"] ? BusinessServiceOwner.fromJS(_data["auditContact"]) : <any>undefined;
            this.vendorId = _data["vendorId"];
            this.vendor = _data["vendor"] ? VendorListDto.fromJS(_data["vendor"]) : <any>undefined;
            this.budgetedHours = _data["budgetedHours"];
            this.projectNameId = _data["projectNameId"];
            this.projectName = _data["projectName"] ? ProjectListDetailsDto.fromJS(_data["projectName"]) : <any>undefined;
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.relatedBsinessId = _data["relatedBsinessId"];
            this.relatedBsiness = _data["relatedBsiness"] ? BusinessUnitPrimaryDto.fromJS(_data["relatedBsiness"]) : <any>undefined;
            this.auditScope = _data["auditScope"];
            this.auditBackground = _data["auditBackground"];
            this.auditObjectives = _data["auditObjectives"];
            this.auditMemo = _data["auditMemo"];
            this.documentChecklist = _data["documentChecklist"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAuditListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAuditListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["auditId"] = this.auditId;
        data["auditTitle"] = this.auditTitle;
        data["auditTypes"] = this.auditTypes;
        data["auditTypeseother"] = this.auditTypeseother;
        data["finacialYearId"] = this.finacialYearId;
        data["finacialYear"] = this.finacialYear ? this.finacialYear.toJSON() : <any>undefined;
        data["finacialYearOther"] = this.finacialYearOther;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        data["auditDuration"] = this.auditDuration;
        data["statusId"] = this.statusId;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["auditLocationAddressOne"] = this.auditLocationAddressOne;
        data["auditLocationAddressTwo"] = this.auditLocationAddressTwo;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["auditAreaId"] = this.auditAreaId;
        data["auditArea"] = this.auditArea ? this.auditArea.toJSON() : <any>undefined;
        data["auditReference"] = this.auditReference;
        data["leadAuditorId"] = this.leadAuditorId;
        data["leadAuditor"] = this.leadAuditor ? this.leadAuditor.toJSON() : <any>undefined;
        data["auditContactId"] = this.auditContactId;
        data["auditContact"] = this.auditContact ? this.auditContact.toJSON() : <any>undefined;
        data["vendorId"] = this.vendorId;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["budgetedHours"] = this.budgetedHours;
        data["projectNameId"] = this.projectNameId;
        data["projectName"] = this.projectName ? this.projectName.toJSON() : <any>undefined;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["relatedBsinessId"] = this.relatedBsinessId;
        data["relatedBsiness"] = this.relatedBsiness ? this.relatedBsiness.toJSON() : <any>undefined;
        data["auditScope"] = this.auditScope;
        data["auditBackground"] = this.auditBackground;
        data["auditObjectives"] = this.auditObjectives;
        data["auditMemo"] = this.auditMemo;
        data["documentChecklist"] = this.documentChecklist;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetAuditListDto {
    tenantId: number | undefined;
    auditId: string | undefined;
    auditTitle: string | undefined;
    auditTypes: AuditType;
    auditTypeseother: string | undefined;
    finacialYearId: number | undefined;
    finacialYear: DynamicPropertyValue;
    finacialYearOther: string | undefined;
    startDate: DateTime | undefined;
    endDate: DateTime | undefined;
    auditDuration: number | undefined;
    statusId: number | undefined;
    status: DynamicPropertyValue;
    auditLocationAddressOne: string | undefined;
    auditLocationAddressTwo: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    countryId: number | undefined;
    country: DynamicPropertyValue;
    auditAreaId: number | undefined;
    auditArea: DynamicPropertyValue;
    auditReference: string | undefined;
    leadAuditorId: number | undefined;
    leadAuditor: BusinessServiceOwner;
    auditContactId: number | undefined;
    auditContact: BusinessServiceOwner;
    vendorId: number | undefined;
    vendor: VendorListDto;
    budgetedHours: number | undefined;
    projectNameId: number | undefined;
    projectName: ProjectListDetailsDto;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationDto;
    relatedBsinessId: number | undefined;
    relatedBsiness: BusinessUnitPrimaryDto;
    auditScope: string | undefined;
    auditBackground: string | undefined;
    auditObjectives: string | undefined;
    auditMemo: string | undefined;
    documentChecklist: string | undefined;
    id: number;
}

export class PagedResultDtoOfGetAuditListDto implements IPagedResultDtoOfGetAuditListDto {
    totalCount!: number;
    items!: GetAuditListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAuditListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAuditListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAuditListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAuditListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAuditListDto {
    totalCount: number;
    items: GetAuditListDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: DateTime;
    executionDuration!: number;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? DateTime.fromISO(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exception = _data["exception"];
            this.customData = _data["customData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: DateTime;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export enum EntityChangeType {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: DateTime;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType;
    readonly changeTypeName!: string | undefined;
    entityChangeSetId!: number;
    id!: number;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.changeTime = _data["changeTime"] ? DateTime.fromISO(_data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = _data["entityTypeFullName"];
            this.changeType = _data["changeType"];
            (<any>this).changeTypeName = _data["changeTypeName"];
            this.entityChangeSetId = _data["entityChangeSetId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: DateTime;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    changeTypeName: string | undefined;
    entityChangeSetId: number;
    id: number;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityChangeId = _data["entityChangeId"];
            this.newValue = _data["newValue"];
            this.originalValue = _data["originalValue"];
            this.propertyName = _data["propertyName"];
            this.propertyTypeFullName = _data["propertyTypeFullName"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class AuthoratativeDocumentsDto implements IAuthoratativeDocumentsDto {
    tenantId!: number | undefined;
    authorityDocumentId!: string | undefined;
    authorityDocumentOrigin!: string | undefined;
    authoratativeDocumentTitle!: string | undefined;
    mandateTypeId!: number | undefined;
    typeId!: number | undefined;
    keywords!: string | undefined;
    authoratativeDocumentName!: string | undefined;
    documentURL!: string | undefined;
    logo!: string | undefined;
    effectiveDate!: DateTime | undefined;
    notes!: string | undefined;
    importantNotice!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAuthoratativeDocumentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.authorityDocumentId = _data["authorityDocumentId"];
            this.authorityDocumentOrigin = _data["authorityDocumentOrigin"];
            this.authoratativeDocumentTitle = _data["authoratativeDocumentTitle"];
            this.mandateTypeId = _data["mandateTypeId"];
            this.typeId = _data["typeId"];
            this.keywords = _data["keywords"];
            this.authoratativeDocumentName = _data["authoratativeDocumentName"];
            this.documentURL = _data["documentURL"];
            this.logo = _data["logo"];
            this.effectiveDate = _data["effectiveDate"] ? DateTime.fromISO(_data["effectiveDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.importantNotice = _data["importantNotice"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuthoratativeDocumentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthoratativeDocumentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["authorityDocumentId"] = this.authorityDocumentId;
        data["authorityDocumentOrigin"] = this.authorityDocumentOrigin;
        data["authoratativeDocumentTitle"] = this.authoratativeDocumentTitle;
        data["mandateTypeId"] = this.mandateTypeId;
        data["typeId"] = this.typeId;
        data["keywords"] = this.keywords;
        data["authoratativeDocumentName"] = this.authoratativeDocumentName;
        data["documentURL"] = this.documentURL;
        data["logo"] = this.logo;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toString() : <any>undefined;
        data["notes"] = this.notes;
        data["importantNotice"] = this.importantNotice;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuthoratativeDocumentsDto {
    tenantId: number | undefined;
    authorityDocumentId: string | undefined;
    authorityDocumentOrigin: string | undefined;
    authoratativeDocumentTitle: string | undefined;
    mandateTypeId: number | undefined;
    typeId: number | undefined;
    keywords: string | undefined;
    authoratativeDocumentName: string | undefined;
    documentURL: string | undefined;
    logo: string | undefined;
    effectiveDate: DateTime | undefined;
    notes: string | undefined;
    importantNotice: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class BusinessProcessAuthorativeDocumentDto implements IBusinessProcessAuthorativeDocumentDto {
    businessProcessId!: number | undefined;
    authoratativeDocumentId!: number | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBusinessProcessAuthorativeDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
            this.authoratativeDocumentId = _data["authoratativeDocumentId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessProcessAuthorativeDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessAuthorativeDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        data["authoratativeDocumentId"] = this.authoratativeDocumentId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusinessProcessAuthorativeDocumentDto {
    businessProcessId: number | undefined;
    authoratativeDocumentId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class BusinessProcessUnitDto implements IBusinessProcessUnitDto {
    businessProcessId!: number | undefined;
    businessUnitId!: number | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBusinessProcessUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
            this.businessUnitId = _data["businessUnitId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessProcessUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        data["businessUnitId"] = this.businessUnitId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusinessProcessUnitDto {
    businessProcessId: number | undefined;
    businessUnitId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class BusinessProcessServiceDto implements IBusinessProcessServiceDto {
    businessProcessId!: number | undefined;
    businessServiceId!: number | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBusinessProcessServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
            this.businessServiceId = _data["businessServiceId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessProcessServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        data["businessServiceId"] = this.businessServiceId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusinessProcessServiceDto {
    businessProcessId: number | undefined;
    businessServiceId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class BusinessProcessDto implements IBusinessProcessDto {
    tenantId!: number | undefined;
    businessProcessId!: string | undefined;
    businessProcessName!: string | undefined;
    statusId!: number | undefined;
    statuses!: GetDynamicValueDto[] | undefined;
    description!: string | undefined;
    processTypeId!: number | undefined;
    processTypes!: GetDynamicValueDto[] | undefined;
    slaApplicableId!: number | undefined;
    slaApplicables!: GetDynamicValueDto[] | undefined;
    activityCycleId!: number | undefined;
    activityCycles!: GetDynamicValueDto[] | undefined;
    authoratativeDocuments!: AuthoratativeDocumentsDto[] | undefined;
    address!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number | undefined;
    countries!: CountryDto[] | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    processManagerId!: number | undefined;
    processManagers!: BusinessServiceOwner[] | undefined;
    processOwnerId!: number | undefined;
    processOwners!: BusinessServiceOwner[] | undefined;
    businessUnitId!: number | undefined;
    businessUnits!: BusinessUnitPrimaryDto[] | undefined;
    regulatoryId!: number | undefined;
    regulatorys!: GetDynamicValueDto[] | undefined;
    processPriorityId!: number | undefined;
    processPrioritys!: GetDynamicValueDto[] | undefined;
    othersId!: number | undefined;
    otheres!: GetDynamicValueDto[] | undefined;
    confidentialityId!: number | undefined;
    confidentialitys!: GetDynamicValueDto[] | undefined;
    reviewPeriodId!: number | undefined;
    reviewPeriods!: GetDynamicValueDto[] | undefined;
    intergrityId!: number | undefined;
    intergritys!: GetDynamicValueDto[] | undefined;
    availibilityId!: number | undefined;
    availibilityes!: GetDynamicValueDto[] | undefined;
    documents!: string | undefined;
    businessServices!: BusinessServiceSDto[] | undefined;
    selectedBusinessProcessAuthorativeDocuments!: BusinessProcessAuthorativeDocumentDto[] | undefined;
    removedBusinessProcessAuthorativeDocuments!: number[] | undefined;
    selectedBusinessProcessUnits!: BusinessProcessUnitDto[] | undefined;
    removedBusinessProcessUnits!: number[] | undefined;
    selectedBusinessProcessServices!: BusinessProcessServiceDto[] | undefined;
    removedBusinessProcessServices!: number[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBusinessProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.businessProcessId = _data["businessProcessId"];
            this.businessProcessName = _data["businessProcessName"];
            this.statusId = _data["statusId"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(GetDynamicValueDto.fromJS(item));
            }
            this.description = _data["description"];
            this.processTypeId = _data["processTypeId"];
            if (Array.isArray(_data["processTypes"])) {
                this.processTypes = [] as any;
                for (let item of _data["processTypes"])
                    this.processTypes!.push(GetDynamicValueDto.fromJS(item));
            }
            this.slaApplicableId = _data["slaApplicableId"];
            if (Array.isArray(_data["slaApplicables"])) {
                this.slaApplicables = [] as any;
                for (let item of _data["slaApplicables"])
                    this.slaApplicables!.push(GetDynamicValueDto.fromJS(item));
            }
            this.activityCycleId = _data["activityCycleId"];
            if (Array.isArray(_data["activityCycles"])) {
                this.activityCycles = [] as any;
                for (let item of _data["activityCycles"])
                    this.activityCycles!.push(GetDynamicValueDto.fromJS(item));
            }
            if (Array.isArray(_data["authoratativeDocuments"])) {
                this.authoratativeDocuments = [] as any;
                for (let item of _data["authoratativeDocuments"])
                    this.authoratativeDocuments!.push(AuthoratativeDocumentsDto.fromJS(item));
            }
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(CountryDto.fromJS(item));
            }
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            this.processManagerId = _data["processManagerId"];
            if (Array.isArray(_data["processManagers"])) {
                this.processManagers = [] as any;
                for (let item of _data["processManagers"])
                    this.processManagers!.push(BusinessServiceOwner.fromJS(item));
            }
            this.processOwnerId = _data["processOwnerId"];
            if (Array.isArray(_data["processOwners"])) {
                this.processOwners = [] as any;
                for (let item of _data["processOwners"])
                    this.processOwners!.push(BusinessServiceOwner.fromJS(item));
            }
            this.businessUnitId = _data["businessUnitId"];
            if (Array.isArray(_data["businessUnits"])) {
                this.businessUnits = [] as any;
                for (let item of _data["businessUnits"])
                    this.businessUnits!.push(BusinessUnitPrimaryDto.fromJS(item));
            }
            this.regulatoryId = _data["regulatoryId"];
            if (Array.isArray(_data["regulatorys"])) {
                this.regulatorys = [] as any;
                for (let item of _data["regulatorys"])
                    this.regulatorys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.processPriorityId = _data["processPriorityId"];
            if (Array.isArray(_data["processPrioritys"])) {
                this.processPrioritys = [] as any;
                for (let item of _data["processPrioritys"])
                    this.processPrioritys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.othersId = _data["othersId"];
            if (Array.isArray(_data["otheres"])) {
                this.otheres = [] as any;
                for (let item of _data["otheres"])
                    this.otheres!.push(GetDynamicValueDto.fromJS(item));
            }
            this.confidentialityId = _data["confidentialityId"];
            if (Array.isArray(_data["confidentialitys"])) {
                this.confidentialitys = [] as any;
                for (let item of _data["confidentialitys"])
                    this.confidentialitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.reviewPeriodId = _data["reviewPeriodId"];
            if (Array.isArray(_data["reviewPeriods"])) {
                this.reviewPeriods = [] as any;
                for (let item of _data["reviewPeriods"])
                    this.reviewPeriods!.push(GetDynamicValueDto.fromJS(item));
            }
            this.intergrityId = _data["intergrityId"];
            if (Array.isArray(_data["intergritys"])) {
                this.intergritys = [] as any;
                for (let item of _data["intergritys"])
                    this.intergritys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.availibilityId = _data["availibilityId"];
            if (Array.isArray(_data["availibilityes"])) {
                this.availibilityes = [] as any;
                for (let item of _data["availibilityes"])
                    this.availibilityes!.push(GetDynamicValueDto.fromJS(item));
            }
            this.documents = _data["documents"];
            if (Array.isArray(_data["businessServices"])) {
                this.businessServices = [] as any;
                for (let item of _data["businessServices"])
                    this.businessServices!.push(BusinessServiceSDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedBusinessProcessAuthorativeDocuments"])) {
                this.selectedBusinessProcessAuthorativeDocuments = [] as any;
                for (let item of _data["selectedBusinessProcessAuthorativeDocuments"])
                    this.selectedBusinessProcessAuthorativeDocuments!.push(BusinessProcessAuthorativeDocumentDto.fromJS(item));
            }
            if (Array.isArray(_data["removedBusinessProcessAuthorativeDocuments"])) {
                this.removedBusinessProcessAuthorativeDocuments = [] as any;
                for (let item of _data["removedBusinessProcessAuthorativeDocuments"])
                    this.removedBusinessProcessAuthorativeDocuments!.push(item);
            }
            if (Array.isArray(_data["selectedBusinessProcessUnits"])) {
                this.selectedBusinessProcessUnits = [] as any;
                for (let item of _data["selectedBusinessProcessUnits"])
                    this.selectedBusinessProcessUnits!.push(BusinessProcessUnitDto.fromJS(item));
            }
            if (Array.isArray(_data["removedBusinessProcessUnits"])) {
                this.removedBusinessProcessUnits = [] as any;
                for (let item of _data["removedBusinessProcessUnits"])
                    this.removedBusinessProcessUnits!.push(item);
            }
            if (Array.isArray(_data["selectedBusinessProcessServices"])) {
                this.selectedBusinessProcessServices = [] as any;
                for (let item of _data["selectedBusinessProcessServices"])
                    this.selectedBusinessProcessServices!.push(BusinessProcessServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["removedBusinessProcessServices"])) {
                this.removedBusinessProcessServices = [] as any;
                for (let item of _data["removedBusinessProcessServices"])
                    this.removedBusinessProcessServices!.push(item);
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["businessProcessId"] = this.businessProcessId;
        data["businessProcessName"] = this.businessProcessName;
        data["statusId"] = this.statusId;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["processTypeId"] = this.processTypeId;
        if (Array.isArray(this.processTypes)) {
            data["processTypes"] = [];
            for (let item of this.processTypes)
                data["processTypes"].push(item.toJSON());
        }
        data["slaApplicableId"] = this.slaApplicableId;
        if (Array.isArray(this.slaApplicables)) {
            data["slaApplicables"] = [];
            for (let item of this.slaApplicables)
                data["slaApplicables"].push(item.toJSON());
        }
        data["activityCycleId"] = this.activityCycleId;
        if (Array.isArray(this.activityCycles)) {
            data["activityCycles"] = [];
            for (let item of this.activityCycles)
                data["activityCycles"].push(item.toJSON());
        }
        if (Array.isArray(this.authoratativeDocuments)) {
            data["authoratativeDocuments"] = [];
            for (let item of this.authoratativeDocuments)
                data["authoratativeDocuments"].push(item.toJSON());
        }
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        data["processManagerId"] = this.processManagerId;
        if (Array.isArray(this.processManagers)) {
            data["processManagers"] = [];
            for (let item of this.processManagers)
                data["processManagers"].push(item.toJSON());
        }
        data["processOwnerId"] = this.processOwnerId;
        if (Array.isArray(this.processOwners)) {
            data["processOwners"] = [];
            for (let item of this.processOwners)
                data["processOwners"].push(item.toJSON());
        }
        data["businessUnitId"] = this.businessUnitId;
        if (Array.isArray(this.businessUnits)) {
            data["businessUnits"] = [];
            for (let item of this.businessUnits)
                data["businessUnits"].push(item.toJSON());
        }
        data["regulatoryId"] = this.regulatoryId;
        if (Array.isArray(this.regulatorys)) {
            data["regulatorys"] = [];
            for (let item of this.regulatorys)
                data["regulatorys"].push(item.toJSON());
        }
        data["processPriorityId"] = this.processPriorityId;
        if (Array.isArray(this.processPrioritys)) {
            data["processPrioritys"] = [];
            for (let item of this.processPrioritys)
                data["processPrioritys"].push(item.toJSON());
        }
        data["othersId"] = this.othersId;
        if (Array.isArray(this.otheres)) {
            data["otheres"] = [];
            for (let item of this.otheres)
                data["otheres"].push(item.toJSON());
        }
        data["confidentialityId"] = this.confidentialityId;
        if (Array.isArray(this.confidentialitys)) {
            data["confidentialitys"] = [];
            for (let item of this.confidentialitys)
                data["confidentialitys"].push(item.toJSON());
        }
        data["reviewPeriodId"] = this.reviewPeriodId;
        if (Array.isArray(this.reviewPeriods)) {
            data["reviewPeriods"] = [];
            for (let item of this.reviewPeriods)
                data["reviewPeriods"].push(item.toJSON());
        }
        data["intergrityId"] = this.intergrityId;
        if (Array.isArray(this.intergritys)) {
            data["intergritys"] = [];
            for (let item of this.intergritys)
                data["intergritys"].push(item.toJSON());
        }
        data["availibilityId"] = this.availibilityId;
        if (Array.isArray(this.availibilityes)) {
            data["availibilityes"] = [];
            for (let item of this.availibilityes)
                data["availibilityes"].push(item.toJSON());
        }
        data["documents"] = this.documents;
        if (Array.isArray(this.businessServices)) {
            data["businessServices"] = [];
            for (let item of this.businessServices)
                data["businessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedBusinessProcessAuthorativeDocuments)) {
            data["selectedBusinessProcessAuthorativeDocuments"] = [];
            for (let item of this.selectedBusinessProcessAuthorativeDocuments)
                data["selectedBusinessProcessAuthorativeDocuments"].push(item.toJSON());
        }
        if (Array.isArray(this.removedBusinessProcessAuthorativeDocuments)) {
            data["removedBusinessProcessAuthorativeDocuments"] = [];
            for (let item of this.removedBusinessProcessAuthorativeDocuments)
                data["removedBusinessProcessAuthorativeDocuments"].push(item);
        }
        if (Array.isArray(this.selectedBusinessProcessUnits)) {
            data["selectedBusinessProcessUnits"] = [];
            for (let item of this.selectedBusinessProcessUnits)
                data["selectedBusinessProcessUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.removedBusinessProcessUnits)) {
            data["removedBusinessProcessUnits"] = [];
            for (let item of this.removedBusinessProcessUnits)
                data["removedBusinessProcessUnits"].push(item);
        }
        if (Array.isArray(this.selectedBusinessProcessServices)) {
            data["selectedBusinessProcessServices"] = [];
            for (let item of this.selectedBusinessProcessServices)
                data["selectedBusinessProcessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.removedBusinessProcessServices)) {
            data["removedBusinessProcessServices"] = [];
            for (let item of this.removedBusinessProcessServices)
                data["removedBusinessProcessServices"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusinessProcessDto {
    tenantId: number | undefined;
    businessProcessId: string | undefined;
    businessProcessName: string | undefined;
    statusId: number | undefined;
    statuses: GetDynamicValueDto[] | undefined;
    description: string | undefined;
    processTypeId: number | undefined;
    processTypes: GetDynamicValueDto[] | undefined;
    slaApplicableId: number | undefined;
    slaApplicables: GetDynamicValueDto[] | undefined;
    activityCycleId: number | undefined;
    activityCycles: GetDynamicValueDto[] | undefined;
    authoratativeDocuments: AuthoratativeDocumentsDto[] | undefined;
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    countryId: number | undefined;
    countries: CountryDto[] | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    processManagerId: number | undefined;
    processManagers: BusinessServiceOwner[] | undefined;
    processOwnerId: number | undefined;
    processOwners: BusinessServiceOwner[] | undefined;
    businessUnitId: number | undefined;
    businessUnits: BusinessUnitPrimaryDto[] | undefined;
    regulatoryId: number | undefined;
    regulatorys: GetDynamicValueDto[] | undefined;
    processPriorityId: number | undefined;
    processPrioritys: GetDynamicValueDto[] | undefined;
    othersId: number | undefined;
    otheres: GetDynamicValueDto[] | undefined;
    confidentialityId: number | undefined;
    confidentialitys: GetDynamicValueDto[] | undefined;
    reviewPeriodId: number | undefined;
    reviewPeriods: GetDynamicValueDto[] | undefined;
    intergrityId: number | undefined;
    intergritys: GetDynamicValueDto[] | undefined;
    availibilityId: number | undefined;
    availibilityes: GetDynamicValueDto[] | undefined;
    documents: string | undefined;
    businessServices: BusinessServiceSDto[] | undefined;
    selectedBusinessProcessAuthorativeDocuments: BusinessProcessAuthorativeDocumentDto[] | undefined;
    removedBusinessProcessAuthorativeDocuments: number[] | undefined;
    selectedBusinessProcessUnits: BusinessProcessUnitDto[] | undefined;
    removedBusinessProcessUnits: number[] | undefined;
    selectedBusinessProcessServices: BusinessProcessServiceDto[] | undefined;
    removedBusinessProcessServices: number[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export enum LevelType {
    Consortium = 1,
    BusinessGroup = 2,
    Company = 3,
}

export class GetOrganizationForEditDto implements IGetOrganizationForEditDto {
    id!: number;
    tenantId!: number | undefined;
    companyId!: string | undefined;
    companyName!: string | undefined;
    leveltype!: LevelType;
    organizationUnitId!: number | undefined;
    parentOrganizationId!: number | undefined;
    industrySectorId!: number | undefined;
    industrySector!: DynamicPropertyValue;
    isAuditableEntity!: boolean;
    description!: string | undefined;
    countryId!: number | undefined;
    country!: DynamicPropertyValue;
    employeeSize!: number;
    companyWebsite!: string | undefined;
    companyLogo!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    addressCountryId!: number | undefined;
    addressCountry!: DynamicPropertyValue;
    contactFirstName!: string | undefined;
    contactLastName!: string | undefined;
    jobTitle!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    primaryContactId!: number | undefined;
    companyAdministratorId!: number | undefined;
    isActive!: boolean;

    constructor(data?: IGetOrganizationForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.leveltype = _data["leveltype"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.parentOrganizationId = _data["parentOrganizationId"];
            this.industrySectorId = _data["industrySectorId"];
            this.industrySector = _data["industrySector"] ? DynamicPropertyValue.fromJS(_data["industrySector"]) : <any>undefined;
            this.isAuditableEntity = _data["isAuditableEntity"];
            this.description = _data["description"];
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? DynamicPropertyValue.fromJS(_data["country"]) : <any>undefined;
            this.employeeSize = _data["employeeSize"];
            this.companyWebsite = _data["companyWebsite"];
            this.companyLogo = _data["companyLogo"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.addressCountryId = _data["addressCountryId"];
            this.addressCountry = _data["addressCountry"] ? DynamicPropertyValue.fromJS(_data["addressCountry"]) : <any>undefined;
            this.contactFirstName = _data["contactFirstName"];
            this.contactLastName = _data["contactLastName"];
            this.jobTitle = _data["jobTitle"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            this.primaryContactId = _data["primaryContactId"];
            this.companyAdministratorId = _data["companyAdministratorId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetOrganizationForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["leveltype"] = this.leveltype;
        data["organizationUnitId"] = this.organizationUnitId;
        data["parentOrganizationId"] = this.parentOrganizationId;
        data["industrySectorId"] = this.industrySectorId;
        data["industrySector"] = this.industrySector ? this.industrySector.toJSON() : <any>undefined;
        data["isAuditableEntity"] = this.isAuditableEntity;
        data["description"] = this.description;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["employeeSize"] = this.employeeSize;
        data["companyWebsite"] = this.companyWebsite;
        data["companyLogo"] = this.companyLogo;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["addressCountryId"] = this.addressCountryId;
        data["addressCountry"] = this.addressCountry ? this.addressCountry.toJSON() : <any>undefined;
        data["contactFirstName"] = this.contactFirstName;
        data["contactLastName"] = this.contactLastName;
        data["jobTitle"] = this.jobTitle;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["primaryContactId"] = this.primaryContactId;
        data["companyAdministratorId"] = this.companyAdministratorId;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IGetOrganizationForEditDto {
    id: number;
    tenantId: number | undefined;
    companyId: string | undefined;
    companyName: string | undefined;
    leveltype: LevelType;
    organizationUnitId: number | undefined;
    parentOrganizationId: number | undefined;
    industrySectorId: number | undefined;
    industrySector: DynamicPropertyValue;
    isAuditableEntity: boolean;
    description: string | undefined;
    countryId: number | undefined;
    country: DynamicPropertyValue;
    employeeSize: number;
    companyWebsite: string | undefined;
    companyLogo: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    addressCountryId: number | undefined;
    addressCountry: DynamicPropertyValue;
    contactFirstName: string | undefined;
    contactLastName: string | undefined;
    jobTitle: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    primaryContactId: number | undefined;
    companyAdministratorId: number | undefined;
    isActive: boolean;
}

export class GetBusinessUnitForEditDto implements IGetBusinessUnitForEditDto {
    id!: number;
    tenantId!: number | undefined;
    businessUnitId!: string | undefined;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationForEditDto;
    businessUnitTitle!: string | undefined;
    isAuditableEntity!: boolean;
    unitTypeId!: number | undefined;
    parentUnit!: number | undefined;
    organizationUnitId!: number | undefined;
    empId!: number | undefined;

    constructor(data?: IGetBusinessUnitForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.businessUnitId = _data["businessUnitId"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationForEditDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.businessUnitTitle = _data["businessUnitTitle"];
            this.isAuditableEntity = _data["isAuditableEntity"];
            this.unitTypeId = _data["unitTypeId"];
            this.parentUnit = _data["parentUnit"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.empId = _data["empId"];
        }
    }

    static fromJS(data: any): GetBusinessUnitForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessUnitForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["businessUnitId"] = this.businessUnitId;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["businessUnitTitle"] = this.businessUnitTitle;
        data["isAuditableEntity"] = this.isAuditableEntity;
        data["unitTypeId"] = this.unitTypeId;
        data["parentUnit"] = this.parentUnit;
        data["organizationUnitId"] = this.organizationUnitId;
        data["empId"] = this.empId;
        return data; 
    }
}

export interface IGetBusinessUnitForEditDto {
    id: number;
    tenantId: number | undefined;
    businessUnitId: string | undefined;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationForEditDto;
    businessUnitTitle: string | undefined;
    isAuditableEntity: boolean;
    unitTypeId: number | undefined;
    parentUnit: number | undefined;
    organizationUnitId: number | undefined;
    empId: number | undefined;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean;
    shouldChangePasswordOnNextLogin!: boolean;
    isTwoFactorEnabled!: boolean;
    isLockoutEnabled!: boolean;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    isTwoFactorEnabled: boolean;
    isLockoutEnabled: boolean;
}

export class GetEmployeeForEditDto implements IGetEmployeeForEditDto {
    id!: number;
    tenantId!: number | undefined;
    employeeId!: string | undefined;
    dateOfBirth!: DateTime;
    name!: string | undefined;
    surname!: string | undefined;
    password!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    directPhone!: string | undefined;
    age!: number | undefined;
    profilePicture!: string | undefined;
    isNotifiedByEmail!: boolean;
    employeeTypeId!: number | undefined;
    employeeType!: DynamicPropertyValue;
    employeeGradeId!: number | undefined;
    employeeGrade!: DynamicPropertyValue;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationForEditDto;
    businessUnitId!: number | undefined;
    businessUnit!: GetBusinessUnitForEditDto;
    riskGroupId!: number | undefined;
    riskGroup!: DynamicPropertyValue;
    employeePosition!: string | undefined;
    userId!: number | undefined;
    user!: UserEditDto;
    accessCardId!: string | undefined;
    companyId!: string | undefined;
    isActive!: boolean;

    constructor(data?: IGetEmployeeForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.employeeId = _data["employeeId"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.password = _data["password"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.directPhone = _data["directPhone"];
            this.age = _data["age"];
            this.profilePicture = _data["profilePicture"];
            this.isNotifiedByEmail = _data["isNotifiedByEmail"];
            this.employeeTypeId = _data["employeeTypeId"];
            this.employeeType = _data["employeeType"] ? DynamicPropertyValue.fromJS(_data["employeeType"]) : <any>undefined;
            this.employeeGradeId = _data["employeeGradeId"];
            this.employeeGrade = _data["employeeGrade"] ? DynamicPropertyValue.fromJS(_data["employeeGrade"]) : <any>undefined;
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationForEditDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.businessUnitId = _data["businessUnitId"];
            this.businessUnit = _data["businessUnit"] ? GetBusinessUnitForEditDto.fromJS(_data["businessUnit"]) : <any>undefined;
            this.riskGroupId = _data["riskGroupId"];
            this.riskGroup = _data["riskGroup"] ? DynamicPropertyValue.fromJS(_data["riskGroup"]) : <any>undefined;
            this.employeePosition = _data["employeePosition"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : <any>undefined;
            this.accessCardId = _data["accessCardId"];
            this.companyId = _data["companyId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetEmployeeForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["employeeId"] = this.employeeId;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : <any>undefined;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["password"] = this.password;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["directPhone"] = this.directPhone;
        data["age"] = this.age;
        data["profilePicture"] = this.profilePicture;
        data["isNotifiedByEmail"] = this.isNotifiedByEmail;
        data["employeeTypeId"] = this.employeeTypeId;
        data["employeeType"] = this.employeeType ? this.employeeType.toJSON() : <any>undefined;
        data["employeeGradeId"] = this.employeeGradeId;
        data["employeeGrade"] = this.employeeGrade ? this.employeeGrade.toJSON() : <any>undefined;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["businessUnitId"] = this.businessUnitId;
        data["businessUnit"] = this.businessUnit ? this.businessUnit.toJSON() : <any>undefined;
        data["riskGroupId"] = this.riskGroupId;
        data["riskGroup"] = this.riskGroup ? this.riskGroup.toJSON() : <any>undefined;
        data["employeePosition"] = this.employeePosition;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["accessCardId"] = this.accessCardId;
        data["companyId"] = this.companyId;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IGetEmployeeForEditDto {
    id: number;
    tenantId: number | undefined;
    employeeId: string | undefined;
    dateOfBirth: DateTime;
    name: string | undefined;
    surname: string | undefined;
    password: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    directPhone: string | undefined;
    age: number | undefined;
    profilePicture: string | undefined;
    isNotifiedByEmail: boolean;
    employeeTypeId: number | undefined;
    employeeType: DynamicPropertyValue;
    employeeGradeId: number | undefined;
    employeeGrade: DynamicPropertyValue;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationForEditDto;
    businessUnitId: number | undefined;
    businessUnit: GetBusinessUnitForEditDto;
    riskGroupId: number | undefined;
    riskGroup: DynamicPropertyValue;
    employeePosition: string | undefined;
    userId: number | undefined;
    user: UserEditDto;
    accessCardId: string | undefined;
    companyId: string | undefined;
    isActive: boolean;
}

export class BusinessProcessListDto implements IBusinessProcessListDto {
    businessProcessId!: string | undefined;
    businessProcessName!: string | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationForEditDto;
    processOwnerId!: number | undefined;
    processOwner!: GetEmployeeForEditDto;
    statusId!: number | undefined;
    status!: DynamicPropertyValue;
    processTypeId!: number | undefined;
    processType!: DynamicPropertyValue;
    processPriorityId!: number | undefined;
    processPriority!: DynamicPropertyValue;
    description!: string | undefined;
    id!: number;

    constructor(data?: IBusinessProcessListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
            this.businessProcessName = _data["businessProcessName"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationForEditDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.processOwnerId = _data["processOwnerId"];
            this.processOwner = _data["processOwner"] ? GetEmployeeForEditDto.fromJS(_data["processOwner"]) : <any>undefined;
            this.statusId = _data["statusId"];
            this.status = _data["status"] ? DynamicPropertyValue.fromJS(_data["status"]) : <any>undefined;
            this.processTypeId = _data["processTypeId"];
            this.processType = _data["processType"] ? DynamicPropertyValue.fromJS(_data["processType"]) : <any>undefined;
            this.processPriorityId = _data["processPriorityId"];
            this.processPriority = _data["processPriority"] ? DynamicPropertyValue.fromJS(_data["processPriority"]) : <any>undefined;
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessProcessListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        data["businessProcessName"] = this.businessProcessName;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["processOwnerId"] = this.processOwnerId;
        data["processOwner"] = this.processOwner ? this.processOwner.toJSON() : <any>undefined;
        data["statusId"] = this.statusId;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["processTypeId"] = this.processTypeId;
        data["processType"] = this.processType ? this.processType.toJSON() : <any>undefined;
        data["processPriorityId"] = this.processPriorityId;
        data["processPriority"] = this.processPriority ? this.processPriority.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusinessProcessListDto {
    businessProcessId: string | undefined;
    businessProcessName: string | undefined;
    isActive: boolean;
    creationTime: DateTime;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationForEditDto;
    processOwnerId: number | undefined;
    processOwner: GetEmployeeForEditDto;
    statusId: number | undefined;
    status: DynamicPropertyValue;
    processTypeId: number | undefined;
    processType: DynamicPropertyValue;
    processPriorityId: number | undefined;
    processPriority: DynamicPropertyValue;
    description: string | undefined;
    id: number;
}

export class PagedResultDtoOfBusinessProcessListDto implements IPagedResultDtoOfBusinessProcessListDto {
    totalCount!: number;
    items!: BusinessProcessListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessProcessListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessProcessListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessProcessListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessProcessListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBusinessProcessListDto {
    totalCount: number;
    items: BusinessProcessListDto[] | undefined;
}

export class GetBusinessProcessForEditDto implements IGetBusinessProcessForEditDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    businessProcessId!: string | undefined;
    businessProcessName!: string;
    statusId!: number | undefined;
    status!: DynamicPropertyValue;
    description!: string | undefined;
    processTypeId!: number | undefined;
    processType!: DynamicPropertyValue;
    slaApplicableId!: number | undefined;
    slaApplicable!: DynamicPropertyValue;
    activityCycleId!: number | undefined;
    activityCycle!: DynamicPropertyValue;
    address!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number | undefined;
    country!: DynamicPropertyValue;
    companyNameId!: number | undefined;
    companyName!: GetOrganizationForEditDto;
    processManagerId!: number | undefined;
    processManager!: GetEmployeeForEditDto;
    processOwnerId!: number | undefined;
    processOwner!: GetEmployeeForEditDto;
    businessUnitOwnerId!: number | undefined;
    businessUnitOwner!: GetEmployeeForEditDto;
    regulatoryMandateId!: number | undefined;
    regulatoryMandate!: DynamicPropertyValue;
    processPriorityId!: number | undefined;
    processPriority!: DynamicPropertyValue;
    othersId!: number | undefined;
    others!: DynamicPropertyValue;
    confidentialityId!: number | undefined;
    confidentiality!: DynamicPropertyValue;
    reviewPeriodId!: number | undefined;
    reviewPeriod!: DynamicPropertyValue;
    intergrityId!: number | undefined;
    intergrity!: DynamicPropertyValue;
    availibilityId!: number | undefined;
    availibility!: DynamicPropertyValue;
    documents!: string | undefined;

    constructor(data?: IGetBusinessProcessForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.businessProcessId = _data["businessProcessId"];
            this.businessProcessName = _data["businessProcessName"];
            this.statusId = _data["statusId"];
            this.status = _data["status"] ? DynamicPropertyValue.fromJS(_data["status"]) : <any>undefined;
            this.description = _data["description"];
            this.processTypeId = _data["processTypeId"];
            this.processType = _data["processType"] ? DynamicPropertyValue.fromJS(_data["processType"]) : <any>undefined;
            this.slaApplicableId = _data["slaApplicableId"];
            this.slaApplicable = _data["slaApplicable"] ? DynamicPropertyValue.fromJS(_data["slaApplicable"]) : <any>undefined;
            this.activityCycleId = _data["activityCycleId"];
            this.activityCycle = _data["activityCycle"] ? DynamicPropertyValue.fromJS(_data["activityCycle"]) : <any>undefined;
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? DynamicPropertyValue.fromJS(_data["country"]) : <any>undefined;
            this.companyNameId = _data["companyNameId"];
            this.companyName = _data["companyName"] ? GetOrganizationForEditDto.fromJS(_data["companyName"]) : <any>undefined;
            this.processManagerId = _data["processManagerId"];
            this.processManager = _data["processManager"] ? GetEmployeeForEditDto.fromJS(_data["processManager"]) : <any>undefined;
            this.processOwnerId = _data["processOwnerId"];
            this.processOwner = _data["processOwner"] ? GetEmployeeForEditDto.fromJS(_data["processOwner"]) : <any>undefined;
            this.businessUnitOwnerId = _data["businessUnitOwnerId"];
            this.businessUnitOwner = _data["businessUnitOwner"] ? GetEmployeeForEditDto.fromJS(_data["businessUnitOwner"]) : <any>undefined;
            this.regulatoryMandateId = _data["regulatoryMandateId"];
            this.regulatoryMandate = _data["regulatoryMandate"] ? DynamicPropertyValue.fromJS(_data["regulatoryMandate"]) : <any>undefined;
            this.processPriorityId = _data["processPriorityId"];
            this.processPriority = _data["processPriority"] ? DynamicPropertyValue.fromJS(_data["processPriority"]) : <any>undefined;
            this.othersId = _data["othersId"];
            this.others = _data["others"] ? DynamicPropertyValue.fromJS(_data["others"]) : <any>undefined;
            this.confidentialityId = _data["confidentialityId"];
            this.confidentiality = _data["confidentiality"] ? DynamicPropertyValue.fromJS(_data["confidentiality"]) : <any>undefined;
            this.reviewPeriodId = _data["reviewPeriodId"];
            this.reviewPeriod = _data["reviewPeriod"] ? DynamicPropertyValue.fromJS(_data["reviewPeriod"]) : <any>undefined;
            this.intergrityId = _data["intergrityId"];
            this.intergrity = _data["intergrity"] ? DynamicPropertyValue.fromJS(_data["intergrity"]) : <any>undefined;
            this.availibilityId = _data["availibilityId"];
            this.availibility = _data["availibility"] ? DynamicPropertyValue.fromJS(_data["availibility"]) : <any>undefined;
            this.documents = _data["documents"];
        }
    }

    static fromJS(data: any): GetBusinessProcessForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessProcessForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["businessProcessId"] = this.businessProcessId;
        data["businessProcessName"] = this.businessProcessName;
        data["statusId"] = this.statusId;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["processTypeId"] = this.processTypeId;
        data["processType"] = this.processType ? this.processType.toJSON() : <any>undefined;
        data["slaApplicableId"] = this.slaApplicableId;
        data["slaApplicable"] = this.slaApplicable ? this.slaApplicable.toJSON() : <any>undefined;
        data["activityCycleId"] = this.activityCycleId;
        data["activityCycle"] = this.activityCycle ? this.activityCycle.toJSON() : <any>undefined;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["companyNameId"] = this.companyNameId;
        data["companyName"] = this.companyName ? this.companyName.toJSON() : <any>undefined;
        data["processManagerId"] = this.processManagerId;
        data["processManager"] = this.processManager ? this.processManager.toJSON() : <any>undefined;
        data["processOwnerId"] = this.processOwnerId;
        data["processOwner"] = this.processOwner ? this.processOwner.toJSON() : <any>undefined;
        data["businessUnitOwnerId"] = this.businessUnitOwnerId;
        data["businessUnitOwner"] = this.businessUnitOwner ? this.businessUnitOwner.toJSON() : <any>undefined;
        data["regulatoryMandateId"] = this.regulatoryMandateId;
        data["regulatoryMandate"] = this.regulatoryMandate ? this.regulatoryMandate.toJSON() : <any>undefined;
        data["processPriorityId"] = this.processPriorityId;
        data["processPriority"] = this.processPriority ? this.processPriority.toJSON() : <any>undefined;
        data["othersId"] = this.othersId;
        data["others"] = this.others ? this.others.toJSON() : <any>undefined;
        data["confidentialityId"] = this.confidentialityId;
        data["confidentiality"] = this.confidentiality ? this.confidentiality.toJSON() : <any>undefined;
        data["reviewPeriodId"] = this.reviewPeriodId;
        data["reviewPeriod"] = this.reviewPeriod ? this.reviewPeriod.toJSON() : <any>undefined;
        data["intergrityId"] = this.intergrityId;
        data["intergrity"] = this.intergrity ? this.intergrity.toJSON() : <any>undefined;
        data["availibilityId"] = this.availibilityId;
        data["availibility"] = this.availibility ? this.availibility.toJSON() : <any>undefined;
        data["documents"] = this.documents;
        return data; 
    }
}

export interface IGetBusinessProcessForEditDto {
    id: number | undefined;
    tenantId: number | undefined;
    businessProcessId: string | undefined;
    businessProcessName: string;
    statusId: number | undefined;
    status: DynamicPropertyValue;
    description: string | undefined;
    processTypeId: number | undefined;
    processType: DynamicPropertyValue;
    slaApplicableId: number | undefined;
    slaApplicable: DynamicPropertyValue;
    activityCycleId: number | undefined;
    activityCycle: DynamicPropertyValue;
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    countryId: number | undefined;
    country: DynamicPropertyValue;
    companyNameId: number | undefined;
    companyName: GetOrganizationForEditDto;
    processManagerId: number | undefined;
    processManager: GetEmployeeForEditDto;
    processOwnerId: number | undefined;
    processOwner: GetEmployeeForEditDto;
    businessUnitOwnerId: number | undefined;
    businessUnitOwner: GetEmployeeForEditDto;
    regulatoryMandateId: number | undefined;
    regulatoryMandate: DynamicPropertyValue;
    processPriorityId: number | undefined;
    processPriority: DynamicPropertyValue;
    othersId: number | undefined;
    others: DynamicPropertyValue;
    confidentialityId: number | undefined;
    confidentiality: DynamicPropertyValue;
    reviewPeriodId: number | undefined;
    reviewPeriod: DynamicPropertyValue;
    intergrityId: number | undefined;
    intergrity: DynamicPropertyValue;
    availibilityId: number | undefined;
    availibility: DynamicPropertyValue;
    documents: string | undefined;
}

export class ITserviceBusinessServiceDto implements IITserviceBusinessServiceDto {
    itServiceId!: number | undefined;
    businessServiceId!: number | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IITserviceBusinessServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itServiceId = _data["itServiceId"];
            this.businessServiceId = _data["businessServiceId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ITserviceBusinessServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ITserviceBusinessServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itServiceId"] = this.itServiceId;
        data["businessServiceId"] = this.businessServiceId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IITserviceBusinessServiceDto {
    itServiceId: number | undefined;
    businessServiceId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ServiceBusinessUnitDto implements IServiceBusinessUnitDto {
    id!: number;
    businessServiceId!: number | undefined;
    businessUnitId!: number | undefined;

    constructor(data?: IServiceBusinessUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessServiceId = _data["businessServiceId"];
            this.businessUnitId = _data["businessUnitId"];
        }
    }

    static fromJS(data: any): ServiceBusinessUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceBusinessUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessServiceId"] = this.businessServiceId;
        data["businessUnitId"] = this.businessUnitId;
        return data; 
    }
}

export interface IServiceBusinessUnitDto {
    id: number;
    businessServiceId: number | undefined;
    businessUnitId: number | undefined;
}

export class BusinessServiceDto implements IBusinessServiceDto {
    tenantId!: number | undefined;
    businessServiceId!: string | undefined;
    businessServiceName!: string | undefined;
    businessUnitDependentId!: number | undefined;
    businessUnits!: BusinessUnitPrimaryDto[] | undefined;
    businessUnitprimaryId!: number | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    businessServiceOwnerId!: number | undefined;
    businessServiceOwners!: BusinessServiceOwner[] | undefined;
    businessServiceManagerId!: number | undefined;
    serviceTypeId!: number | undefined;
    serviceTypes!: GetDynamicValueDto[] | undefined;
    confidentialityId!: number | undefined;
    confidentialitys!: GetDynamicValueDto[] | undefined;
    intergrityId!: number | undefined;
    intergritys!: GetDynamicValueDto[] | undefined;
    othersId!: number | undefined;
    otheres!: GetDynamicValueDto[] | undefined;
    availibilityId!: number | undefined;
    availibilitys!: GetDynamicValueDto[] | undefined;
    iTserviceLists!: ITserviceListDto[] | undefined;
    selectedItServices!: ITserviceBusinessServiceDto[] | undefined;
    removedItServices!: number[] | undefined;
    removedBusinessUnits!: number[] | undefined;
    selectdBusinessUnits!: ServiceBusinessUnitDto[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBusinessServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.businessServiceId = _data["businessServiceId"];
            this.businessServiceName = _data["businessServiceName"];
            this.businessUnitDependentId = _data["businessUnitDependentId"];
            if (Array.isArray(_data["businessUnits"])) {
                this.businessUnits = [] as any;
                for (let item of _data["businessUnits"])
                    this.businessUnits!.push(BusinessUnitPrimaryDto.fromJS(item));
            }
            this.businessUnitprimaryId = _data["businessUnitprimaryId"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            this.businessServiceOwnerId = _data["businessServiceOwnerId"];
            if (Array.isArray(_data["businessServiceOwners"])) {
                this.businessServiceOwners = [] as any;
                for (let item of _data["businessServiceOwners"])
                    this.businessServiceOwners!.push(BusinessServiceOwner.fromJS(item));
            }
            this.businessServiceManagerId = _data["businessServiceManagerId"];
            this.serviceTypeId = _data["serviceTypeId"];
            if (Array.isArray(_data["serviceTypes"])) {
                this.serviceTypes = [] as any;
                for (let item of _data["serviceTypes"])
                    this.serviceTypes!.push(GetDynamicValueDto.fromJS(item));
            }
            this.confidentialityId = _data["confidentialityId"];
            if (Array.isArray(_data["confidentialitys"])) {
                this.confidentialitys = [] as any;
                for (let item of _data["confidentialitys"])
                    this.confidentialitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.intergrityId = _data["intergrityId"];
            if (Array.isArray(_data["intergritys"])) {
                this.intergritys = [] as any;
                for (let item of _data["intergritys"])
                    this.intergritys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.othersId = _data["othersId"];
            if (Array.isArray(_data["otheres"])) {
                this.otheres = [] as any;
                for (let item of _data["otheres"])
                    this.otheres!.push(GetDynamicValueDto.fromJS(item));
            }
            this.availibilityId = _data["availibilityId"];
            if (Array.isArray(_data["availibilitys"])) {
                this.availibilitys = [] as any;
                for (let item of _data["availibilitys"])
                    this.availibilitys!.push(GetDynamicValueDto.fromJS(item));
            }
            if (Array.isArray(_data["iTserviceLists"])) {
                this.iTserviceLists = [] as any;
                for (let item of _data["iTserviceLists"])
                    this.iTserviceLists!.push(ITserviceListDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedItServices"])) {
                this.selectedItServices = [] as any;
                for (let item of _data["selectedItServices"])
                    this.selectedItServices!.push(ITserviceBusinessServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["removedItServices"])) {
                this.removedItServices = [] as any;
                for (let item of _data["removedItServices"])
                    this.removedItServices!.push(item);
            }
            if (Array.isArray(_data["removedBusinessUnits"])) {
                this.removedBusinessUnits = [] as any;
                for (let item of _data["removedBusinessUnits"])
                    this.removedBusinessUnits!.push(item);
            }
            if (Array.isArray(_data["selectdBusinessUnits"])) {
                this.selectdBusinessUnits = [] as any;
                for (let item of _data["selectdBusinessUnits"])
                    this.selectdBusinessUnits!.push(ServiceBusinessUnitDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["businessServiceId"] = this.businessServiceId;
        data["businessServiceName"] = this.businessServiceName;
        data["businessUnitDependentId"] = this.businessUnitDependentId;
        if (Array.isArray(this.businessUnits)) {
            data["businessUnits"] = [];
            for (let item of this.businessUnits)
                data["businessUnits"].push(item.toJSON());
        }
        data["businessUnitprimaryId"] = this.businessUnitprimaryId;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        data["businessServiceOwnerId"] = this.businessServiceOwnerId;
        if (Array.isArray(this.businessServiceOwners)) {
            data["businessServiceOwners"] = [];
            for (let item of this.businessServiceOwners)
                data["businessServiceOwners"].push(item.toJSON());
        }
        data["businessServiceManagerId"] = this.businessServiceManagerId;
        data["serviceTypeId"] = this.serviceTypeId;
        if (Array.isArray(this.serviceTypes)) {
            data["serviceTypes"] = [];
            for (let item of this.serviceTypes)
                data["serviceTypes"].push(item.toJSON());
        }
        data["confidentialityId"] = this.confidentialityId;
        if (Array.isArray(this.confidentialitys)) {
            data["confidentialitys"] = [];
            for (let item of this.confidentialitys)
                data["confidentialitys"].push(item.toJSON());
        }
        data["intergrityId"] = this.intergrityId;
        if (Array.isArray(this.intergritys)) {
            data["intergritys"] = [];
            for (let item of this.intergritys)
                data["intergritys"].push(item.toJSON());
        }
        data["othersId"] = this.othersId;
        if (Array.isArray(this.otheres)) {
            data["otheres"] = [];
            for (let item of this.otheres)
                data["otheres"].push(item.toJSON());
        }
        data["availibilityId"] = this.availibilityId;
        if (Array.isArray(this.availibilitys)) {
            data["availibilitys"] = [];
            for (let item of this.availibilitys)
                data["availibilitys"].push(item.toJSON());
        }
        if (Array.isArray(this.iTserviceLists)) {
            data["iTserviceLists"] = [];
            for (let item of this.iTserviceLists)
                data["iTserviceLists"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedItServices)) {
            data["selectedItServices"] = [];
            for (let item of this.selectedItServices)
                data["selectedItServices"].push(item.toJSON());
        }
        if (Array.isArray(this.removedItServices)) {
            data["removedItServices"] = [];
            for (let item of this.removedItServices)
                data["removedItServices"].push(item);
        }
        if (Array.isArray(this.removedBusinessUnits)) {
            data["removedBusinessUnits"] = [];
            for (let item of this.removedBusinessUnits)
                data["removedBusinessUnits"].push(item);
        }
        if (Array.isArray(this.selectdBusinessUnits)) {
            data["selectdBusinessUnits"] = [];
            for (let item of this.selectdBusinessUnits)
                data["selectdBusinessUnits"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusinessServiceDto {
    tenantId: number | undefined;
    businessServiceId: string | undefined;
    businessServiceName: string | undefined;
    businessUnitDependentId: number | undefined;
    businessUnits: BusinessUnitPrimaryDto[] | undefined;
    businessUnitprimaryId: number | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    businessServiceOwnerId: number | undefined;
    businessServiceOwners: BusinessServiceOwner[] | undefined;
    businessServiceManagerId: number | undefined;
    serviceTypeId: number | undefined;
    serviceTypes: GetDynamicValueDto[] | undefined;
    confidentialityId: number | undefined;
    confidentialitys: GetDynamicValueDto[] | undefined;
    intergrityId: number | undefined;
    intergritys: GetDynamicValueDto[] | undefined;
    othersId: number | undefined;
    otheres: GetDynamicValueDto[] | undefined;
    availibilityId: number | undefined;
    availibilitys: GetDynamicValueDto[] | undefined;
    iTserviceLists: ITserviceListDto[] | undefined;
    selectedItServices: ITserviceBusinessServiceDto[] | undefined;
    removedItServices: number[] | undefined;
    removedBusinessUnits: number[] | undefined;
    selectdBusinessUnits: ServiceBusinessUnitDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class BusinessServicesListDto implements IBusinessServicesListDto {
    businessServiceId!: string | undefined;
    businessServiceName!: string | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    businessServiceOwnerId!: number | undefined;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationDto;
    businessServiceOwner!: GetEmployeeForEditDto;
    businessServiceManagerId!: number | undefined;
    businessServiceManager!: GetEmployeeForEditDto;
    businessUnitDependentId!: number | undefined;
    businessUnitDependent!: BusinessUnitPrimaryDto;
    businessUnitprimaryId!: number | undefined;
    businessUnitprimary!: BusinessUnitPrimaryDto;
    serviceTypeId!: number | undefined;
    serviceType!: DynamicPropertyValue;
    confidentialityId!: number | undefined;
    confidentiality!: DynamicPropertyValue;
    intergrityId!: number | undefined;
    intergrity!: DynamicPropertyValue;
    availibilityId!: number | undefined;
    availibility!: DynamicPropertyValue;
    id!: number;

    constructor(data?: IBusinessServicesListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessServiceId = _data["businessServiceId"];
            this.businessServiceName = _data["businessServiceName"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.businessServiceOwnerId = _data["businessServiceOwnerId"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.businessServiceOwner = _data["businessServiceOwner"] ? GetEmployeeForEditDto.fromJS(_data["businessServiceOwner"]) : <any>undefined;
            this.businessServiceManagerId = _data["businessServiceManagerId"];
            this.businessServiceManager = _data["businessServiceManager"] ? GetEmployeeForEditDto.fromJS(_data["businessServiceManager"]) : <any>undefined;
            this.businessUnitDependentId = _data["businessUnitDependentId"];
            this.businessUnitDependent = _data["businessUnitDependent"] ? BusinessUnitPrimaryDto.fromJS(_data["businessUnitDependent"]) : <any>undefined;
            this.businessUnitprimaryId = _data["businessUnitprimaryId"];
            this.businessUnitprimary = _data["businessUnitprimary"] ? BusinessUnitPrimaryDto.fromJS(_data["businessUnitprimary"]) : <any>undefined;
            this.serviceTypeId = _data["serviceTypeId"];
            this.serviceType = _data["serviceType"] ? DynamicPropertyValue.fromJS(_data["serviceType"]) : <any>undefined;
            this.confidentialityId = _data["confidentialityId"];
            this.confidentiality = _data["confidentiality"] ? DynamicPropertyValue.fromJS(_data["confidentiality"]) : <any>undefined;
            this.intergrityId = _data["intergrityId"];
            this.intergrity = _data["intergrity"] ? DynamicPropertyValue.fromJS(_data["intergrity"]) : <any>undefined;
            this.availibilityId = _data["availibilityId"];
            this.availibility = _data["availibility"] ? DynamicPropertyValue.fromJS(_data["availibility"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessServicesListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessServicesListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessServiceId"] = this.businessServiceId;
        data["businessServiceName"] = this.businessServiceName;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["businessServiceOwnerId"] = this.businessServiceOwnerId;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["businessServiceOwner"] = this.businessServiceOwner ? this.businessServiceOwner.toJSON() : <any>undefined;
        data["businessServiceManagerId"] = this.businessServiceManagerId;
        data["businessServiceManager"] = this.businessServiceManager ? this.businessServiceManager.toJSON() : <any>undefined;
        data["businessUnitDependentId"] = this.businessUnitDependentId;
        data["businessUnitDependent"] = this.businessUnitDependent ? this.businessUnitDependent.toJSON() : <any>undefined;
        data["businessUnitprimaryId"] = this.businessUnitprimaryId;
        data["businessUnitprimary"] = this.businessUnitprimary ? this.businessUnitprimary.toJSON() : <any>undefined;
        data["serviceTypeId"] = this.serviceTypeId;
        data["serviceType"] = this.serviceType ? this.serviceType.toJSON() : <any>undefined;
        data["confidentialityId"] = this.confidentialityId;
        data["confidentiality"] = this.confidentiality ? this.confidentiality.toJSON() : <any>undefined;
        data["intergrityId"] = this.intergrityId;
        data["intergrity"] = this.intergrity ? this.intergrity.toJSON() : <any>undefined;
        data["availibilityId"] = this.availibilityId;
        data["availibility"] = this.availibility ? this.availibility.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusinessServicesListDto {
    businessServiceId: string | undefined;
    businessServiceName: string | undefined;
    isActive: boolean;
    creationTime: DateTime;
    businessServiceOwnerId: number | undefined;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationDto;
    businessServiceOwner: GetEmployeeForEditDto;
    businessServiceManagerId: number | undefined;
    businessServiceManager: GetEmployeeForEditDto;
    businessUnitDependentId: number | undefined;
    businessUnitDependent: BusinessUnitPrimaryDto;
    businessUnitprimaryId: number | undefined;
    businessUnitprimary: BusinessUnitPrimaryDto;
    serviceTypeId: number | undefined;
    serviceType: DynamicPropertyValue;
    confidentialityId: number | undefined;
    confidentiality: DynamicPropertyValue;
    intergrityId: number | undefined;
    intergrity: DynamicPropertyValue;
    availibilityId: number | undefined;
    availibility: DynamicPropertyValue;
    id: number;
}

export class PagedResultDtoOfBusinessServicesListDto implements IPagedResultDtoOfBusinessServicesListDto {
    totalCount!: number;
    items!: BusinessServicesListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessServicesListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessServicesListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessServicesListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessServicesListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBusinessServicesListDto {
    totalCount: number;
    items: BusinessServicesListDto[] | undefined;
}

export class BusinessUnitDto implements IBusinessUnitDto {
    id!: number;
    businessUnitTitle!: string | undefined;

    constructor(data?: IBusinessUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessUnitTitle = _data["businessUnitTitle"];
        }
    }

    static fromJS(data: any): BusinessUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessUnitTitle"] = this.businessUnitTitle;
        return data; 
    }
}

export interface IBusinessUnitDto {
    id: number;
    businessUnitTitle: string | undefined;
}

export class GetBusinessServicesForEditDto implements IGetBusinessServicesForEditDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    businessServiceId!: string | undefined;
    businessServiceName!: string | undefined;
    businessUnitDependentId!: number | undefined;
    businessUnitDependent!: GetBusinessUnitForEditDto;
    businessUnitprimaryId!: number | undefined;
    businessUnitprimary!: GetBusinessUnitForEditDto;
    companyNameId!: number | undefined;
    companyName!: GetOrganizationForEditDto;
    businessServiceOwnerId!: number | undefined;
    businessServiceOwner!: GetEmployeeForEditDto;
    businessServiceManagerId!: number | undefined;
    businessServiceManager!: GetEmployeeForEditDto;
    serviceTypeId!: number | undefined;
    serviceType!: DynamicPropertyValue;
    confidentialityId!: number | undefined;
    confidentiality!: DynamicPropertyValue;
    intergrityId!: number | undefined;
    intergrity!: DynamicPropertyValue;
    othersId!: number | undefined;
    others!: DynamicPropertyValue;
    businessUnits!: BusinessUnitDto[] | undefined;

    constructor(data?: IGetBusinessServicesForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.businessServiceId = _data["businessServiceId"];
            this.businessServiceName = _data["businessServiceName"];
            this.businessUnitDependentId = _data["businessUnitDependentId"];
            this.businessUnitDependent = _data["businessUnitDependent"] ? GetBusinessUnitForEditDto.fromJS(_data["businessUnitDependent"]) : <any>undefined;
            this.businessUnitprimaryId = _data["businessUnitprimaryId"];
            this.businessUnitprimary = _data["businessUnitprimary"] ? GetBusinessUnitForEditDto.fromJS(_data["businessUnitprimary"]) : <any>undefined;
            this.companyNameId = _data["companyNameId"];
            this.companyName = _data["companyName"] ? GetOrganizationForEditDto.fromJS(_data["companyName"]) : <any>undefined;
            this.businessServiceOwnerId = _data["businessServiceOwnerId"];
            this.businessServiceOwner = _data["businessServiceOwner"] ? GetEmployeeForEditDto.fromJS(_data["businessServiceOwner"]) : <any>undefined;
            this.businessServiceManagerId = _data["businessServiceManagerId"];
            this.businessServiceManager = _data["businessServiceManager"] ? GetEmployeeForEditDto.fromJS(_data["businessServiceManager"]) : <any>undefined;
            this.serviceTypeId = _data["serviceTypeId"];
            this.serviceType = _data["serviceType"] ? DynamicPropertyValue.fromJS(_data["serviceType"]) : <any>undefined;
            this.confidentialityId = _data["confidentialityId"];
            this.confidentiality = _data["confidentiality"] ? DynamicPropertyValue.fromJS(_data["confidentiality"]) : <any>undefined;
            this.intergrityId = _data["intergrityId"];
            this.intergrity = _data["intergrity"] ? DynamicPropertyValue.fromJS(_data["intergrity"]) : <any>undefined;
            this.othersId = _data["othersId"];
            this.others = _data["others"] ? DynamicPropertyValue.fromJS(_data["others"]) : <any>undefined;
            if (Array.isArray(_data["businessUnits"])) {
                this.businessUnits = [] as any;
                for (let item of _data["businessUnits"])
                    this.businessUnits!.push(BusinessUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetBusinessServicesForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessServicesForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["businessServiceId"] = this.businessServiceId;
        data["businessServiceName"] = this.businessServiceName;
        data["businessUnitDependentId"] = this.businessUnitDependentId;
        data["businessUnitDependent"] = this.businessUnitDependent ? this.businessUnitDependent.toJSON() : <any>undefined;
        data["businessUnitprimaryId"] = this.businessUnitprimaryId;
        data["businessUnitprimary"] = this.businessUnitprimary ? this.businessUnitprimary.toJSON() : <any>undefined;
        data["companyNameId"] = this.companyNameId;
        data["companyName"] = this.companyName ? this.companyName.toJSON() : <any>undefined;
        data["businessServiceOwnerId"] = this.businessServiceOwnerId;
        data["businessServiceOwner"] = this.businessServiceOwner ? this.businessServiceOwner.toJSON() : <any>undefined;
        data["businessServiceManagerId"] = this.businessServiceManagerId;
        data["businessServiceManager"] = this.businessServiceManager ? this.businessServiceManager.toJSON() : <any>undefined;
        data["serviceTypeId"] = this.serviceTypeId;
        data["serviceType"] = this.serviceType ? this.serviceType.toJSON() : <any>undefined;
        data["confidentialityId"] = this.confidentialityId;
        data["confidentiality"] = this.confidentiality ? this.confidentiality.toJSON() : <any>undefined;
        data["intergrityId"] = this.intergrityId;
        data["intergrity"] = this.intergrity ? this.intergrity.toJSON() : <any>undefined;
        data["othersId"] = this.othersId;
        data["others"] = this.others ? this.others.toJSON() : <any>undefined;
        if (Array.isArray(this.businessUnits)) {
            data["businessUnits"] = [];
            for (let item of this.businessUnits)
                data["businessUnits"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetBusinessServicesForEditDto {
    id: number | undefined;
    tenantId: number | undefined;
    businessServiceId: string | undefined;
    businessServiceName: string | undefined;
    businessUnitDependentId: number | undefined;
    businessUnitDependent: GetBusinessUnitForEditDto;
    businessUnitprimaryId: number | undefined;
    businessUnitprimary: GetBusinessUnitForEditDto;
    companyNameId: number | undefined;
    companyName: GetOrganizationForEditDto;
    businessServiceOwnerId: number | undefined;
    businessServiceOwner: GetEmployeeForEditDto;
    businessServiceManagerId: number | undefined;
    businessServiceManager: GetEmployeeForEditDto;
    serviceTypeId: number | undefined;
    serviceType: DynamicPropertyValue;
    confidentialityId: number | undefined;
    confidentiality: DynamicPropertyValue;
    intergrityId: number | undefined;
    intergrity: DynamicPropertyValue;
    othersId: number | undefined;
    others: DynamicPropertyValue;
    businessUnits: BusinessUnitDto[] | undefined;
}

export class BusinessUnitListDto implements IBusinessUnitListDto {
    parentUnit!: number | undefined;
    businessUnitTitle!: string | undefined;
    isAuditableEntity!: boolean;
    lockThreatOrganization!: GetOrganizationForEditDto;
    unitTypeId!: number | undefined;
    unitType!: DynamicPropertyValue;
    isActive!: boolean;
    creationTime!: DateTime;
    businessUnitId!: string | undefined;
    organizationId!: number | undefined;
    organizationUnitId!: number | undefined;
    oraganizationUnitName!: string | undefined;
    empId!: number | undefined;
    employeeName!: string | undefined;
    id!: number;

    constructor(data?: IBusinessUnitListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentUnit = _data["parentUnit"];
            this.businessUnitTitle = _data["businessUnitTitle"];
            this.isAuditableEntity = _data["isAuditableEntity"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationForEditDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.unitTypeId = _data["unitTypeId"];
            this.unitType = _data["unitType"] ? DynamicPropertyValue.fromJS(_data["unitType"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.businessUnitId = _data["businessUnitId"];
            this.organizationId = _data["organizationId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.oraganizationUnitName = _data["oraganizationUnitName"];
            this.empId = _data["empId"];
            this.employeeName = _data["employeeName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessUnitListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUnitListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentUnit"] = this.parentUnit;
        data["businessUnitTitle"] = this.businessUnitTitle;
        data["isAuditableEntity"] = this.isAuditableEntity;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["unitTypeId"] = this.unitTypeId;
        data["unitType"] = this.unitType ? this.unitType.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["businessUnitId"] = this.businessUnitId;
        data["organizationId"] = this.organizationId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["oraganizationUnitName"] = this.oraganizationUnitName;
        data["empId"] = this.empId;
        data["employeeName"] = this.employeeName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusinessUnitListDto {
    parentUnit: number | undefined;
    businessUnitTitle: string | undefined;
    isAuditableEntity: boolean;
    lockThreatOrganization: GetOrganizationForEditDto;
    unitTypeId: number | undefined;
    unitType: DynamicPropertyValue;
    isActive: boolean;
    creationTime: DateTime;
    businessUnitId: string | undefined;
    organizationId: number | undefined;
    organizationUnitId: number | undefined;
    oraganizationUnitName: string | undefined;
    empId: number | undefined;
    employeeName: string | undefined;
    id: number;
}

export class PagedResultDtoOfBusinessUnitListDto implements IPagedResultDtoOfBusinessUnitListDto {
    totalCount!: number;
    items!: BusinessUnitListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessUnitListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessUnitListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessUnitListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessUnitListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBusinessUnitListDto {
    totalCount: number;
    items: BusinessUnitListDto[] | undefined;
}

export class CreateOrUpdateBusinessUnitInput implements ICreateOrUpdateBusinessUnitInput {
    id!: number | undefined;
    tenantId!: number | undefined;
    businessUnitId!: string | undefined;
    lockThreatOrganizationId!: number | undefined;
    businessUnitTitle!: string | undefined;
    isAuditableEntity!: boolean;
    unitTypeId!: number | undefined;
    parentUnit!: number | undefined;
    organizationUnitId!: number | undefined;
    empId!: number | undefined;

    constructor(data?: ICreateOrUpdateBusinessUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.businessUnitId = _data["businessUnitId"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.businessUnitTitle = _data["businessUnitTitle"];
            this.isAuditableEntity = _data["isAuditableEntity"];
            this.unitTypeId = _data["unitTypeId"];
            this.parentUnit = _data["parentUnit"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.empId = _data["empId"];
        }
    }

    static fromJS(data: any): CreateOrUpdateBusinessUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBusinessUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["businessUnitId"] = this.businessUnitId;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["businessUnitTitle"] = this.businessUnitTitle;
        data["isAuditableEntity"] = this.isAuditableEntity;
        data["unitTypeId"] = this.unitTypeId;
        data["parentUnit"] = this.parentUnit;
        data["organizationUnitId"] = this.organizationUnitId;
        data["empId"] = this.empId;
        return data; 
    }
}

export interface ICreateOrUpdateBusinessUnitInput {
    id: number | undefined;
    tenantId: number | undefined;
    businessUnitId: string | undefined;
    lockThreatOrganizationId: number | undefined;
    businessUnitTitle: string | undefined;
    isAuditableEntity: boolean;
    unitTypeId: number | undefined;
    parentUnit: number | undefined;
    organizationUnitId: number | undefined;
    empId: number | undefined;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number;
    displayName!: string;
    parentId!: number | undefined;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["parentId"] = this.parentId;
        return data; 
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;
    parentId: number | undefined;
}

export class GetLockThreatOrganizationDto implements IGetLockThreatOrganizationDto {
    id!: number;
    companyName!: string | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IGetLockThreatOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): GetLockThreatOrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLockThreatOrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IGetLockThreatOrganizationDto {
    id: number;
    companyName: string | undefined;
    organizationUnitId: number | undefined;
}

export class UnitTypeDto implements IUnitTypeDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IUnitTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UnitTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IUnitTypeDto {
    id: number;
    name: string | undefined;
}

export class ParentUnit implements IParentUnit {
    id!: number;
    businessUnitTitle!: string | undefined;

    constructor(data?: IParentUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessUnitTitle = _data["businessUnitTitle"];
        }
    }

    static fromJS(data: any): ParentUnit {
        data = typeof data === 'object' ? data : {};
        let result = new ParentUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessUnitTitle"] = this.businessUnitTitle;
        return data; 
    }
}

export interface IParentUnit {
    id: number;
    businessUnitTitle: string | undefined;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export enum FriendshipState {
    Accepted = 1,
    Blocked = 2,
}

export class FriendDto implements IFriendDto {
    friendUserId!: number;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number;
    isOnline!: boolean;
    state!: FriendshipState;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendUserId = _data["friendUserId"];
            this.friendTenantId = _data["friendTenantId"];
            this.friendUserName = _data["friendUserName"];
            this.friendTenancyName = _data["friendTenancyName"];
            this.friendProfilePictureId = _data["friendProfilePictureId"];
            this.unreadMessageCount = _data["unreadMessageCount"];
            this.isOnline = _data["isOnline"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }
}

export interface IFriendDto {
    friendUserId: number;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendshipState;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: DateTime;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverTime = _data["serverTime"] ? DateTime.fromISO(_data["serverTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["friends"])) {
                this.friends = [] as any;
                for (let item of _data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toString() : <any>undefined;
        if (Array.isArray(this.friends)) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: DateTime;
    friends: FriendDto[] | undefined;
}

export enum ChatSide {
    Sender = 1,
    Receiver = 2,
}

export enum ChatMessageReadState {
    Unread = 1,
    Read = 2,
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number;
    tenantId!: number | undefined;
    targetUserId!: number;
    targetTenantId!: number | undefined;
    side!: ChatSide;
    readState!: ChatMessageReadState;
    receiverReadState!: ChatMessageReadState;
    message!: string | undefined;
    creationTime!: DateTime;
    sharedMessageId!: string | undefined;
    id!: number;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.targetUserId = _data["targetUserId"];
            this.targetTenantId = _data["targetTenantId"];
            this.side = _data["side"];
            this.readState = _data["readState"];
            this.receiverReadState = _data["receiverReadState"];
            this.message = _data["message"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = _data["sharedMessageId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IChatMessageDto {
    userId: number;
    tenantId: number | undefined;
    targetUserId: number;
    targetTenantId: number | undefined;
    side: ChatSide;
    readState: ChatMessageReadState;
    receiverReadState: ChatMessageReadState;
    message: string | undefined;
    creationTime: DateTime;
    sharedMessageId: string | undefined;
    id: number;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isFree = _data["isFree"];
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    excludeCurrentUser!: boolean;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.excludeCurrentUser = _data["excludeCurrentUser"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["excludeCurrentUser"] = this.excludeCurrentUser;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    excludeCurrentUser: boolean;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class VendorsDto implements IVendorsDto {
    id!: number | undefined;
    vendorName!: string | undefined;

    constructor(data?: IVendorsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vendorName = _data["vendorName"];
        }
    }

    static fromJS(data: any): VendorsDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vendorName"] = this.vendorName;
        return data; 
    }
}

export interface IVendorsDto {
    id: number | undefined;
    vendorName: string | undefined;
}

export class ContactInfoDto implements IContactInfoDto {
    tenantId!: number | undefined;
    contactId!: string | undefined;
    contactTypeId!: number | undefined;
    contactTypes!: GetDynamicValueDto[] | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    jobTitle!: string | undefined;
    phoneNumber!: string | undefined;
    mobileNo!: string | undefined;
    email!: string | undefined;
    addressOne!: string | undefined;
    addressTwo!: string | undefined;
    state!: string | undefined;
    city!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number | undefined;
    countries!: CountryDto[] | undefined;
    loginUserId!: number | undefined;
    employeesList!: BusinessServiceOwner[] | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    vendorId!: number | undefined;
    vendors!: VendorsDto[] | undefined;
    profilePicture!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.contactId = _data["contactId"];
            this.contactTypeId = _data["contactTypeId"];
            if (Array.isArray(_data["contactTypes"])) {
                this.contactTypes = [] as any;
                for (let item of _data["contactTypes"])
                    this.contactTypes!.push(GetDynamicValueDto.fromJS(item));
            }
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.jobTitle = _data["jobTitle"];
            this.phoneNumber = _data["phoneNumber"];
            this.mobileNo = _data["mobileNo"];
            this.email = _data["email"];
            this.addressOne = _data["addressOne"];
            this.addressTwo = _data["addressTwo"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(CountryDto.fromJS(item));
            }
            this.loginUserId = _data["loginUserId"];
            if (Array.isArray(_data["employeesList"])) {
                this.employeesList = [] as any;
                for (let item of _data["employeesList"])
                    this.employeesList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            this.vendorId = _data["vendorId"];
            if (Array.isArray(_data["vendors"])) {
                this.vendors = [] as any;
                for (let item of _data["vendors"])
                    this.vendors!.push(VendorsDto.fromJS(item));
            }
            this.profilePicture = _data["profilePicture"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["contactTypeId"] = this.contactTypeId;
        if (Array.isArray(this.contactTypes)) {
            data["contactTypes"] = [];
            for (let item of this.contactTypes)
                data["contactTypes"].push(item.toJSON());
        }
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["jobTitle"] = this.jobTitle;
        data["phoneNumber"] = this.phoneNumber;
        data["mobileNo"] = this.mobileNo;
        data["email"] = this.email;
        data["addressOne"] = this.addressOne;
        data["addressTwo"] = this.addressTwo;
        data["state"] = this.state;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        data["loginUserId"] = this.loginUserId;
        if (Array.isArray(this.employeesList)) {
            data["employeesList"] = [];
            for (let item of this.employeesList)
                data["employeesList"].push(item.toJSON());
        }
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        data["vendorId"] = this.vendorId;
        if (Array.isArray(this.vendors)) {
            data["vendors"] = [];
            for (let item of this.vendors)
                data["vendors"].push(item.toJSON());
        }
        data["profilePicture"] = this.profilePicture;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactInfoDto {
    tenantId: number | undefined;
    contactId: string | undefined;
    contactTypeId: number | undefined;
    contactTypes: GetDynamicValueDto[] | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    jobTitle: string | undefined;
    phoneNumber: string | undefined;
    mobileNo: string | undefined;
    email: string | undefined;
    addressOne: string | undefined;
    addressTwo: string | undefined;
    state: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    countryId: number | undefined;
    countries: CountryDto[] | undefined;
    loginUserId: number | undefined;
    employeesList: BusinessServiceOwner[] | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    vendorId: number | undefined;
    vendors: VendorsDto[] | undefined;
    profilePicture: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ContactListViewDto implements IContactListViewDto {
    tenantId!: number | undefined;
    contactId!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    jobTitle!: string | undefined;
    phoneNumber!: string | undefined;
    mobileNo!: string | undefined;
    email!: string | undefined;
    addressOne!: string | undefined;
    addressTwo!: string | undefined;
    state!: string | undefined;
    city!: string | undefined;
    postalCode!: string | undefined;
    profilePicture!: string | undefined;
    contactType!: string | undefined;
    country!: string | undefined;
    loginUser!: string | undefined;
    lockThreatOrganization!: string | undefined;
    vendor!: string | undefined;
    id!: number;

    constructor(data?: IContactListViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.contactId = _data["contactId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.jobTitle = _data["jobTitle"];
            this.phoneNumber = _data["phoneNumber"];
            this.mobileNo = _data["mobileNo"];
            this.email = _data["email"];
            this.addressOne = _data["addressOne"];
            this.addressTwo = _data["addressTwo"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.profilePicture = _data["profilePicture"];
            this.contactType = _data["contactType"];
            this.country = _data["country"];
            this.loginUser = _data["loginUser"];
            this.lockThreatOrganization = _data["lockThreatOrganization"];
            this.vendor = _data["vendor"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContactListViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["jobTitle"] = this.jobTitle;
        data["phoneNumber"] = this.phoneNumber;
        data["mobileNo"] = this.mobileNo;
        data["email"] = this.email;
        data["addressOne"] = this.addressOne;
        data["addressTwo"] = this.addressTwo;
        data["state"] = this.state;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["profilePicture"] = this.profilePicture;
        data["contactType"] = this.contactType;
        data["country"] = this.country;
        data["loginUser"] = this.loginUser;
        data["lockThreatOrganization"] = this.lockThreatOrganization;
        data["vendor"] = this.vendor;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactListViewDto {
    tenantId: number | undefined;
    contactId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    jobTitle: string | undefined;
    phoneNumber: string | undefined;
    mobileNo: string | undefined;
    email: string | undefined;
    addressOne: string | undefined;
    addressTwo: string | undefined;
    state: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    profilePicture: string | undefined;
    contactType: string | undefined;
    country: string | undefined;
    loginUser: string | undefined;
    lockThreatOrganization: string | undefined;
    vendor: string | undefined;
    id: number;
}

export class PagedResultDtoOfContactListViewDto implements IPagedResultDtoOfContactListViewDto {
    totalCount!: number;
    items!: ContactListViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactListViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContactListViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactListViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactListViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfContactListViewDto {
    totalCount: number;
    items: ContactListViewDto[] | undefined;
}

export class ContractBusinessProcessDto implements IContractBusinessProcessDto {
    id!: number;
    contractId!: number | undefined;
    businessProcessId!: number | undefined;

    constructor(data?: IContractBusinessProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractId = _data["contractId"];
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static fromJS(data: any): ContractBusinessProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractBusinessProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractId"] = this.contractId;
        data["businessProcessId"] = this.businessProcessId;
        return data; 
    }
}

export interface IContractBusinessProcessDto {
    id: number;
    contractId: number | undefined;
    businessProcessId: number | undefined;
}

export class ContractBusinessServiceDto implements IContractBusinessServiceDto {
    id!: number;
    contractId!: number | undefined;
    businessServiceId!: number | undefined;

    constructor(data?: IContractBusinessServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractId = _data["contractId"];
            this.businessServiceId = _data["businessServiceId"];
        }
    }

    static fromJS(data: any): ContractBusinessServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractBusinessServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractId"] = this.contractId;
        data["businessServiceId"] = this.businessServiceId;
        return data; 
    }
}

export interface IContractBusinessServiceDto {
    id: number;
    contractId: number | undefined;
    businessServiceId: number | undefined;
}

export class ContractEmployeeDto implements IContractEmployeeDto {
    id!: number;
    contractId!: number | undefined;
    employeeId!: number | undefined;

    constructor(data?: IContractEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractId = _data["contractId"];
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): ContractEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractId"] = this.contractId;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface IContractEmployeeDto {
    id: number;
    contractId: number | undefined;
    employeeId: number | undefined;
}

export class ContractEmployeeNotificationDto implements IContractEmployeeNotificationDto {
    id!: number;
    contractId!: number | undefined;
    employeeId!: number | undefined;

    constructor(data?: IContractEmployeeNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractId = _data["contractId"];
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): ContractEmployeeNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractEmployeeNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractId"] = this.contractId;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface IContractEmployeeNotificationDto {
    id: number;
    contractId: number | undefined;
    employeeId: number | undefined;
}

export class ContractITServiceDto implements IContractITServiceDto {
    id!: number;
    contractId!: number | undefined;
    itServiceId!: number | undefined;

    constructor(data?: IContractITServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractId = _data["contractId"];
            this.itServiceId = _data["itServiceId"];
        }
    }

    static fromJS(data: any): ContractITServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractITServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractId"] = this.contractId;
        data["itServiceId"] = this.itServiceId;
        return data; 
    }
}

export interface IContractITServiceDto {
    id: number;
    contractId: number | undefined;
    itServiceId: number | undefined;
}

export class ContractRiskTreatmentDto implements IContractRiskTreatmentDto {
    id!: number;
    contractId!: number | undefined;
    riskTreatmentId!: number | undefined;

    constructor(data?: IContractRiskTreatmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractId = _data["contractId"];
            this.riskTreatmentId = _data["riskTreatmentId"];
        }
    }

    static fromJS(data: any): ContractRiskTreatmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractRiskTreatmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractId"] = this.contractId;
        data["riskTreatmentId"] = this.riskTreatmentId;
        return data; 
    }
}

export interface IContractRiskTreatmentDto {
    id: number;
    contractId: number | undefined;
    riskTreatmentId: number | undefined;
}

export class ContractDto implements IContractDto {
    tenantId!: number | undefined;
    contractId!: string | undefined;
    contractTitle!: string | undefined;
    contractReference!: string | undefined;
    description!: string | undefined;
    contractValue!: number | undefined;
    contractTypeId!: number | undefined;
    contractTypes!: GetDynamicValueDto[] | undefined;
    contractCategoryId!: number | undefined;
    contractCategorys!: GetDynamicValueDto[] | undefined;
    vendorId!: number | undefined;
    vendors!: VendorsDto[] | undefined;
    startDate!: DateTime | undefined;
    endDate!: DateTime | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    employeeId!: number | undefined;
    employeesList!: BusinessServiceOwner[] | undefined;
    iTserviceLists!: ITserviceListDto[] | undefined;
    businessServices!: BusinessServiceSDto[] | undefined;
    businessProcess!: BusinessProcessDetailDto[] | undefined;
    selectedContractBusinessProcess!: ContractBusinessProcessDto[] | undefined;
    selectedContractBusinessService!: ContractBusinessServiceDto[] | undefined;
    selectedContractEmployee!: ContractEmployeeDto[] | undefined;
    selectedContractEmployeeNotification!: ContractEmployeeNotificationDto[] | undefined;
    selectedContractITService!: ContractITServiceDto[] | undefined;
    selectedContractRiskTreatment!: ContractRiskTreatmentDto[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.contractId = _data["contractId"];
            this.contractTitle = _data["contractTitle"];
            this.contractReference = _data["contractReference"];
            this.description = _data["description"];
            this.contractValue = _data["contractValue"];
            this.contractTypeId = _data["contractTypeId"];
            if (Array.isArray(_data["contractTypes"])) {
                this.contractTypes = [] as any;
                for (let item of _data["contractTypes"])
                    this.contractTypes!.push(GetDynamicValueDto.fromJS(item));
            }
            this.contractCategoryId = _data["contractCategoryId"];
            if (Array.isArray(_data["contractCategorys"])) {
                this.contractCategorys = [] as any;
                for (let item of _data["contractCategorys"])
                    this.contractCategorys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.vendorId = _data["vendorId"];
            if (Array.isArray(_data["vendors"])) {
                this.vendors = [] as any;
                for (let item of _data["vendors"])
                    this.vendors!.push(VendorsDto.fromJS(item));
            }
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["employeesList"])) {
                this.employeesList = [] as any;
                for (let item of _data["employeesList"])
                    this.employeesList!.push(BusinessServiceOwner.fromJS(item));
            }
            if (Array.isArray(_data["iTserviceLists"])) {
                this.iTserviceLists = [] as any;
                for (let item of _data["iTserviceLists"])
                    this.iTserviceLists!.push(ITserviceListDto.fromJS(item));
            }
            if (Array.isArray(_data["businessServices"])) {
                this.businessServices = [] as any;
                for (let item of _data["businessServices"])
                    this.businessServices!.push(BusinessServiceSDto.fromJS(item));
            }
            if (Array.isArray(_data["businessProcess"])) {
                this.businessProcess = [] as any;
                for (let item of _data["businessProcess"])
                    this.businessProcess!.push(BusinessProcessDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedContractBusinessProcess"])) {
                this.selectedContractBusinessProcess = [] as any;
                for (let item of _data["selectedContractBusinessProcess"])
                    this.selectedContractBusinessProcess!.push(ContractBusinessProcessDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedContractBusinessService"])) {
                this.selectedContractBusinessService = [] as any;
                for (let item of _data["selectedContractBusinessService"])
                    this.selectedContractBusinessService!.push(ContractBusinessServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedContractEmployee"])) {
                this.selectedContractEmployee = [] as any;
                for (let item of _data["selectedContractEmployee"])
                    this.selectedContractEmployee!.push(ContractEmployeeDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedContractEmployeeNotification"])) {
                this.selectedContractEmployeeNotification = [] as any;
                for (let item of _data["selectedContractEmployeeNotification"])
                    this.selectedContractEmployeeNotification!.push(ContractEmployeeNotificationDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedContractITService"])) {
                this.selectedContractITService = [] as any;
                for (let item of _data["selectedContractITService"])
                    this.selectedContractITService!.push(ContractITServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedContractRiskTreatment"])) {
                this.selectedContractRiskTreatment = [] as any;
                for (let item of _data["selectedContractRiskTreatment"])
                    this.selectedContractRiskTreatment!.push(ContractRiskTreatmentDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contractId"] = this.contractId;
        data["contractTitle"] = this.contractTitle;
        data["contractReference"] = this.contractReference;
        data["description"] = this.description;
        data["contractValue"] = this.contractValue;
        data["contractTypeId"] = this.contractTypeId;
        if (Array.isArray(this.contractTypes)) {
            data["contractTypes"] = [];
            for (let item of this.contractTypes)
                data["contractTypes"].push(item.toJSON());
        }
        data["contractCategoryId"] = this.contractCategoryId;
        if (Array.isArray(this.contractCategorys)) {
            data["contractCategorys"] = [];
            for (let item of this.contractCategorys)
                data["contractCategorys"].push(item.toJSON());
        }
        data["vendorId"] = this.vendorId;
        if (Array.isArray(this.vendors)) {
            data["vendors"] = [];
            for (let item of this.vendors)
                data["vendors"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.employeesList)) {
            data["employeesList"] = [];
            for (let item of this.employeesList)
                data["employeesList"].push(item.toJSON());
        }
        if (Array.isArray(this.iTserviceLists)) {
            data["iTserviceLists"] = [];
            for (let item of this.iTserviceLists)
                data["iTserviceLists"].push(item.toJSON());
        }
        if (Array.isArray(this.businessServices)) {
            data["businessServices"] = [];
            for (let item of this.businessServices)
                data["businessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.businessProcess)) {
            data["businessProcess"] = [];
            for (let item of this.businessProcess)
                data["businessProcess"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedContractBusinessProcess)) {
            data["selectedContractBusinessProcess"] = [];
            for (let item of this.selectedContractBusinessProcess)
                data["selectedContractBusinessProcess"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedContractBusinessService)) {
            data["selectedContractBusinessService"] = [];
            for (let item of this.selectedContractBusinessService)
                data["selectedContractBusinessService"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedContractEmployee)) {
            data["selectedContractEmployee"] = [];
            for (let item of this.selectedContractEmployee)
                data["selectedContractEmployee"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedContractEmployeeNotification)) {
            data["selectedContractEmployeeNotification"] = [];
            for (let item of this.selectedContractEmployeeNotification)
                data["selectedContractEmployeeNotification"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedContractITService)) {
            data["selectedContractITService"] = [];
            for (let item of this.selectedContractITService)
                data["selectedContractITService"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedContractRiskTreatment)) {
            data["selectedContractRiskTreatment"] = [];
            for (let item of this.selectedContractRiskTreatment)
                data["selectedContractRiskTreatment"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContractDto {
    tenantId: number | undefined;
    contractId: string | undefined;
    contractTitle: string | undefined;
    contractReference: string | undefined;
    description: string | undefined;
    contractValue: number | undefined;
    contractTypeId: number | undefined;
    contractTypes: GetDynamicValueDto[] | undefined;
    contractCategoryId: number | undefined;
    contractCategorys: GetDynamicValueDto[] | undefined;
    vendorId: number | undefined;
    vendors: VendorsDto[] | undefined;
    startDate: DateTime | undefined;
    endDate: DateTime | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    employeeId: number | undefined;
    employeesList: BusinessServiceOwner[] | undefined;
    iTserviceLists: ITserviceListDto[] | undefined;
    businessServices: BusinessServiceSDto[] | undefined;
    businessProcess: BusinessProcessDetailDto[] | undefined;
    selectedContractBusinessProcess: ContractBusinessProcessDto[] | undefined;
    selectedContractBusinessService: ContractBusinessServiceDto[] | undefined;
    selectedContractEmployee: ContractEmployeeDto[] | undefined;
    selectedContractEmployeeNotification: ContractEmployeeNotificationDto[] | undefined;
    selectedContractITService: ContractITServiceDto[] | undefined;
    selectedContractRiskTreatment: ContractRiskTreatmentDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ContractListDto implements IContractListDto {
    tenantId!: number | undefined;
    contractId!: string | undefined;
    contractTitle!: string | undefined;
    contractReference!: string | undefined;
    description!: string | undefined;
    contractValue!: number | undefined;
    startDate!: DateTime | undefined;
    endDate!: DateTime | undefined;
    contractType!: string | undefined;
    contractCategory!: string | undefined;
    vendor!: string | undefined;
    lockThreatOrganization!: string | undefined;
    employee!: string | undefined;
    id!: number;

    constructor(data?: IContractListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.contractId = _data["contractId"];
            this.contractTitle = _data["contractTitle"];
            this.contractReference = _data["contractReference"];
            this.description = _data["description"];
            this.contractValue = _data["contractValue"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
            this.contractType = _data["contractType"];
            this.contractCategory = _data["contractCategory"];
            this.vendor = _data["vendor"];
            this.lockThreatOrganization = _data["lockThreatOrganization"];
            this.employee = _data["employee"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contractId"] = this.contractId;
        data["contractTitle"] = this.contractTitle;
        data["contractReference"] = this.contractReference;
        data["description"] = this.description;
        data["contractValue"] = this.contractValue;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        data["contractType"] = this.contractType;
        data["contractCategory"] = this.contractCategory;
        data["vendor"] = this.vendor;
        data["lockThreatOrganization"] = this.lockThreatOrganization;
        data["employee"] = this.employee;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContractListDto {
    tenantId: number | undefined;
    contractId: string | undefined;
    contractTitle: string | undefined;
    contractReference: string | undefined;
    description: string | undefined;
    contractValue: number | undefined;
    startDate: DateTime | undefined;
    endDate: DateTime | undefined;
    contractType: string | undefined;
    contractCategory: string | undefined;
    vendor: string | undefined;
    lockThreatOrganization: string | undefined;
    employee: string | undefined;
    id: number;
}

export class PagedResultDtoOfContractListDto implements IPagedResultDtoOfContractListDto {
    totalCount!: number;
    items!: ContractListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContractListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContractListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContractListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContractListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfContractListDto {
    totalCount: number;
    items: ContractListDto[] | undefined;
}

export class DynamicNameValueDto implements IDynamicNameValueDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IDynamicNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DynamicNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IDynamicNameValueDto {
    id: number;
    name: string | undefined;
}

export class FacilitieIdDto implements IFacilitieIdDto {
    id!: number;

    constructor(data?: IFacilitieIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FacilitieIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new FacilitieIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IFacilitieIdDto {
    id: number;
}

export class Widget implements IWidget {
    widgetId!: string | undefined;
    height!: number;
    width!: number;
    positionX!: number;
    positionY!: number;

    constructor(data?: IWidget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetId = _data["widgetId"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
        }
    }

    static fromJS(data: any): Widget {
        data = typeof data === 'object' ? data : {};
        let result = new Widget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["height"] = this.height;
        data["width"] = this.width;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        return data; 
    }
}

export interface IWidget {
    widgetId: string | undefined;
    height: number;
    width: number;
    positionX: number;
    positionY: number;
}

export class Page implements IPage {
    id!: string | undefined;
    name!: string | undefined;
    widgets!: Widget[] | undefined;

    constructor(data?: IPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(Widget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Page {
        data = typeof data === 'object' ? data : {};
        let result = new Page();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPage {
    id: string | undefined;
    name: string | undefined;
    widgets: Widget[] | undefined;
}

export class Dashboard implements IDashboard {
    dashboardName!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: IDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dashboard {
        data = typeof data === 'object' ? data : {};
        let result = new Dashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDashboard {
    dashboardName: string | undefined;
    pages: Page[] | undefined;
}

export class SavePageInput implements ISavePageInput {
    dashboardName!: string | undefined;
    application!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: ISavePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.application = _data["application"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SavePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SavePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["application"] = this.application;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISavePageInput {
    dashboardName: string | undefined;
    application: string | undefined;
    pages: Page[] | undefined;
}

export class RenamePageInput implements IRenamePageInput {
    dashboardName!: string | undefined;
    id!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    constructor(data?: IRenamePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): RenamePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenamePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["id"] = this.id;
        data["name"] = this.name;
        data["application"] = this.application;
        return data; 
    }
}

export interface IRenamePageInput {
    dashboardName: string | undefined;
    id: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class AddNewPageInput implements IAddNewPageInput {
    dashboardName!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    constructor(data?: IAddNewPageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddNewPageInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["name"] = this.name;
        data["application"] = this.application;
        return data; 
    }
}

export interface IAddNewPageInput {
    dashboardName: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class AddNewPageOutput implements IAddNewPageOutput {
    pageId!: string | undefined;

    constructor(data?: IAddNewPageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageId = _data["pageId"];
        }
    }

    static fromJS(data: any): AddNewPageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageId"] = this.pageId;
        return data; 
    }
}

export interface IAddNewPageOutput {
    pageId: string | undefined;
}

export class AddWidgetInput implements IAddWidgetInput {
    widgetId!: string | undefined;
    pageId!: string | undefined;
    dashboardName!: string | undefined;
    width!: number;
    height!: number;
    application!: string | undefined;

    constructor(data?: IAddWidgetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetId = _data["widgetId"];
            this.pageId = _data["pageId"];
            this.dashboardName = _data["dashboardName"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddWidgetInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddWidgetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["pageId"] = this.pageId;
        data["dashboardName"] = this.dashboardName;
        data["width"] = this.width;
        data["height"] = this.height;
        data["application"] = this.application;
        return data; 
    }
}

export interface IAddWidgetInput {
    widgetId: string | undefined;
    pageId: string | undefined;
    dashboardName: string | undefined;
    width: number;
    height: number;
    application: string | undefined;
}

export class WidgetFilterOutput implements IWidgetFilterOutput {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IWidgetFilterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WidgetFilterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetFilterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IWidgetFilterOutput {
    id: string | undefined;
    name: string | undefined;
}

export class WidgetOutput implements IWidgetOutput {
    id!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    filters!: WidgetFilterOutput[] | undefined;

    constructor(data?: IWidgetOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(WidgetFilterOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WidgetOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWidgetOutput {
    id: string | undefined;
    name: string | undefined;
    description: string | undefined;
    filters: WidgetFilterOutput[] | undefined;
}

export class DashboardOutput implements IDashboardOutput {
    name!: string | undefined;
    widgets!: WidgetOutput[] | undefined;

    constructor(data?: IDashboardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(WidgetOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDashboardOutput {
    name: string | undefined;
    widgets: WidgetOutput[] | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString!: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateString = _data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class DynamicEntityPropertyDto implements IDynamicEntityPropertyDto {
    entityFullName!: string | undefined;
    dynamicPropertyName!: string | undefined;
    dynamicPropertyId!: number;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IDynamicEntityPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityFullName = _data["entityFullName"];
            this.dynamicPropertyName = _data["dynamicPropertyName"];
            this.dynamicPropertyId = _data["dynamicPropertyId"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicEntityPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicEntityPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityFullName"] = this.entityFullName;
        data["dynamicPropertyName"] = this.dynamicPropertyName;
        data["dynamicPropertyId"] = this.dynamicPropertyId;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicEntityPropertyDto {
    entityFullName: string | undefined;
    dynamicPropertyName: string | undefined;
    dynamicPropertyId: number;
    tenantId: number | undefined;
    id: number;
}

export class ListResultDtoOfDynamicEntityPropertyDto implements IListResultDtoOfDynamicEntityPropertyDto {
    items!: DynamicEntityPropertyDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicEntityPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicEntityPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicEntityPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicEntityPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfDynamicEntityPropertyDto {
    items: DynamicEntityPropertyDto[] | undefined;
}

export class GetAllEntitiesHasDynamicPropertyOutput implements IGetAllEntitiesHasDynamicPropertyOutput {
    entityFullName!: string | undefined;

    constructor(data?: IGetAllEntitiesHasDynamicPropertyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityFullName = _data["entityFullName"];
        }
    }

    static fromJS(data: any): GetAllEntitiesHasDynamicPropertyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllEntitiesHasDynamicPropertyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityFullName"] = this.entityFullName;
        return data; 
    }
}

export interface IGetAllEntitiesHasDynamicPropertyOutput {
    entityFullName: string | undefined;
}

export class ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput implements IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
    items!: GetAllEntitiesHasDynamicPropertyOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllEntitiesHasDynamicPropertyOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
    items: GetAllEntitiesHasDynamicPropertyOutput[] | undefined;
}

export class DynamicEntityPropertyValueDto implements IDynamicEntityPropertyValueDto {
    value!: string | undefined;
    entityId!: string | undefined;
    dynamicEntityPropertyId!: number;
    id!: number;

    constructor(data?: IDynamicEntityPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.entityId = _data["entityId"];
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicEntityPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicEntityPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["entityId"] = this.entityId;
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicEntityPropertyValueDto {
    value: string | undefined;
    entityId: string | undefined;
    dynamicEntityPropertyId: number;
    id: number;
}

export class ListResultDtoOfDynamicEntityPropertyValueDto implements IListResultDtoOfDynamicEntityPropertyValueDto {
    items!: DynamicEntityPropertyValueDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicEntityPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicEntityPropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicEntityPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicEntityPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfDynamicEntityPropertyValueDto {
    items: DynamicEntityPropertyValueDto[] | undefined;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = _data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
}

export class IInputType implements IIInputType {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
}

export class GetAllDynamicEntityPropertyValuesOutputItem implements IGetAllDynamicEntityPropertyValuesOutputItem {
    dynamicEntityPropertyId!: number;
    propertyName!: string | undefined;
    inputType!: IInputType;
    selectedValues!: string[] | undefined;
    allValuesInputTypeHas!: string[] | undefined;

    constructor(data?: IGetAllDynamicEntityPropertyValuesOutputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.propertyName = _data["propertyName"];
            this.inputType = _data["inputType"] ? IInputType.fromJS(_data["inputType"]) : <any>undefined;
            if (Array.isArray(_data["selectedValues"])) {
                this.selectedValues = [] as any;
                for (let item of _data["selectedValues"])
                    this.selectedValues!.push(item);
            }
            if (Array.isArray(_data["allValuesInputTypeHas"])) {
                this.allValuesInputTypeHas = [] as any;
                for (let item of _data["allValuesInputTypeHas"])
                    this.allValuesInputTypeHas!.push(item);
            }
        }
    }

    static fromJS(data: any): GetAllDynamicEntityPropertyValuesOutputItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDynamicEntityPropertyValuesOutputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["propertyName"] = this.propertyName;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        if (Array.isArray(this.selectedValues)) {
            data["selectedValues"] = [];
            for (let item of this.selectedValues)
                data["selectedValues"].push(item);
        }
        if (Array.isArray(this.allValuesInputTypeHas)) {
            data["allValuesInputTypeHas"] = [];
            for (let item of this.allValuesInputTypeHas)
                data["allValuesInputTypeHas"].push(item);
        }
        return data; 
    }
}

export interface IGetAllDynamicEntityPropertyValuesOutputItem {
    dynamicEntityPropertyId: number;
    propertyName: string | undefined;
    inputType: IInputType;
    selectedValues: string[] | undefined;
    allValuesInputTypeHas: string[] | undefined;
}

export class GetAllDynamicEntityPropertyValuesOutput implements IGetAllDynamicEntityPropertyValuesOutput {
    items!: GetAllDynamicEntityPropertyValuesOutputItem[] | undefined;

    constructor(data?: IGetAllDynamicEntityPropertyValuesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllDynamicEntityPropertyValuesOutputItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllDynamicEntityPropertyValuesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDynamicEntityPropertyValuesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAllDynamicEntityPropertyValuesOutput {
    items: GetAllDynamicEntityPropertyValuesOutputItem[] | undefined;
}

export class InsertOrUpdateAllValuesInputItem implements IInsertOrUpdateAllValuesInputItem {
    entityId!: string | undefined;
    dynamicEntityPropertyId!: number;
    values!: string[] | undefined;

    constructor(data?: IInsertOrUpdateAllValuesInputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): InsertOrUpdateAllValuesInputItem {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOrUpdateAllValuesInputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data; 
    }
}

export interface IInsertOrUpdateAllValuesInputItem {
    entityId: string | undefined;
    dynamicEntityPropertyId: number;
    values: string[] | undefined;
}

export class InsertOrUpdateAllValuesInput implements IInsertOrUpdateAllValuesInput {
    items!: InsertOrUpdateAllValuesInputItem[] | undefined;

    constructor(data?: IInsertOrUpdateAllValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InsertOrUpdateAllValuesInputItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InsertOrUpdateAllValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOrUpdateAllValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInsertOrUpdateAllValuesInput {
    items: InsertOrUpdateAllValuesInputItem[] | undefined;
}

export class CleanValuesInput implements ICleanValuesInput {
    dynamicEntityPropertyId!: number;
    entityId!: string | undefined;

    constructor(data?: ICleanValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.entityId = _data["entityId"];
        }
    }

    static fromJS(data: any): CleanValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CleanValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["entityId"] = this.entityId;
        return data; 
    }
}

export interface ICleanValuesInput {
    dynamicEntityPropertyId: number;
    entityId: string | undefined;
}

export class DynamicPropertyDto implements IDynamicPropertyDto {
    propertyName!: string | undefined;
    displayName!: string | undefined;
    inputType!: string | undefined;
    permission!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IDynamicPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.displayName = _data["displayName"];
            this.inputType = _data["inputType"];
            this.permission = _data["permission"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["displayName"] = this.displayName;
        data["inputType"] = this.inputType;
        data["permission"] = this.permission;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicPropertyDto {
    propertyName: string | undefined;
    displayName: string | undefined;
    inputType: string | undefined;
    permission: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class ListResultDtoOfDynamicPropertyDto implements IListResultDtoOfDynamicPropertyDto {
    items!: DynamicPropertyDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfDynamicPropertyDto {
    items: DynamicPropertyDto[] | undefined;
}

export class DynamicPropertyValueDto implements IDynamicPropertyValueDto {
    value!: string | undefined;
    tenantId!: number | undefined;
    dynamicPropertyId!: number;
    id!: number;

    constructor(data?: IDynamicPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.dynamicPropertyId = _data["dynamicPropertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["dynamicPropertyId"] = this.dynamicPropertyId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicPropertyValueDto {
    value: string | undefined;
    tenantId: number | undefined;
    dynamicPropertyId: number;
    id: number;
}

export class ListResultDtoOfDynamicPropertyValueDto implements IListResultDtoOfDynamicPropertyValueDto {
    items!: DynamicPropertyValueDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicPropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfDynamicPropertyValueDto {
    items: DynamicPropertyValueDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    expiringEditionDisplayName!: string | undefined;
    id!: number;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.trialDayCount = _data["trialDayCount"];
            this.expiringEditionDisplayName = _data["expiringEditionDisplayName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;
    itemSource!: LocalizableComboboxItemSourceDto;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        this.attributes![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
            this.itemSource = _data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(_data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? FeatureInputTypeDto.fromJS(_data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionCreateDto.fromJS(_data["edition"]) : new EditionCreateDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : new EditionEditDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId!: number;
    targetEditionId!: number;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceEditionId = _data["sourceEditionId"];
            this.targetEditionId = _data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data; 
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number;
    targetEditionId: number;
}

export class EmployeeListDto implements IEmployeeListDto {
    employeeId!: string | undefined;
    dateOfBirth!: DateTime;
    name!: string | undefined;
    email!: string | undefined;
    cellPhone!: string | undefined;
    directPhone!: string | undefined;
    age!: number | undefined;
    profilePicture!: string | undefined;
    isNotifiedByEmail!: boolean;
    employeeGradeId!: number | undefined;
    employeeGrade!: DynamicPropertyValue;
    employeeTypeId!: number | undefined;
    employeeType!: DynamicPropertyValue;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationForEditDto;
    businessUnitId!: number | undefined;
    businessUnit!: GetBusinessUnitForEditDto;
    riskGroupId!: number | undefined;
    riskGroup!: DynamicPropertyValue;
    employeePosition!: string | undefined;
    userId!: number | undefined;
    user!: UserEditDto;
    accessCardId!: string | undefined;
    companyId!: string | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IEmployeeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.email = _data["email"];
            this.cellPhone = _data["cellPhone"];
            this.directPhone = _data["directPhone"];
            this.age = _data["age"];
            this.profilePicture = _data["profilePicture"];
            this.isNotifiedByEmail = _data["isNotifiedByEmail"];
            this.employeeGradeId = _data["employeeGradeId"];
            this.employeeGrade = _data["employeeGrade"] ? DynamicPropertyValue.fromJS(_data["employeeGrade"]) : <any>undefined;
            this.employeeTypeId = _data["employeeTypeId"];
            this.employeeType = _data["employeeType"] ? DynamicPropertyValue.fromJS(_data["employeeType"]) : <any>undefined;
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationForEditDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.businessUnitId = _data["businessUnitId"];
            this.businessUnit = _data["businessUnit"] ? GetBusinessUnitForEditDto.fromJS(_data["businessUnit"]) : <any>undefined;
            this.riskGroupId = _data["riskGroupId"];
            this.riskGroup = _data["riskGroup"] ? DynamicPropertyValue.fromJS(_data["riskGroup"]) : <any>undefined;
            this.employeePosition = _data["employeePosition"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : <any>undefined;
            this.accessCardId = _data["accessCardId"];
            this.companyId = _data["companyId"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EmployeeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : <any>undefined;
        data["name"] = this.name;
        data["email"] = this.email;
        data["cellPhone"] = this.cellPhone;
        data["directPhone"] = this.directPhone;
        data["age"] = this.age;
        data["profilePicture"] = this.profilePicture;
        data["isNotifiedByEmail"] = this.isNotifiedByEmail;
        data["employeeGradeId"] = this.employeeGradeId;
        data["employeeGrade"] = this.employeeGrade ? this.employeeGrade.toJSON() : <any>undefined;
        data["employeeTypeId"] = this.employeeTypeId;
        data["employeeType"] = this.employeeType ? this.employeeType.toJSON() : <any>undefined;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["businessUnitId"] = this.businessUnitId;
        data["businessUnit"] = this.businessUnit ? this.businessUnit.toJSON() : <any>undefined;
        data["riskGroupId"] = this.riskGroupId;
        data["riskGroup"] = this.riskGroup ? this.riskGroup.toJSON() : <any>undefined;
        data["employeePosition"] = this.employeePosition;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["accessCardId"] = this.accessCardId;
        data["companyId"] = this.companyId;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEmployeeListDto {
    employeeId: string | undefined;
    dateOfBirth: DateTime;
    name: string | undefined;
    email: string | undefined;
    cellPhone: string | undefined;
    directPhone: string | undefined;
    age: number | undefined;
    profilePicture: string | undefined;
    isNotifiedByEmail: boolean;
    employeeGradeId: number | undefined;
    employeeGrade: DynamicPropertyValue;
    employeeTypeId: number | undefined;
    employeeType: DynamicPropertyValue;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationForEditDto;
    businessUnitId: number | undefined;
    businessUnit: GetBusinessUnitForEditDto;
    riskGroupId: number | undefined;
    riskGroup: DynamicPropertyValue;
    employeePosition: string | undefined;
    userId: number | undefined;
    user: UserEditDto;
    accessCardId: string | undefined;
    companyId: string | undefined;
    isActive: boolean;
    creationTime: DateTime;
    id: number;
}

export class PagedResultDtoOfEmployeeListDto implements IPagedResultDtoOfEmployeeListDto {
    totalCount!: number;
    items!: EmployeeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEmployeeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EmployeeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEmployeeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEmployeeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEmployeeListDto {
    totalCount: number;
    items: EmployeeListDto[] | undefined;
}

export class CreateOrUpdateEmployeesInput implements ICreateOrUpdateEmployeesInput {
    id!: number | undefined;
    tenantId!: number | undefined;
    employeeId!: string | undefined;
    dateOfBirth!: DateTime;
    name!: string | undefined;
    surname!: string | undefined;
    password!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    directPhone!: string | undefined;
    age!: number | undefined;
    profilePicture!: string | undefined;
    isNotifiedByEmail!: boolean;
    employeeGradeId!: number | undefined;
    employeeTypeId!: number | undefined;
    lockThreatOrganizationId!: number | undefined;
    businessUnitId!: number | undefined;
    employeePosition!: string | undefined;
    userId!: number | undefined;
    accessCardId!: string | undefined;
    companyId!: string | undefined;
    riskGroupId!: number | undefined;
    isActive!: boolean;

    constructor(data?: ICreateOrUpdateEmployeesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.employeeId = _data["employeeId"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.password = _data["password"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.directPhone = _data["directPhone"];
            this.age = _data["age"];
            this.profilePicture = _data["profilePicture"];
            this.isNotifiedByEmail = _data["isNotifiedByEmail"];
            this.employeeGradeId = _data["employeeGradeId"];
            this.employeeTypeId = _data["employeeTypeId"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.businessUnitId = _data["businessUnitId"];
            this.employeePosition = _data["employeePosition"];
            this.userId = _data["userId"];
            this.accessCardId = _data["accessCardId"];
            this.companyId = _data["companyId"];
            this.riskGroupId = _data["riskGroupId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrUpdateEmployeesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEmployeesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["employeeId"] = this.employeeId;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : <any>undefined;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["password"] = this.password;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["directPhone"] = this.directPhone;
        data["age"] = this.age;
        data["profilePicture"] = this.profilePicture;
        data["isNotifiedByEmail"] = this.isNotifiedByEmail;
        data["employeeGradeId"] = this.employeeGradeId;
        data["employeeTypeId"] = this.employeeTypeId;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["businessUnitId"] = this.businessUnitId;
        data["employeePosition"] = this.employeePosition;
        data["userId"] = this.userId;
        data["accessCardId"] = this.accessCardId;
        data["companyId"] = this.companyId;
        data["riskGroupId"] = this.riskGroupId;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ICreateOrUpdateEmployeesInput {
    id: number | undefined;
    tenantId: number | undefined;
    employeeId: string | undefined;
    dateOfBirth: DateTime;
    name: string | undefined;
    surname: string | undefined;
    password: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    directPhone: string | undefined;
    age: number | undefined;
    profilePicture: string | undefined;
    isNotifiedByEmail: boolean;
    employeeGradeId: number | undefined;
    employeeTypeId: number | undefined;
    lockThreatOrganizationId: number | undefined;
    businessUnitId: number | undefined;
    employeePosition: string | undefined;
    userId: number | undefined;
    accessCardId: string | undefined;
    companyId: string | undefined;
    riskGroupId: number | undefined;
    isActive: boolean;
}

export class ProgramUser implements IProgramUser {
    id!: number;
    employeeName!: string | undefined;
    organizationId!: number;

    constructor(data?: IProgramUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeName = _data["employeeName"];
            this.organizationId = _data["organizationId"];
        }
    }

    static fromJS(data: any): ProgramUser {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeName"] = this.employeeName;
        data["organizationId"] = this.organizationId;
        return data; 
    }
}

export interface IProgramUser {
    id: number;
    employeeName: string | undefined;
    organizationId: number;
}

export class GetEmployeeUnderOraganizationDto implements IGetEmployeeUnderOraganizationDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IGetEmployeeUnderOraganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetEmployeeUnderOraganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeUnderOraganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetEmployeeUnderOraganizationDto {
    id: number;
    name: string | undefined;
}

export class GetExceptionListDto implements IGetExceptionListDto {
    tenantId!: number | undefined;
    exceptionId!: string | undefined;
    requestedDate!: DateTime | undefined;
    businessJustification!: string | undefined;
    exceptionTitle!: string | undefined;
    comments!: string | undefined;
    expertReviewerId!: number | undefined;
    expertReviewer!: BusinessServiceOwner;
    requestedTillDate!: DateTime | undefined;
    reviewDate!: DateTime | undefined;
    approvedTill!: DateTime | undefined;
    nextReview!: DateTime | undefined;
    riskDetails!: string | undefined;
    critcalityId!: number | undefined;
    critcality!: DynamicPropertyValue;
    reviewPriorityId!: number | undefined;
    reviewPriority!: DynamicPropertyValue;
    typeId!: number | undefined;
    type!: DynamicPropertyValue;
    exceptionStatusId!: number | undefined;
    exceptionStatus!: DynamicPropertyValue;
    reviewStatusId!: number | undefined;
    reviewStatus!: DynamicPropertyValue;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationForEditDto;
    employeeId!: number | undefined;
    employee!: BusinessServiceOwner;
    businessUnitId!: number | undefined;
    businessUnit!: BusinessUnitPrimaryDto;
    id!: number;

    constructor(data?: IGetExceptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.exceptionId = _data["exceptionId"];
            this.requestedDate = _data["requestedDate"] ? DateTime.fromISO(_data["requestedDate"].toString()) : <any>undefined;
            this.businessJustification = _data["businessJustification"];
            this.exceptionTitle = _data["exceptionTitle"];
            this.comments = _data["comments"];
            this.expertReviewerId = _data["expertReviewerId"];
            this.expertReviewer = _data["expertReviewer"] ? BusinessServiceOwner.fromJS(_data["expertReviewer"]) : <any>undefined;
            this.requestedTillDate = _data["requestedTillDate"] ? DateTime.fromISO(_data["requestedTillDate"].toString()) : <any>undefined;
            this.reviewDate = _data["reviewDate"] ? DateTime.fromISO(_data["reviewDate"].toString()) : <any>undefined;
            this.approvedTill = _data["approvedTill"] ? DateTime.fromISO(_data["approvedTill"].toString()) : <any>undefined;
            this.nextReview = _data["nextReview"] ? DateTime.fromISO(_data["nextReview"].toString()) : <any>undefined;
            this.riskDetails = _data["riskDetails"];
            this.critcalityId = _data["critcalityId"];
            this.critcality = _data["critcality"] ? DynamicPropertyValue.fromJS(_data["critcality"]) : <any>undefined;
            this.reviewPriorityId = _data["reviewPriorityId"];
            this.reviewPriority = _data["reviewPriority"] ? DynamicPropertyValue.fromJS(_data["reviewPriority"]) : <any>undefined;
            this.typeId = _data["typeId"];
            this.type = _data["type"] ? DynamicPropertyValue.fromJS(_data["type"]) : <any>undefined;
            this.exceptionStatusId = _data["exceptionStatusId"];
            this.exceptionStatus = _data["exceptionStatus"] ? DynamicPropertyValue.fromJS(_data["exceptionStatus"]) : <any>undefined;
            this.reviewStatusId = _data["reviewStatusId"];
            this.reviewStatus = _data["reviewStatus"] ? DynamicPropertyValue.fromJS(_data["reviewStatus"]) : <any>undefined;
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationForEditDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? BusinessServiceOwner.fromJS(_data["employee"]) : <any>undefined;
            this.businessUnitId = _data["businessUnitId"];
            this.businessUnit = _data["businessUnit"] ? BusinessUnitPrimaryDto.fromJS(_data["businessUnit"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetExceptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetExceptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["exceptionId"] = this.exceptionId;
        data["requestedDate"] = this.requestedDate ? this.requestedDate.toString() : <any>undefined;
        data["businessJustification"] = this.businessJustification;
        data["exceptionTitle"] = this.exceptionTitle;
        data["comments"] = this.comments;
        data["expertReviewerId"] = this.expertReviewerId;
        data["expertReviewer"] = this.expertReviewer ? this.expertReviewer.toJSON() : <any>undefined;
        data["requestedTillDate"] = this.requestedTillDate ? this.requestedTillDate.toString() : <any>undefined;
        data["reviewDate"] = this.reviewDate ? this.reviewDate.toString() : <any>undefined;
        data["approvedTill"] = this.approvedTill ? this.approvedTill.toString() : <any>undefined;
        data["nextReview"] = this.nextReview ? this.nextReview.toString() : <any>undefined;
        data["riskDetails"] = this.riskDetails;
        data["critcalityId"] = this.critcalityId;
        data["critcality"] = this.critcality ? this.critcality.toJSON() : <any>undefined;
        data["reviewPriorityId"] = this.reviewPriorityId;
        data["reviewPriority"] = this.reviewPriority ? this.reviewPriority.toJSON() : <any>undefined;
        data["typeId"] = this.typeId;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["exceptionStatusId"] = this.exceptionStatusId;
        data["exceptionStatus"] = this.exceptionStatus ? this.exceptionStatus.toJSON() : <any>undefined;
        data["reviewStatusId"] = this.reviewStatusId;
        data["reviewStatus"] = this.reviewStatus ? this.reviewStatus.toJSON() : <any>undefined;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["businessUnitId"] = this.businessUnitId;
        data["businessUnit"] = this.businessUnit ? this.businessUnit.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetExceptionListDto {
    tenantId: number | undefined;
    exceptionId: string | undefined;
    requestedDate: DateTime | undefined;
    businessJustification: string | undefined;
    exceptionTitle: string | undefined;
    comments: string | undefined;
    expertReviewerId: number | undefined;
    expertReviewer: BusinessServiceOwner;
    requestedTillDate: DateTime | undefined;
    reviewDate: DateTime | undefined;
    approvedTill: DateTime | undefined;
    nextReview: DateTime | undefined;
    riskDetails: string | undefined;
    critcalityId: number | undefined;
    critcality: DynamicPropertyValue;
    reviewPriorityId: number | undefined;
    reviewPriority: DynamicPropertyValue;
    typeId: number | undefined;
    type: DynamicPropertyValue;
    exceptionStatusId: number | undefined;
    exceptionStatus: DynamicPropertyValue;
    reviewStatusId: number | undefined;
    reviewStatus: DynamicPropertyValue;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationForEditDto;
    employeeId: number | undefined;
    employee: BusinessServiceOwner;
    businessUnitId: number | undefined;
    businessUnit: BusinessUnitPrimaryDto;
    id: number;
}

export class PagedResultDtoOfGetExceptionListDto implements IPagedResultDtoOfGetExceptionListDto {
    totalCount!: number;
    items!: GetExceptionListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetExceptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetExceptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetExceptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetExceptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetExceptionListDto {
    totalCount: number;
    items: GetExceptionListDto[] | undefined;
}

export class AssetInformationListDto implements IAssetInformationListDto {
    id!: number | undefined;
    assetTitle!: string | undefined;

    constructor(data?: IAssetInformationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetTitle = _data["assetTitle"];
        }
    }

    static fromJS(data: any): AssetInformationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetInformationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetTitle"] = this.assetTitle;
        return data; 
    }
}

export interface IAssetInformationListDto {
    id: number | undefined;
    assetTitle: string | undefined;
}

export class AuthorativeDocumentDto implements IAuthorativeDocumentDto {
    id!: number;
    authoratativeDocumentTitle!: string | undefined;

    constructor(data?: IAuthorativeDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.authoratativeDocumentTitle = _data["authoratativeDocumentTitle"];
        }
    }

    static fromJS(data: any): AuthorativeDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorativeDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["authoratativeDocumentTitle"] = this.authoratativeDocumentTitle;
        return data; 
    }
}

export interface IAuthorativeDocumentDto {
    id: number;
    authoratativeDocumentTitle: string | undefined;
}

export class PolicyManagerDto implements IPolicyManagerDto {
    id!: number;
    policyName!: string | undefined;

    constructor(data?: IPolicyManagerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.policyName = _data["policyName"];
        }
    }

    static fromJS(data: any): PolicyManagerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyManagerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["policyName"] = this.policyName;
        return data; 
    }
}

export interface IPolicyManagerDto {
    id: number;
    policyName: string | undefined;
}

export class CitationDto implements ICitationDto {
    id!: number;
    citationTitle!: string | undefined;

    constructor(data?: ICitationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.citationTitle = _data["citationTitle"];
        }
    }

    static fromJS(data: any): CitationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CitationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["citationTitle"] = this.citationTitle;
        return data; 
    }
}

export interface ICitationDto {
    id: number;
    citationTitle: string | undefined;
}

export class RemediationDto implements IRemediationDto {
    id!: number;
    planTitle!: string | undefined;

    constructor(data?: IRemediationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planTitle = _data["planTitle"];
        }
    }

    static fromJS(data: any): RemediationDto {
        data = typeof data === 'object' ? data : {};
        let result = new RemediationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planTitle"] = this.planTitle;
        return data; 
    }
}

export interface IRemediationDto {
    id: number;
    planTitle: string | undefined;
}

export class ExceptionAuditingControlDto implements IExceptionAuditingControlDto {
    id!: number;
    exceptionId!: number | undefined;
    citationId!: number | undefined;

    constructor(data?: IExceptionAuditingControlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exceptionId = _data["exceptionId"];
            this.citationId = _data["citationId"];
        }
    }

    static fromJS(data: any): ExceptionAuditingControlDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExceptionAuditingControlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exceptionId"] = this.exceptionId;
        data["citationId"] = this.citationId;
        return data; 
    }
}

export interface IExceptionAuditingControlDto {
    id: number;
    exceptionId: number | undefined;
    citationId: number | undefined;
}

export class ExceptionAuthoratativeDocumentDto implements IExceptionAuthoratativeDocumentDto {
    id!: number;
    exceptionId!: number | undefined;
    authoratativeDocumentId!: number | undefined;

    constructor(data?: IExceptionAuthoratativeDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exceptionId = _data["exceptionId"];
            this.authoratativeDocumentId = _data["authoratativeDocumentId"];
        }
    }

    static fromJS(data: any): ExceptionAuthoratativeDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExceptionAuthoratativeDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exceptionId"] = this.exceptionId;
        data["authoratativeDocumentId"] = this.authoratativeDocumentId;
        return data; 
    }
}

export interface IExceptionAuthoratativeDocumentDto {
    id: number;
    exceptionId: number | undefined;
    authoratativeDocumentId: number | undefined;
}

export class ExceptionBusinessUnitDto implements IExceptionBusinessUnitDto {
    id!: number;
    exceptionId!: number | undefined;
    businessUnitId!: number | undefined;

    constructor(data?: IExceptionBusinessUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exceptionId = _data["exceptionId"];
            this.businessUnitId = _data["businessUnitId"];
        }
    }

    static fromJS(data: any): ExceptionBusinessUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExceptionBusinessUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exceptionId"] = this.exceptionId;
        data["businessUnitId"] = this.businessUnitId;
        return data; 
    }
}

export interface IExceptionBusinessUnitDto {
    id: number;
    exceptionId: number | undefined;
    businessUnitId: number | undefined;
}

export class ExceptionCitationDto implements IExceptionCitationDto {
    id!: number;
    exceptionId!: number | undefined;
    citationId!: number | undefined;

    constructor(data?: IExceptionCitationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exceptionId = _data["exceptionId"];
            this.citationId = _data["citationId"];
        }
    }

    static fromJS(data: any): ExceptionCitationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExceptionCitationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exceptionId"] = this.exceptionId;
        data["citationId"] = this.citationId;
        return data; 
    }
}

export interface IExceptionCitationDto {
    id: number;
    exceptionId: number | undefined;
    citationId: number | undefined;
}

export class ExceptionCitationLibraryDto implements IExceptionCitationLibraryDto {
    id!: number;
    exceptionId!: number | undefined;
    citationId!: number | undefined;

    constructor(data?: IExceptionCitationLibraryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exceptionId = _data["exceptionId"];
            this.citationId = _data["citationId"];
        }
    }

    static fromJS(data: any): ExceptionCitationLibraryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExceptionCitationLibraryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exceptionId"] = this.exceptionId;
        data["citationId"] = this.citationId;
        return data; 
    }
}

export interface IExceptionCitationLibraryDto {
    id: number;
    exceptionId: number | undefined;
    citationId: number | undefined;
}

export class ExceptionDocumentDto implements IExceptionDocumentDto {
    id!: number;
    exceptionId!: number | undefined;
    document!: string | undefined;
    title!: string | undefined;
    description!: string | undefined;

    constructor(data?: IExceptionDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exceptionId = _data["exceptionId"];
            this.document = _data["document"];
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ExceptionDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExceptionDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exceptionId"] = this.exceptionId;
        data["document"] = this.document;
        data["title"] = this.title;
        data["description"] = this.description;
        return data; 
    }
}

export interface IExceptionDocumentDto {
    id: number;
    exceptionId: number | undefined;
    document: string | undefined;
    title: string | undefined;
    description: string | undefined;
}

export class ExceptionOrganizationDto implements IExceptionOrganizationDto {
    id!: number;
    exceptionId!: number | undefined;
    lockThreatOrganizationId!: number | undefined;

    constructor(data?: IExceptionOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exceptionId = _data["exceptionId"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
        }
    }

    static fromJS(data: any): ExceptionOrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExceptionOrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exceptionId"] = this.exceptionId;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        return data; 
    }
}

export interface IExceptionOrganizationDto {
    id: number;
    exceptionId: number | undefined;
    lockThreatOrganizationId: number | undefined;
}

export class ExceptionRemediationDto implements IExceptionRemediationDto {
    id!: number;
    exceptionId!: number | undefined;
    remediationId!: number | undefined;

    constructor(data?: IExceptionRemediationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exceptionId = _data["exceptionId"];
            this.remediationId = _data["remediationId"];
        }
    }

    static fromJS(data: any): ExceptionRemediationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExceptionRemediationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exceptionId"] = this.exceptionId;
        data["remediationId"] = this.remediationId;
        return data; 
    }
}

export interface IExceptionRemediationDto {
    id: number;
    exceptionId: number | undefined;
    remediationId: number | undefined;
}

export class ExceptionRiskManagementDto implements IExceptionRiskManagementDto {
    id!: number;
    exceptionId!: number | undefined;
    riskManagementId!: number | undefined;

    constructor(data?: IExceptionRiskManagementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exceptionId = _data["exceptionId"];
            this.riskManagementId = _data["riskManagementId"];
        }
    }

    static fromJS(data: any): ExceptionRiskManagementDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExceptionRiskManagementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exceptionId"] = this.exceptionId;
        data["riskManagementId"] = this.riskManagementId;
        return data; 
    }
}

export interface IExceptionRiskManagementDto {
    id: number;
    exceptionId: number | undefined;
    riskManagementId: number | undefined;
}

export class GetExceptionInfoDto implements IGetExceptionInfoDto {
    tenantId!: number | undefined;
    exceptionId!: string | undefined;
    requestedDate!: DateTime | undefined;
    businessJustification!: string | undefined;
    exceptionTitle!: string | undefined;
    comments!: string | undefined;
    expertReviewerId!: number | undefined;
    expertReviewers!: BusinessServiceOwner[] | undefined;
    requestedTillDate!: DateTime | undefined;
    reviewDate!: DateTime | undefined;
    approvedTill!: DateTime | undefined;
    nextReview!: DateTime | undefined;
    riskDetails!: string | undefined;
    critcalityId!: number | undefined;
    critcalitys!: GetDynamicValueDto[] | undefined;
    reviewPriorityId!: number | undefined;
    reviewPrioritys!: GetDynamicValueDto[] | undefined;
    typeId!: number | undefined;
    types!: GetDynamicValueDto[] | undefined;
    exceptionStatusId!: number | undefined;
    exceptionStatusList!: GetDynamicValueDto[] | undefined;
    reviewStatusId!: number | undefined;
    reviewStatusList!: GetDynamicValueDto[] | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    employeeId!: number | undefined;
    employeesList!: BusinessServiceOwner[] | undefined;
    businessUnitId!: number | undefined;
    businessUnitOwners!: BusinessUnitPrimaryDto[] | undefined;
    assetInformationId!: number | undefined;
    assetInformations!: AssetInformationListDto[] | undefined;
    authoritativeSourceList!: AuthorativeDocumentDto[] | undefined;
    policyManagerId!: number | undefined;
    policyManagers!: PolicyManagerDto[] | undefined;
    systemApplicationId!: number | undefined;
    systemApplicationList!: SytemApplicationDto[] | undefined;
    citationList!: CitationDto[] | undefined;
    remediationList!: RemediationDto[] | undefined;
    selectedExceptionAuditingControls!: ExceptionAuditingControlDto[] | undefined;
    selectedExceptionAuthoratativeDocuments!: ExceptionAuthoratativeDocumentDto[] | undefined;
    selectedExceptionBusinessUnits!: ExceptionBusinessUnitDto[] | undefined;
    selectedExceptionCitations!: ExceptionCitationDto[] | undefined;
    selectedExceptionCitationLibrarys!: ExceptionCitationLibraryDto[] | undefined;
    selectedExceptionDocuments!: ExceptionDocumentDto[] | undefined;
    selectedExceptionOrganizations!: ExceptionOrganizationDto[] | undefined;
    selectedExceptionRemediations!: ExceptionRemediationDto[] | undefined;
    selectedExceptionRiskManagements!: ExceptionRiskManagementDto[] | undefined;
    removedExceptionAuditingControl!: number[] | undefined;
    removedExceptionAuthoratativeDocument!: number[] | undefined;
    removedExceptionBusinessUnit!: number[] | undefined;
    removedExceptionCitation!: number[] | undefined;
    removedExceptionCitationLibrary!: number[] | undefined;
    removedExceptionDocument!: number[] | undefined;
    removedExceptionOrganization!: number[] | undefined;
    removedExceptionRemediation!: number[] | undefined;
    removedExceptionRiskManagement!: number[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IGetExceptionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.exceptionId = _data["exceptionId"];
            this.requestedDate = _data["requestedDate"] ? DateTime.fromISO(_data["requestedDate"].toString()) : <any>undefined;
            this.businessJustification = _data["businessJustification"];
            this.exceptionTitle = _data["exceptionTitle"];
            this.comments = _data["comments"];
            this.expertReviewerId = _data["expertReviewerId"];
            if (Array.isArray(_data["expertReviewers"])) {
                this.expertReviewers = [] as any;
                for (let item of _data["expertReviewers"])
                    this.expertReviewers!.push(BusinessServiceOwner.fromJS(item));
            }
            this.requestedTillDate = _data["requestedTillDate"] ? DateTime.fromISO(_data["requestedTillDate"].toString()) : <any>undefined;
            this.reviewDate = _data["reviewDate"] ? DateTime.fromISO(_data["reviewDate"].toString()) : <any>undefined;
            this.approvedTill = _data["approvedTill"] ? DateTime.fromISO(_data["approvedTill"].toString()) : <any>undefined;
            this.nextReview = _data["nextReview"] ? DateTime.fromISO(_data["nextReview"].toString()) : <any>undefined;
            this.riskDetails = _data["riskDetails"];
            this.critcalityId = _data["critcalityId"];
            if (Array.isArray(_data["critcalitys"])) {
                this.critcalitys = [] as any;
                for (let item of _data["critcalitys"])
                    this.critcalitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.reviewPriorityId = _data["reviewPriorityId"];
            if (Array.isArray(_data["reviewPrioritys"])) {
                this.reviewPrioritys = [] as any;
                for (let item of _data["reviewPrioritys"])
                    this.reviewPrioritys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.typeId = _data["typeId"];
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types!.push(GetDynamicValueDto.fromJS(item));
            }
            this.exceptionStatusId = _data["exceptionStatusId"];
            if (Array.isArray(_data["exceptionStatusList"])) {
                this.exceptionStatusList = [] as any;
                for (let item of _data["exceptionStatusList"])
                    this.exceptionStatusList!.push(GetDynamicValueDto.fromJS(item));
            }
            this.reviewStatusId = _data["reviewStatusId"];
            if (Array.isArray(_data["reviewStatusList"])) {
                this.reviewStatusList = [] as any;
                for (let item of _data["reviewStatusList"])
                    this.reviewStatusList!.push(GetDynamicValueDto.fromJS(item));
            }
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["employeesList"])) {
                this.employeesList = [] as any;
                for (let item of _data["employeesList"])
                    this.employeesList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.businessUnitId = _data["businessUnitId"];
            if (Array.isArray(_data["businessUnitOwners"])) {
                this.businessUnitOwners = [] as any;
                for (let item of _data["businessUnitOwners"])
                    this.businessUnitOwners!.push(BusinessUnitPrimaryDto.fromJS(item));
            }
            this.assetInformationId = _data["assetInformationId"];
            if (Array.isArray(_data["assetInformations"])) {
                this.assetInformations = [] as any;
                for (let item of _data["assetInformations"])
                    this.assetInformations!.push(AssetInformationListDto.fromJS(item));
            }
            if (Array.isArray(_data["authoritativeSourceList"])) {
                this.authoritativeSourceList = [] as any;
                for (let item of _data["authoritativeSourceList"])
                    this.authoritativeSourceList!.push(AuthorativeDocumentDto.fromJS(item));
            }
            this.policyManagerId = _data["policyManagerId"];
            if (Array.isArray(_data["policyManagers"])) {
                this.policyManagers = [] as any;
                for (let item of _data["policyManagers"])
                    this.policyManagers!.push(PolicyManagerDto.fromJS(item));
            }
            this.systemApplicationId = _data["systemApplicationId"];
            if (Array.isArray(_data["systemApplicationList"])) {
                this.systemApplicationList = [] as any;
                for (let item of _data["systemApplicationList"])
                    this.systemApplicationList!.push(SytemApplicationDto.fromJS(item));
            }
            if (Array.isArray(_data["citationList"])) {
                this.citationList = [] as any;
                for (let item of _data["citationList"])
                    this.citationList!.push(CitationDto.fromJS(item));
            }
            if (Array.isArray(_data["remediationList"])) {
                this.remediationList = [] as any;
                for (let item of _data["remediationList"])
                    this.remediationList!.push(RemediationDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedExceptionAuditingControls"])) {
                this.selectedExceptionAuditingControls = [] as any;
                for (let item of _data["selectedExceptionAuditingControls"])
                    this.selectedExceptionAuditingControls!.push(ExceptionAuditingControlDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedExceptionAuthoratativeDocuments"])) {
                this.selectedExceptionAuthoratativeDocuments = [] as any;
                for (let item of _data["selectedExceptionAuthoratativeDocuments"])
                    this.selectedExceptionAuthoratativeDocuments!.push(ExceptionAuthoratativeDocumentDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedExceptionBusinessUnits"])) {
                this.selectedExceptionBusinessUnits = [] as any;
                for (let item of _data["selectedExceptionBusinessUnits"])
                    this.selectedExceptionBusinessUnits!.push(ExceptionBusinessUnitDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedExceptionCitations"])) {
                this.selectedExceptionCitations = [] as any;
                for (let item of _data["selectedExceptionCitations"])
                    this.selectedExceptionCitations!.push(ExceptionCitationDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedExceptionCitationLibrarys"])) {
                this.selectedExceptionCitationLibrarys = [] as any;
                for (let item of _data["selectedExceptionCitationLibrarys"])
                    this.selectedExceptionCitationLibrarys!.push(ExceptionCitationLibraryDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedExceptionDocuments"])) {
                this.selectedExceptionDocuments = [] as any;
                for (let item of _data["selectedExceptionDocuments"])
                    this.selectedExceptionDocuments!.push(ExceptionDocumentDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedExceptionOrganizations"])) {
                this.selectedExceptionOrganizations = [] as any;
                for (let item of _data["selectedExceptionOrganizations"])
                    this.selectedExceptionOrganizations!.push(ExceptionOrganizationDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedExceptionRemediations"])) {
                this.selectedExceptionRemediations = [] as any;
                for (let item of _data["selectedExceptionRemediations"])
                    this.selectedExceptionRemediations!.push(ExceptionRemediationDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedExceptionRiskManagements"])) {
                this.selectedExceptionRiskManagements = [] as any;
                for (let item of _data["selectedExceptionRiskManagements"])
                    this.selectedExceptionRiskManagements!.push(ExceptionRiskManagementDto.fromJS(item));
            }
            if (Array.isArray(_data["removedExceptionAuditingControl"])) {
                this.removedExceptionAuditingControl = [] as any;
                for (let item of _data["removedExceptionAuditingControl"])
                    this.removedExceptionAuditingControl!.push(item);
            }
            if (Array.isArray(_data["removedExceptionAuthoratativeDocument"])) {
                this.removedExceptionAuthoratativeDocument = [] as any;
                for (let item of _data["removedExceptionAuthoratativeDocument"])
                    this.removedExceptionAuthoratativeDocument!.push(item);
            }
            if (Array.isArray(_data["removedExceptionBusinessUnit"])) {
                this.removedExceptionBusinessUnit = [] as any;
                for (let item of _data["removedExceptionBusinessUnit"])
                    this.removedExceptionBusinessUnit!.push(item);
            }
            if (Array.isArray(_data["removedExceptionCitation"])) {
                this.removedExceptionCitation = [] as any;
                for (let item of _data["removedExceptionCitation"])
                    this.removedExceptionCitation!.push(item);
            }
            if (Array.isArray(_data["removedExceptionCitationLibrary"])) {
                this.removedExceptionCitationLibrary = [] as any;
                for (let item of _data["removedExceptionCitationLibrary"])
                    this.removedExceptionCitationLibrary!.push(item);
            }
            if (Array.isArray(_data["removedExceptionDocument"])) {
                this.removedExceptionDocument = [] as any;
                for (let item of _data["removedExceptionDocument"])
                    this.removedExceptionDocument!.push(item);
            }
            if (Array.isArray(_data["removedExceptionOrganization"])) {
                this.removedExceptionOrganization = [] as any;
                for (let item of _data["removedExceptionOrganization"])
                    this.removedExceptionOrganization!.push(item);
            }
            if (Array.isArray(_data["removedExceptionRemediation"])) {
                this.removedExceptionRemediation = [] as any;
                for (let item of _data["removedExceptionRemediation"])
                    this.removedExceptionRemediation!.push(item);
            }
            if (Array.isArray(_data["removedExceptionRiskManagement"])) {
                this.removedExceptionRiskManagement = [] as any;
                for (let item of _data["removedExceptionRiskManagement"])
                    this.removedExceptionRiskManagement!.push(item);
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetExceptionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetExceptionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["exceptionId"] = this.exceptionId;
        data["requestedDate"] = this.requestedDate ? this.requestedDate.toString() : <any>undefined;
        data["businessJustification"] = this.businessJustification;
        data["exceptionTitle"] = this.exceptionTitle;
        data["comments"] = this.comments;
        data["expertReviewerId"] = this.expertReviewerId;
        if (Array.isArray(this.expertReviewers)) {
            data["expertReviewers"] = [];
            for (let item of this.expertReviewers)
                data["expertReviewers"].push(item.toJSON());
        }
        data["requestedTillDate"] = this.requestedTillDate ? this.requestedTillDate.toString() : <any>undefined;
        data["reviewDate"] = this.reviewDate ? this.reviewDate.toString() : <any>undefined;
        data["approvedTill"] = this.approvedTill ? this.approvedTill.toString() : <any>undefined;
        data["nextReview"] = this.nextReview ? this.nextReview.toString() : <any>undefined;
        data["riskDetails"] = this.riskDetails;
        data["critcalityId"] = this.critcalityId;
        if (Array.isArray(this.critcalitys)) {
            data["critcalitys"] = [];
            for (let item of this.critcalitys)
                data["critcalitys"].push(item.toJSON());
        }
        data["reviewPriorityId"] = this.reviewPriorityId;
        if (Array.isArray(this.reviewPrioritys)) {
            data["reviewPrioritys"] = [];
            for (let item of this.reviewPrioritys)
                data["reviewPrioritys"].push(item.toJSON());
        }
        data["typeId"] = this.typeId;
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item.toJSON());
        }
        data["exceptionStatusId"] = this.exceptionStatusId;
        if (Array.isArray(this.exceptionStatusList)) {
            data["exceptionStatusList"] = [];
            for (let item of this.exceptionStatusList)
                data["exceptionStatusList"].push(item.toJSON());
        }
        data["reviewStatusId"] = this.reviewStatusId;
        if (Array.isArray(this.reviewStatusList)) {
            data["reviewStatusList"] = [];
            for (let item of this.reviewStatusList)
                data["reviewStatusList"].push(item.toJSON());
        }
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.employeesList)) {
            data["employeesList"] = [];
            for (let item of this.employeesList)
                data["employeesList"].push(item.toJSON());
        }
        data["businessUnitId"] = this.businessUnitId;
        if (Array.isArray(this.businessUnitOwners)) {
            data["businessUnitOwners"] = [];
            for (let item of this.businessUnitOwners)
                data["businessUnitOwners"].push(item.toJSON());
        }
        data["assetInformationId"] = this.assetInformationId;
        if (Array.isArray(this.assetInformations)) {
            data["assetInformations"] = [];
            for (let item of this.assetInformations)
                data["assetInformations"].push(item.toJSON());
        }
        if (Array.isArray(this.authoritativeSourceList)) {
            data["authoritativeSourceList"] = [];
            for (let item of this.authoritativeSourceList)
                data["authoritativeSourceList"].push(item.toJSON());
        }
        data["policyManagerId"] = this.policyManagerId;
        if (Array.isArray(this.policyManagers)) {
            data["policyManagers"] = [];
            for (let item of this.policyManagers)
                data["policyManagers"].push(item.toJSON());
        }
        data["systemApplicationId"] = this.systemApplicationId;
        if (Array.isArray(this.systemApplicationList)) {
            data["systemApplicationList"] = [];
            for (let item of this.systemApplicationList)
                data["systemApplicationList"].push(item.toJSON());
        }
        if (Array.isArray(this.citationList)) {
            data["citationList"] = [];
            for (let item of this.citationList)
                data["citationList"].push(item.toJSON());
        }
        if (Array.isArray(this.remediationList)) {
            data["remediationList"] = [];
            for (let item of this.remediationList)
                data["remediationList"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedExceptionAuditingControls)) {
            data["selectedExceptionAuditingControls"] = [];
            for (let item of this.selectedExceptionAuditingControls)
                data["selectedExceptionAuditingControls"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedExceptionAuthoratativeDocuments)) {
            data["selectedExceptionAuthoratativeDocuments"] = [];
            for (let item of this.selectedExceptionAuthoratativeDocuments)
                data["selectedExceptionAuthoratativeDocuments"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedExceptionBusinessUnits)) {
            data["selectedExceptionBusinessUnits"] = [];
            for (let item of this.selectedExceptionBusinessUnits)
                data["selectedExceptionBusinessUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedExceptionCitations)) {
            data["selectedExceptionCitations"] = [];
            for (let item of this.selectedExceptionCitations)
                data["selectedExceptionCitations"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedExceptionCitationLibrarys)) {
            data["selectedExceptionCitationLibrarys"] = [];
            for (let item of this.selectedExceptionCitationLibrarys)
                data["selectedExceptionCitationLibrarys"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedExceptionDocuments)) {
            data["selectedExceptionDocuments"] = [];
            for (let item of this.selectedExceptionDocuments)
                data["selectedExceptionDocuments"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedExceptionOrganizations)) {
            data["selectedExceptionOrganizations"] = [];
            for (let item of this.selectedExceptionOrganizations)
                data["selectedExceptionOrganizations"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedExceptionRemediations)) {
            data["selectedExceptionRemediations"] = [];
            for (let item of this.selectedExceptionRemediations)
                data["selectedExceptionRemediations"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedExceptionRiskManagements)) {
            data["selectedExceptionRiskManagements"] = [];
            for (let item of this.selectedExceptionRiskManagements)
                data["selectedExceptionRiskManagements"].push(item.toJSON());
        }
        if (Array.isArray(this.removedExceptionAuditingControl)) {
            data["removedExceptionAuditingControl"] = [];
            for (let item of this.removedExceptionAuditingControl)
                data["removedExceptionAuditingControl"].push(item);
        }
        if (Array.isArray(this.removedExceptionAuthoratativeDocument)) {
            data["removedExceptionAuthoratativeDocument"] = [];
            for (let item of this.removedExceptionAuthoratativeDocument)
                data["removedExceptionAuthoratativeDocument"].push(item);
        }
        if (Array.isArray(this.removedExceptionBusinessUnit)) {
            data["removedExceptionBusinessUnit"] = [];
            for (let item of this.removedExceptionBusinessUnit)
                data["removedExceptionBusinessUnit"].push(item);
        }
        if (Array.isArray(this.removedExceptionCitation)) {
            data["removedExceptionCitation"] = [];
            for (let item of this.removedExceptionCitation)
                data["removedExceptionCitation"].push(item);
        }
        if (Array.isArray(this.removedExceptionCitationLibrary)) {
            data["removedExceptionCitationLibrary"] = [];
            for (let item of this.removedExceptionCitationLibrary)
                data["removedExceptionCitationLibrary"].push(item);
        }
        if (Array.isArray(this.removedExceptionDocument)) {
            data["removedExceptionDocument"] = [];
            for (let item of this.removedExceptionDocument)
                data["removedExceptionDocument"].push(item);
        }
        if (Array.isArray(this.removedExceptionOrganization)) {
            data["removedExceptionOrganization"] = [];
            for (let item of this.removedExceptionOrganization)
                data["removedExceptionOrganization"].push(item);
        }
        if (Array.isArray(this.removedExceptionRemediation)) {
            data["removedExceptionRemediation"] = [];
            for (let item of this.removedExceptionRemediation)
                data["removedExceptionRemediation"].push(item);
        }
        if (Array.isArray(this.removedExceptionRiskManagement)) {
            data["removedExceptionRiskManagement"] = [];
            for (let item of this.removedExceptionRiskManagement)
                data["removedExceptionRiskManagement"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetExceptionInfoDto {
    tenantId: number | undefined;
    exceptionId: string | undefined;
    requestedDate: DateTime | undefined;
    businessJustification: string | undefined;
    exceptionTitle: string | undefined;
    comments: string | undefined;
    expertReviewerId: number | undefined;
    expertReviewers: BusinessServiceOwner[] | undefined;
    requestedTillDate: DateTime | undefined;
    reviewDate: DateTime | undefined;
    approvedTill: DateTime | undefined;
    nextReview: DateTime | undefined;
    riskDetails: string | undefined;
    critcalityId: number | undefined;
    critcalitys: GetDynamicValueDto[] | undefined;
    reviewPriorityId: number | undefined;
    reviewPrioritys: GetDynamicValueDto[] | undefined;
    typeId: number | undefined;
    types: GetDynamicValueDto[] | undefined;
    exceptionStatusId: number | undefined;
    exceptionStatusList: GetDynamicValueDto[] | undefined;
    reviewStatusId: number | undefined;
    reviewStatusList: GetDynamicValueDto[] | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    employeeId: number | undefined;
    employeesList: BusinessServiceOwner[] | undefined;
    businessUnitId: number | undefined;
    businessUnitOwners: BusinessUnitPrimaryDto[] | undefined;
    assetInformationId: number | undefined;
    assetInformations: AssetInformationListDto[] | undefined;
    authoritativeSourceList: AuthorativeDocumentDto[] | undefined;
    policyManagerId: number | undefined;
    policyManagers: PolicyManagerDto[] | undefined;
    systemApplicationId: number | undefined;
    systemApplicationList: SytemApplicationDto[] | undefined;
    citationList: CitationDto[] | undefined;
    remediationList: RemediationDto[] | undefined;
    selectedExceptionAuditingControls: ExceptionAuditingControlDto[] | undefined;
    selectedExceptionAuthoratativeDocuments: ExceptionAuthoratativeDocumentDto[] | undefined;
    selectedExceptionBusinessUnits: ExceptionBusinessUnitDto[] | undefined;
    selectedExceptionCitations: ExceptionCitationDto[] | undefined;
    selectedExceptionCitationLibrarys: ExceptionCitationLibraryDto[] | undefined;
    selectedExceptionDocuments: ExceptionDocumentDto[] | undefined;
    selectedExceptionOrganizations: ExceptionOrganizationDto[] | undefined;
    selectedExceptionRemediations: ExceptionRemediationDto[] | undefined;
    selectedExceptionRiskManagements: ExceptionRiskManagementDto[] | undefined;
    removedExceptionAuditingControl: number[] | undefined;
    removedExceptionAuthoratativeDocument: number[] | undefined;
    removedExceptionBusinessUnit: number[] | undefined;
    removedExceptionCitation: number[] | undefined;
    removedExceptionCitationLibrary: number[] | undefined;
    removedExceptionDocument: number[] | undefined;
    removedExceptionOrganization: number[] | undefined;
    removedExceptionRemediation: number[] | undefined;
    removedExceptionRiskManagement: number[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class FacilitieDatacenterITServiceDto implements IFacilitieDatacenterITServiceDto {
    id!: number;
    facilitieDatacenterId!: number | undefined;
    itServiceId!: number | undefined;

    constructor(data?: IFacilitieDatacenterITServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.facilitieDatacenterId = _data["facilitieDatacenterId"];
            this.itServiceId = _data["itServiceId"];
        }
    }

    static fromJS(data: any): FacilitieDatacenterITServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FacilitieDatacenterITServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["facilitieDatacenterId"] = this.facilitieDatacenterId;
        data["itServiceId"] = this.itServiceId;
        return data; 
    }
}

export interface IFacilitieDatacenterITServiceDto {
    id: number;
    facilitieDatacenterId: number | undefined;
    itServiceId: number | undefined;
}

export class FacilitieDatacenterProcessDto implements IFacilitieDatacenterProcessDto {
    id!: number;
    facilitieDatacenterId!: number | undefined;
    businessProcessId!: number | undefined;

    constructor(data?: IFacilitieDatacenterProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.facilitieDatacenterId = _data["facilitieDatacenterId"];
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static fromJS(data: any): FacilitieDatacenterProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new FacilitieDatacenterProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["facilitieDatacenterId"] = this.facilitieDatacenterId;
        data["businessProcessId"] = this.businessProcessId;
        return data; 
    }
}

export interface IFacilitieDatacenterProcessDto {
    id: number;
    facilitieDatacenterId: number | undefined;
    businessProcessId: number | undefined;
}

export class FacilitieDatacenterServiceDto implements IFacilitieDatacenterServiceDto {
    id!: number;
    facilitieDatacenterId!: number | undefined;
    businessServiceId!: number | undefined;

    constructor(data?: IFacilitieDatacenterServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.facilitieDatacenterId = _data["facilitieDatacenterId"];
            this.businessServiceId = _data["businessServiceId"];
        }
    }

    static fromJS(data: any): FacilitieDatacenterServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FacilitieDatacenterServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["facilitieDatacenterId"] = this.facilitieDatacenterId;
        data["businessServiceId"] = this.businessServiceId;
        return data; 
    }
}

export interface IFacilitieDatacenterServiceDto {
    id: number;
    facilitieDatacenterId: number | undefined;
    businessServiceId: number | undefined;
}

export class FacilitieDatacenterDto implements IFacilitieDatacenterDto {
    tenantId!: number | undefined;
    facilityId!: string | undefined;
    facilityName!: string | undefined;
    facilityAddressOne!: string | undefined;
    facilityAddressTwo!: string | undefined;
    facilityTypeId!: number | undefined;
    facilityTypes!: GetDynamicValueDto[] | undefined;
    state!: string | undefined;
    city!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number | undefined;
    countries!: CountryDto[] | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    businessUnitOwnerId!: number | undefined;
    businessUnitOwners!: BusinessUnitPrimaryDto[] | undefined;
    businessUnitGaurdianId!: number | undefined;
    businessUnitGaurdians!: BusinessUnitGaurdianDto[] | undefined;
    employeeId!: number | undefined;
    employeesList!: BusinessServiceOwner[] | undefined;
    confidentialityId!: number | undefined;
    confidentialitys!: GetDynamicValueDto[] | undefined;
    integrityId!: number | undefined;
    integritys!: GetDynamicValueDto[] | undefined;
    availibilityId!: number | undefined;
    availibilitys!: GetDynamicValueDto[] | undefined;
    othersId!: number | undefined;
    otheres!: GetDynamicValueDto[] | undefined;
    iTserviceLists!: ITserviceListDto[] | undefined;
    businessServices!: BusinessServiceSDto[] | undefined;
    businessProcess!: BusinessProcessDetailDto[] | undefined;
    selectedFacilitieDatacenterITServices!: FacilitieDatacenterITServiceDto[] | undefined;
    selectedFacilitieDatacenterProcess!: FacilitieDatacenterProcessDto[] | undefined;
    selectedFacilitieDatacenterServices!: FacilitieDatacenterServiceDto[] | undefined;
    removedFacilitieDatacenterITService!: number[] | undefined;
    removedFacilitieDatacenterProcess!: number[] | undefined;
    removedFacilitieDatacenterService!: number[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IFacilitieDatacenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.facilityId = _data["facilityId"];
            this.facilityName = _data["facilityName"];
            this.facilityAddressOne = _data["facilityAddressOne"];
            this.facilityAddressTwo = _data["facilityAddressTwo"];
            this.facilityTypeId = _data["facilityTypeId"];
            if (Array.isArray(_data["facilityTypes"])) {
                this.facilityTypes = [] as any;
                for (let item of _data["facilityTypes"])
                    this.facilityTypes!.push(GetDynamicValueDto.fromJS(item));
            }
            this.state = _data["state"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(CountryDto.fromJS(item));
            }
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            this.businessUnitOwnerId = _data["businessUnitOwnerId"];
            if (Array.isArray(_data["businessUnitOwners"])) {
                this.businessUnitOwners = [] as any;
                for (let item of _data["businessUnitOwners"])
                    this.businessUnitOwners!.push(BusinessUnitPrimaryDto.fromJS(item));
            }
            this.businessUnitGaurdianId = _data["businessUnitGaurdianId"];
            if (Array.isArray(_data["businessUnitGaurdians"])) {
                this.businessUnitGaurdians = [] as any;
                for (let item of _data["businessUnitGaurdians"])
                    this.businessUnitGaurdians!.push(BusinessUnitGaurdianDto.fromJS(item));
            }
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["employeesList"])) {
                this.employeesList = [] as any;
                for (let item of _data["employeesList"])
                    this.employeesList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.confidentialityId = _data["confidentialityId"];
            if (Array.isArray(_data["confidentialitys"])) {
                this.confidentialitys = [] as any;
                for (let item of _data["confidentialitys"])
                    this.confidentialitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.integrityId = _data["integrityId"];
            if (Array.isArray(_data["integritys"])) {
                this.integritys = [] as any;
                for (let item of _data["integritys"])
                    this.integritys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.availibilityId = _data["availibilityId"];
            if (Array.isArray(_data["availibilitys"])) {
                this.availibilitys = [] as any;
                for (let item of _data["availibilitys"])
                    this.availibilitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.othersId = _data["othersId"];
            if (Array.isArray(_data["otheres"])) {
                this.otheres = [] as any;
                for (let item of _data["otheres"])
                    this.otheres!.push(GetDynamicValueDto.fromJS(item));
            }
            if (Array.isArray(_data["iTserviceLists"])) {
                this.iTserviceLists = [] as any;
                for (let item of _data["iTserviceLists"])
                    this.iTserviceLists!.push(ITserviceListDto.fromJS(item));
            }
            if (Array.isArray(_data["businessServices"])) {
                this.businessServices = [] as any;
                for (let item of _data["businessServices"])
                    this.businessServices!.push(BusinessServiceSDto.fromJS(item));
            }
            if (Array.isArray(_data["businessProcess"])) {
                this.businessProcess = [] as any;
                for (let item of _data["businessProcess"])
                    this.businessProcess!.push(BusinessProcessDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFacilitieDatacenterITServices"])) {
                this.selectedFacilitieDatacenterITServices = [] as any;
                for (let item of _data["selectedFacilitieDatacenterITServices"])
                    this.selectedFacilitieDatacenterITServices!.push(FacilitieDatacenterITServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFacilitieDatacenterProcess"])) {
                this.selectedFacilitieDatacenterProcess = [] as any;
                for (let item of _data["selectedFacilitieDatacenterProcess"])
                    this.selectedFacilitieDatacenterProcess!.push(FacilitieDatacenterProcessDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFacilitieDatacenterServices"])) {
                this.selectedFacilitieDatacenterServices = [] as any;
                for (let item of _data["selectedFacilitieDatacenterServices"])
                    this.selectedFacilitieDatacenterServices!.push(FacilitieDatacenterServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["removedFacilitieDatacenterITService"])) {
                this.removedFacilitieDatacenterITService = [] as any;
                for (let item of _data["removedFacilitieDatacenterITService"])
                    this.removedFacilitieDatacenterITService!.push(item);
            }
            if (Array.isArray(_data["removedFacilitieDatacenterProcess"])) {
                this.removedFacilitieDatacenterProcess = [] as any;
                for (let item of _data["removedFacilitieDatacenterProcess"])
                    this.removedFacilitieDatacenterProcess!.push(item);
            }
            if (Array.isArray(_data["removedFacilitieDatacenterService"])) {
                this.removedFacilitieDatacenterService = [] as any;
                for (let item of _data["removedFacilitieDatacenterService"])
                    this.removedFacilitieDatacenterService!.push(item);
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FacilitieDatacenterDto {
        data = typeof data === 'object' ? data : {};
        let result = new FacilitieDatacenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["facilityId"] = this.facilityId;
        data["facilityName"] = this.facilityName;
        data["facilityAddressOne"] = this.facilityAddressOne;
        data["facilityAddressTwo"] = this.facilityAddressTwo;
        data["facilityTypeId"] = this.facilityTypeId;
        if (Array.isArray(this.facilityTypes)) {
            data["facilityTypes"] = [];
            for (let item of this.facilityTypes)
                data["facilityTypes"].push(item.toJSON());
        }
        data["state"] = this.state;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        data["businessUnitOwnerId"] = this.businessUnitOwnerId;
        if (Array.isArray(this.businessUnitOwners)) {
            data["businessUnitOwners"] = [];
            for (let item of this.businessUnitOwners)
                data["businessUnitOwners"].push(item.toJSON());
        }
        data["businessUnitGaurdianId"] = this.businessUnitGaurdianId;
        if (Array.isArray(this.businessUnitGaurdians)) {
            data["businessUnitGaurdians"] = [];
            for (let item of this.businessUnitGaurdians)
                data["businessUnitGaurdians"].push(item.toJSON());
        }
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.employeesList)) {
            data["employeesList"] = [];
            for (let item of this.employeesList)
                data["employeesList"].push(item.toJSON());
        }
        data["confidentialityId"] = this.confidentialityId;
        if (Array.isArray(this.confidentialitys)) {
            data["confidentialitys"] = [];
            for (let item of this.confidentialitys)
                data["confidentialitys"].push(item.toJSON());
        }
        data["integrityId"] = this.integrityId;
        if (Array.isArray(this.integritys)) {
            data["integritys"] = [];
            for (let item of this.integritys)
                data["integritys"].push(item.toJSON());
        }
        data["availibilityId"] = this.availibilityId;
        if (Array.isArray(this.availibilitys)) {
            data["availibilitys"] = [];
            for (let item of this.availibilitys)
                data["availibilitys"].push(item.toJSON());
        }
        data["othersId"] = this.othersId;
        if (Array.isArray(this.otheres)) {
            data["otheres"] = [];
            for (let item of this.otheres)
                data["otheres"].push(item.toJSON());
        }
        if (Array.isArray(this.iTserviceLists)) {
            data["iTserviceLists"] = [];
            for (let item of this.iTserviceLists)
                data["iTserviceLists"].push(item.toJSON());
        }
        if (Array.isArray(this.businessServices)) {
            data["businessServices"] = [];
            for (let item of this.businessServices)
                data["businessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.businessProcess)) {
            data["businessProcess"] = [];
            for (let item of this.businessProcess)
                data["businessProcess"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFacilitieDatacenterITServices)) {
            data["selectedFacilitieDatacenterITServices"] = [];
            for (let item of this.selectedFacilitieDatacenterITServices)
                data["selectedFacilitieDatacenterITServices"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFacilitieDatacenterProcess)) {
            data["selectedFacilitieDatacenterProcess"] = [];
            for (let item of this.selectedFacilitieDatacenterProcess)
                data["selectedFacilitieDatacenterProcess"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFacilitieDatacenterServices)) {
            data["selectedFacilitieDatacenterServices"] = [];
            for (let item of this.selectedFacilitieDatacenterServices)
                data["selectedFacilitieDatacenterServices"].push(item.toJSON());
        }
        if (Array.isArray(this.removedFacilitieDatacenterITService)) {
            data["removedFacilitieDatacenterITService"] = [];
            for (let item of this.removedFacilitieDatacenterITService)
                data["removedFacilitieDatacenterITService"].push(item);
        }
        if (Array.isArray(this.removedFacilitieDatacenterProcess)) {
            data["removedFacilitieDatacenterProcess"] = [];
            for (let item of this.removedFacilitieDatacenterProcess)
                data["removedFacilitieDatacenterProcess"].push(item);
        }
        if (Array.isArray(this.removedFacilitieDatacenterService)) {
            data["removedFacilitieDatacenterService"] = [];
            for (let item of this.removedFacilitieDatacenterService)
                data["removedFacilitieDatacenterService"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IFacilitieDatacenterDto {
    tenantId: number | undefined;
    facilityId: string | undefined;
    facilityName: string | undefined;
    facilityAddressOne: string | undefined;
    facilityAddressTwo: string | undefined;
    facilityTypeId: number | undefined;
    facilityTypes: GetDynamicValueDto[] | undefined;
    state: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    countryId: number | undefined;
    countries: CountryDto[] | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    businessUnitOwnerId: number | undefined;
    businessUnitOwners: BusinessUnitPrimaryDto[] | undefined;
    businessUnitGaurdianId: number | undefined;
    businessUnitGaurdians: BusinessUnitGaurdianDto[] | undefined;
    employeeId: number | undefined;
    employeesList: BusinessServiceOwner[] | undefined;
    confidentialityId: number | undefined;
    confidentialitys: GetDynamicValueDto[] | undefined;
    integrityId: number | undefined;
    integritys: GetDynamicValueDto[] | undefined;
    availibilityId: number | undefined;
    availibilitys: GetDynamicValueDto[] | undefined;
    othersId: number | undefined;
    otheres: GetDynamicValueDto[] | undefined;
    iTserviceLists: ITserviceListDto[] | undefined;
    businessServices: BusinessServiceSDto[] | undefined;
    businessProcess: BusinessProcessDetailDto[] | undefined;
    selectedFacilitieDatacenterITServices: FacilitieDatacenterITServiceDto[] | undefined;
    selectedFacilitieDatacenterProcess: FacilitieDatacenterProcessDto[] | undefined;
    selectedFacilitieDatacenterServices: FacilitieDatacenterServiceDto[] | undefined;
    removedFacilitieDatacenterITService: number[] | undefined;
    removedFacilitieDatacenterProcess: number[] | undefined;
    removedFacilitieDatacenterService: number[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class GetFacilitiesDatacenterListDto implements IGetFacilitiesDatacenterListDto {
    tenantId!: number | undefined;
    facilityId!: string | undefined;
    facilityName!: string | undefined;
    facilityAddressOne!: string | undefined;
    facilityAddressTwo!: string | undefined;
    facilityTypeId!: number | undefined;
    facilityType!: DynamicPropertyValue;
    state!: string | undefined;
    city!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number | undefined;
    country!: DynamicPropertyValue;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationForEditDto;
    businessUnitOwnerId!: number | undefined;
    businessUnitOwner!: BusinessUnitPrimaryDto;
    businessUnitGaurdianId!: number | undefined;
    businessUnitGaurdian!: BusinessUnitPrimaryDto;
    confidentialityId!: number | undefined;
    confidentiality!: DynamicPropertyValue;
    integrityId!: number | undefined;
    integrity!: DynamicPropertyValue;
    availibilityId!: number | undefined;
    availibility!: DynamicPropertyValue;
    othersId!: number | undefined;
    others!: DynamicPropertyValue;
    id!: number;

    constructor(data?: IGetFacilitiesDatacenterListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.facilityId = _data["facilityId"];
            this.facilityName = _data["facilityName"];
            this.facilityAddressOne = _data["facilityAddressOne"];
            this.facilityAddressTwo = _data["facilityAddressTwo"];
            this.facilityTypeId = _data["facilityTypeId"];
            this.facilityType = _data["facilityType"] ? DynamicPropertyValue.fromJS(_data["facilityType"]) : <any>undefined;
            this.state = _data["state"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? DynamicPropertyValue.fromJS(_data["country"]) : <any>undefined;
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationForEditDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.businessUnitOwnerId = _data["businessUnitOwnerId"];
            this.businessUnitOwner = _data["businessUnitOwner"] ? BusinessUnitPrimaryDto.fromJS(_data["businessUnitOwner"]) : <any>undefined;
            this.businessUnitGaurdianId = _data["businessUnitGaurdianId"];
            this.businessUnitGaurdian = _data["businessUnitGaurdian"] ? BusinessUnitPrimaryDto.fromJS(_data["businessUnitGaurdian"]) : <any>undefined;
            this.confidentialityId = _data["confidentialityId"];
            this.confidentiality = _data["confidentiality"] ? DynamicPropertyValue.fromJS(_data["confidentiality"]) : <any>undefined;
            this.integrityId = _data["integrityId"];
            this.integrity = _data["integrity"] ? DynamicPropertyValue.fromJS(_data["integrity"]) : <any>undefined;
            this.availibilityId = _data["availibilityId"];
            this.availibility = _data["availibility"] ? DynamicPropertyValue.fromJS(_data["availibility"]) : <any>undefined;
            this.othersId = _data["othersId"];
            this.others = _data["others"] ? DynamicPropertyValue.fromJS(_data["others"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetFacilitiesDatacenterListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetFacilitiesDatacenterListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["facilityId"] = this.facilityId;
        data["facilityName"] = this.facilityName;
        data["facilityAddressOne"] = this.facilityAddressOne;
        data["facilityAddressTwo"] = this.facilityAddressTwo;
        data["facilityTypeId"] = this.facilityTypeId;
        data["facilityType"] = this.facilityType ? this.facilityType.toJSON() : <any>undefined;
        data["state"] = this.state;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["businessUnitOwnerId"] = this.businessUnitOwnerId;
        data["businessUnitOwner"] = this.businessUnitOwner ? this.businessUnitOwner.toJSON() : <any>undefined;
        data["businessUnitGaurdianId"] = this.businessUnitGaurdianId;
        data["businessUnitGaurdian"] = this.businessUnitGaurdian ? this.businessUnitGaurdian.toJSON() : <any>undefined;
        data["confidentialityId"] = this.confidentialityId;
        data["confidentiality"] = this.confidentiality ? this.confidentiality.toJSON() : <any>undefined;
        data["integrityId"] = this.integrityId;
        data["integrity"] = this.integrity ? this.integrity.toJSON() : <any>undefined;
        data["availibilityId"] = this.availibilityId;
        data["availibility"] = this.availibility ? this.availibility.toJSON() : <any>undefined;
        data["othersId"] = this.othersId;
        data["others"] = this.others ? this.others.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetFacilitiesDatacenterListDto {
    tenantId: number | undefined;
    facilityId: string | undefined;
    facilityName: string | undefined;
    facilityAddressOne: string | undefined;
    facilityAddressTwo: string | undefined;
    facilityTypeId: number | undefined;
    facilityType: DynamicPropertyValue;
    state: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    countryId: number | undefined;
    country: DynamicPropertyValue;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationForEditDto;
    businessUnitOwnerId: number | undefined;
    businessUnitOwner: BusinessUnitPrimaryDto;
    businessUnitGaurdianId: number | undefined;
    businessUnitGaurdian: BusinessUnitPrimaryDto;
    confidentialityId: number | undefined;
    confidentiality: DynamicPropertyValue;
    integrityId: number | undefined;
    integrity: DynamicPropertyValue;
    availibilityId: number | undefined;
    availibility: DynamicPropertyValue;
    othersId: number | undefined;
    others: DynamicPropertyValue;
    id: number;
}

export class PagedResultDtoOfGetFacilitiesDatacenterListDto implements IPagedResultDtoOfGetFacilitiesDatacenterListDto {
    totalCount!: number;
    items!: GetFacilitiesDatacenterListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetFacilitiesDatacenterListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetFacilitiesDatacenterListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetFacilitiesDatacenterListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetFacilitiesDatacenterListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetFacilitiesDatacenterListDto {
    totalCount: number;
    items: GetFacilitiesDatacenterListDto[] | undefined;
}

export class StorageUri implements IStorageUri {
    primaryUri!: string | undefined;
    secondaryUri!: string | undefined;

    constructor(data?: IStorageUri) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.primaryUri = _data["primaryUri"];
            this.secondaryUri = _data["secondaryUri"];
        }
    }

    static fromJS(data: any): StorageUri {
        data = typeof data === 'object' ? data : {};
        let result = new StorageUri();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primaryUri"] = this.primaryUri;
        data["secondaryUri"] = this.secondaryUri;
        return data; 
    }
}

export interface IStorageUri {
    primaryUri: string | undefined;
    secondaryUri: string | undefined;
}

export class StorageCredentials implements IStorageCredentials {
    sasToken!: string | undefined;
    accountName!: string | undefined;
    keyName!: string | undefined;
    readonly isAnonymous!: boolean;
    readonly isSAS!: boolean;
    readonly isSharedKey!: boolean;
    readonly isToken!: boolean;
    readonly sasSignature!: string | undefined;

    constructor(data?: IStorageCredentials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sasToken = _data["sasToken"];
            this.accountName = _data["accountName"];
            this.keyName = _data["keyName"];
            (<any>this).isAnonymous = _data["isAnonymous"];
            (<any>this).isSAS = _data["isSAS"];
            (<any>this).isSharedKey = _data["isSharedKey"];
            (<any>this).isToken = _data["isToken"];
            (<any>this).sasSignature = _data["sasSignature"];
        }
    }

    static fromJS(data: any): StorageCredentials {
        data = typeof data === 'object' ? data : {};
        let result = new StorageCredentials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sasToken"] = this.sasToken;
        data["accountName"] = this.accountName;
        data["keyName"] = this.keyName;
        data["isAnonymous"] = this.isAnonymous;
        data["isSAS"] = this.isSAS;
        data["isSharedKey"] = this.isSharedKey;
        data["isToken"] = this.isToken;
        data["sasSignature"] = this.sasSignature;
        return data; 
    }
}

export interface IStorageCredentials {
    sasToken: string | undefined;
    accountName: string | undefined;
    keyName: string | undefined;
    isAnonymous: boolean;
    isSAS: boolean;
    isSharedKey: boolean;
    isToken: boolean;
    sasSignature: string | undefined;
}

export class CloudStorageAccount implements ICloudStorageAccount {
    blobEndpoint!: string | undefined;
    queueEndpoint!: string | undefined;
    tableEndpoint!: string | undefined;
    fileEndpoint!: string | undefined;
    blobStorageUri!: StorageUri;
    queueStorageUri!: StorageUri;
    tableStorageUri!: StorageUri;
    fileStorageUri!: StorageUri;
    credentials!: StorageCredentials;

    constructor(data?: ICloudStorageAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blobEndpoint = _data["blobEndpoint"];
            this.queueEndpoint = _data["queueEndpoint"];
            this.tableEndpoint = _data["tableEndpoint"];
            this.fileEndpoint = _data["fileEndpoint"];
            this.blobStorageUri = _data["blobStorageUri"] ? StorageUri.fromJS(_data["blobStorageUri"]) : <any>undefined;
            this.queueStorageUri = _data["queueStorageUri"] ? StorageUri.fromJS(_data["queueStorageUri"]) : <any>undefined;
            this.tableStorageUri = _data["tableStorageUri"] ? StorageUri.fromJS(_data["tableStorageUri"]) : <any>undefined;
            this.fileStorageUri = _data["fileStorageUri"] ? StorageUri.fromJS(_data["fileStorageUri"]) : <any>undefined;
            this.credentials = _data["credentials"] ? StorageCredentials.fromJS(_data["credentials"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CloudStorageAccount {
        data = typeof data === 'object' ? data : {};
        let result = new CloudStorageAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blobEndpoint"] = this.blobEndpoint;
        data["queueEndpoint"] = this.queueEndpoint;
        data["tableEndpoint"] = this.tableEndpoint;
        data["fileEndpoint"] = this.fileEndpoint;
        data["blobStorageUri"] = this.blobStorageUri ? this.blobStorageUri.toJSON() : <any>undefined;
        data["queueStorageUri"] = this.queueStorageUri ? this.queueStorageUri.toJSON() : <any>undefined;
        data["tableStorageUri"] = this.tableStorageUri ? this.tableStorageUri.toJSON() : <any>undefined;
        data["fileStorageUri"] = this.fileStorageUri ? this.fileStorageUri.toJSON() : <any>undefined;
        data["credentials"] = this.credentials ? this.credentials.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICloudStorageAccount {
    blobEndpoint: string | undefined;
    queueEndpoint: string | undefined;
    tableEndpoint: string | undefined;
    fileEndpoint: string | undefined;
    blobStorageUri: StorageUri;
    queueStorageUri: StorageUri;
    tableStorageUri: StorageUri;
    fileStorageUri: StorageUri;
    credentials: StorageCredentials;
}

export class IBufferManager implements IIBufferManager {

    constructor(data?: IIBufferManager) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IBufferManager {
        data = typeof data === 'object' ? data : {};
        let result = new IBufferManager();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIBufferManager {
}

export class IRetryPolicy implements IIRetryPolicy {

    constructor(data?: IIRetryPolicy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IRetryPolicy {
        data = typeof data === 'object' ? data : {};
        let result = new IRetryPolicy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIRetryPolicy {
}

export enum LocationMode {
    PrimaryOnly = 0,
    PrimaryThenSecondary = 1,
    SecondaryOnly = 2,
    SecondaryThenPrimary = 3,
}

export class BlobRequestOptions implements IBlobRequestOptions {
    retryPolicy!: IRetryPolicy;
    absorbConditionalErrorsOnRetry!: boolean | undefined;
    locationMode!: LocationMode;
    serverTimeout!: string | undefined;
    maximumExecutionTime!: string | undefined;
    parallelOperationThreadCount!: number | undefined;
    singleBlobUploadThresholdInBytes!: number | undefined;
    useTransactionalMD5!: boolean | undefined;
    storeBlobContentMD5!: boolean | undefined;
    disableContentMD5Validation!: boolean | undefined;

    constructor(data?: IBlobRequestOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.retryPolicy = _data["retryPolicy"] ? IRetryPolicy.fromJS(_data["retryPolicy"]) : <any>undefined;
            this.absorbConditionalErrorsOnRetry = _data["absorbConditionalErrorsOnRetry"];
            this.locationMode = _data["locationMode"];
            this.serverTimeout = _data["serverTimeout"];
            this.maximumExecutionTime = _data["maximumExecutionTime"];
            this.parallelOperationThreadCount = _data["parallelOperationThreadCount"];
            this.singleBlobUploadThresholdInBytes = _data["singleBlobUploadThresholdInBytes"];
            this.useTransactionalMD5 = _data["useTransactionalMD5"];
            this.storeBlobContentMD5 = _data["storeBlobContentMD5"];
            this.disableContentMD5Validation = _data["disableContentMD5Validation"];
        }
    }

    static fromJS(data: any): BlobRequestOptions {
        data = typeof data === 'object' ? data : {};
        let result = new BlobRequestOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retryPolicy"] = this.retryPolicy ? this.retryPolicy.toJSON() : <any>undefined;
        data["absorbConditionalErrorsOnRetry"] = this.absorbConditionalErrorsOnRetry;
        data["locationMode"] = this.locationMode;
        data["serverTimeout"] = this.serverTimeout;
        data["maximumExecutionTime"] = this.maximumExecutionTime;
        data["parallelOperationThreadCount"] = this.parallelOperationThreadCount;
        data["singleBlobUploadThresholdInBytes"] = this.singleBlobUploadThresholdInBytes;
        data["useTransactionalMD5"] = this.useTransactionalMD5;
        data["storeBlobContentMD5"] = this.storeBlobContentMD5;
        data["disableContentMD5Validation"] = this.disableContentMD5Validation;
        return data; 
    }
}

export interface IBlobRequestOptions {
    retryPolicy: IRetryPolicy;
    absorbConditionalErrorsOnRetry: boolean | undefined;
    locationMode: LocationMode;
    serverTimeout: string | undefined;
    maximumExecutionTime: string | undefined;
    parallelOperationThreadCount: number | undefined;
    singleBlobUploadThresholdInBytes: number | undefined;
    useTransactionalMD5: boolean | undefined;
    storeBlobContentMD5: boolean | undefined;
    disableContentMD5Validation: boolean | undefined;
}

export enum AuthenticationScheme {
    SharedKeyLite = 0,
    SharedKey = 1,
    Token = 2,
}

export class CloudBlobClient implements ICloudBlobClient {
    bufferManager!: IBufferManager;
    credentials!: StorageCredentials;
    baseUri!: string | undefined;
    storageUri!: StorageUri;
    defaultRequestOptions!: BlobRequestOptions;
    retryPolicy!: IRetryPolicy;
    defaultDelimiter!: string | undefined;
    authenticationScheme!: AuthenticationScheme;

    constructor(data?: ICloudBlobClient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bufferManager = _data["bufferManager"] ? IBufferManager.fromJS(_data["bufferManager"]) : <any>undefined;
            this.credentials = _data["credentials"] ? StorageCredentials.fromJS(_data["credentials"]) : <any>undefined;
            this.baseUri = _data["baseUri"];
            this.storageUri = _data["storageUri"] ? StorageUri.fromJS(_data["storageUri"]) : <any>undefined;
            this.defaultRequestOptions = _data["defaultRequestOptions"] ? BlobRequestOptions.fromJS(_data["defaultRequestOptions"]) : <any>undefined;
            this.retryPolicy = _data["retryPolicy"] ? IRetryPolicy.fromJS(_data["retryPolicy"]) : <any>undefined;
            this.defaultDelimiter = _data["defaultDelimiter"];
            this.authenticationScheme = _data["authenticationScheme"];
        }
    }

    static fromJS(data: any): CloudBlobClient {
        data = typeof data === 'object' ? data : {};
        let result = new CloudBlobClient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bufferManager"] = this.bufferManager ? this.bufferManager.toJSON() : <any>undefined;
        data["credentials"] = this.credentials ? this.credentials.toJSON() : <any>undefined;
        data["baseUri"] = this.baseUri;
        data["storageUri"] = this.storageUri ? this.storageUri.toJSON() : <any>undefined;
        data["defaultRequestOptions"] = this.defaultRequestOptions ? this.defaultRequestOptions.toJSON() : <any>undefined;
        data["retryPolicy"] = this.retryPolicy ? this.retryPolicy.toJSON() : <any>undefined;
        data["defaultDelimiter"] = this.defaultDelimiter;
        data["authenticationScheme"] = this.authenticationScheme;
        return data; 
    }
}

export interface ICloudBlobClient {
    bufferManager: IBufferManager;
    credentials: StorageCredentials;
    baseUri: string | undefined;
    storageUri: StorageUri;
    defaultRequestOptions: BlobRequestOptions;
    retryPolicy: IRetryPolicy;
    defaultDelimiter: string | undefined;
    authenticationScheme: AuthenticationScheme;
}

export enum LeaseStatus {
    Unspecified = 0,
    Locked = 1,
    Unlocked = 2,
}

export enum LeaseState {
    Unspecified = 0,
    Available = 1,
    Leased = 2,
    Expired = 3,
    Breaking = 4,
    Broken = 5,
}

export enum LeaseDuration {
    Unspecified = 0,
    Fixed = 1,
    Infinite = 2,
}

export enum BlobContainerPublicAccessType {
    Off = 0,
    Container = 1,
    Blob = 2,
    Unknown = 3,
}

export class BlobContainerProperties implements IBlobContainerProperties {
    readonly eTag!: string | undefined;
    readonly hasImmutabilityPolicy!: boolean | undefined;
    readonly hasLegalHold!: boolean | undefined;
    readonly lastModified!: DateTime | undefined;
    leaseStatus!: LeaseStatus;
    leaseState!: LeaseState;
    leaseDuration!: LeaseDuration;
    publicAccess!: BlobContainerPublicAccessType;

    constructor(data?: IBlobContainerProperties) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).eTag = _data["eTag"];
            (<any>this).hasImmutabilityPolicy = _data["hasImmutabilityPolicy"];
            (<any>this).hasLegalHold = _data["hasLegalHold"];
            (<any>this).lastModified = _data["lastModified"] ? DateTime.fromISO(_data["lastModified"].toString()) : <any>undefined;
            this.leaseStatus = _data["leaseStatus"];
            this.leaseState = _data["leaseState"];
            this.leaseDuration = _data["leaseDuration"];
            this.publicAccess = _data["publicAccess"];
        }
    }

    static fromJS(data: any): BlobContainerProperties {
        data = typeof data === 'object' ? data : {};
        let result = new BlobContainerProperties();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eTag"] = this.eTag;
        data["hasImmutabilityPolicy"] = this.hasImmutabilityPolicy;
        data["hasLegalHold"] = this.hasLegalHold;
        data["lastModified"] = this.lastModified ? this.lastModified.toString() : <any>undefined;
        data["leaseStatus"] = this.leaseStatus;
        data["leaseState"] = this.leaseState;
        data["leaseDuration"] = this.leaseDuration;
        data["publicAccess"] = this.publicAccess;
        return data; 
    }
}

export interface IBlobContainerProperties {
    eTag: string | undefined;
    hasImmutabilityPolicy: boolean | undefined;
    hasLegalHold: boolean | undefined;
    lastModified: DateTime | undefined;
    leaseStatus: LeaseStatus;
    leaseState: LeaseState;
    leaseDuration: LeaseDuration;
    publicAccess: BlobContainerPublicAccessType;
}

export class CloudBlobContainer implements ICloudBlobContainer {
    serviceClient!: CloudBlobClient;
    readonly uri!: string | undefined;
    storageUri!: StorageUri;
    readonly name!: string | undefined;
    readonly metadata!: { [key: string]: string; } | undefined;
    properties!: BlobContainerProperties;

    constructor(data?: ICloudBlobContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceClient = _data["serviceClient"] ? CloudBlobClient.fromJS(_data["serviceClient"]) : <any>undefined;
            (<any>this).uri = _data["uri"];
            this.storageUri = _data["storageUri"] ? StorageUri.fromJS(_data["storageUri"]) : <any>undefined;
            (<any>this).name = _data["name"];
            if (_data["metadata"]) {
                (<any>this).metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this).metadata![key] = _data["metadata"][key];
                }
            }
            this.properties = _data["properties"] ? BlobContainerProperties.fromJS(_data["properties"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CloudBlobContainer {
        data = typeof data === 'object' ? data : {};
        let result = new CloudBlobContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceClient"] = this.serviceClient ? this.serviceClient.toJSON() : <any>undefined;
        data["uri"] = this.uri;
        data["storageUri"] = this.storageUri ? this.storageUri.toJSON() : <any>undefined;
        data["name"] = this.name;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    data["metadata"][key] = this.metadata[key];
            }
        }
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICloudBlobContainer {
    serviceClient: CloudBlobClient;
    uri: string | undefined;
    storageUri: StorageUri;
    name: string | undefined;
    metadata: { [key: string]: string; } | undefined;
    properties: BlobContainerProperties;
}

export class UploadFileDto implements IUploadFileDto {
    base64!: string | undefined;
    fileName!: string | undefined;

    constructor(data?: IUploadFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64 = _data["base64"];
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): UploadFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64"] = this.base64;
        data["fileName"] = this.fileName;
        return data; 
    }
}

export interface IUploadFileDto {
    base64: string | undefined;
    fileName: string | undefined;
}

export class MemoryStream implements IMemoryStream {
    readonly canRead!: boolean;
    readonly canSeek!: boolean;
    readonly canWrite!: boolean;
    capacity!: number;
    readonly length!: number;
    position!: number;
    readonly canTimeout!: boolean;
    readTimeout!: number;
    writeTimeout!: number;

    constructor(data?: IMemoryStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).canRead = _data["canRead"];
            (<any>this).canSeek = _data["canSeek"];
            (<any>this).canWrite = _data["canWrite"];
            this.capacity = _data["capacity"];
            (<any>this).length = _data["length"];
            this.position = _data["position"];
            (<any>this).canTimeout = _data["canTimeout"];
            this.readTimeout = _data["readTimeout"];
            this.writeTimeout = _data["writeTimeout"];
        }
    }

    static fromJS(data: any): MemoryStream {
        data = typeof data === 'object' ? data : {};
        let result = new MemoryStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canRead"] = this.canRead;
        data["canSeek"] = this.canSeek;
        data["canWrite"] = this.canWrite;
        data["capacity"] = this.capacity;
        data["length"] = this.length;
        data["position"] = this.position;
        data["canTimeout"] = this.canTimeout;
        data["readTimeout"] = this.readTimeout;
        data["writeTimeout"] = this.writeTimeout;
        return data; 
    }
}

export interface IMemoryStream {
    canRead: boolean;
    canSeek: boolean;
    canWrite: boolean;
    capacity: number;
    length: number;
    position: number;
    canTimeout: boolean;
    readTimeout: number;
    writeTimeout: number;
}

export class TupleOfMemoryStreamString implements ITupleOfMemoryStreamString {
    item1!: MemoryStream;
    item2!: string | undefined;

    constructor(data?: ITupleOfMemoryStreamString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"] ? MemoryStream.fromJS(_data["item1"]) : <any>undefined;
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any): TupleOfMemoryStreamString {
        data = typeof data === 'object' ? data : {};
        let result = new TupleOfMemoryStreamString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1 ? this.item1.toJSON() : <any>undefined;
        data["item2"] = this.item2;
        return data; 
    }
}

export interface ITupleOfMemoryStreamString {
    item1: MemoryStream;
    item2: string | undefined;
}

export class FindingListDto implements IFindingListDto {
    tenantId!: number | undefined;
    findingId!: string | undefined;
    findingTitle!: string | undefined;
    findingDetails!: string | undefined;
    dateCreated!: DateTime | undefined;
    categoryId!: number | undefined;
    category!: DynamicPropertyValue;
    categoryOther!: string | undefined;
    findingStatusId!: number | undefined;
    findingStatus!: DynamicPropertyValue;
    rankingId!: number | undefined;
    ranking!: DynamicPropertyValue;
    classificationId!: number | undefined;
    classification!: DynamicPropertyValue;
    findingManagerId!: number | undefined;
    findingManager!: BusinessServiceOwner;
    findingCoordinatorId!: number | undefined;
    findingCoordinator!: BusinessServiceOwner;
    findingOwnerId!: number | undefined;
    findingOwner!: BusinessServiceOwner;
    criteria!: string | undefined;
    cause!: string | undefined;
    condition!: string | undefined;
    consequence!: string | undefined;
    actionId!: number | undefined;
    action!: DynamicPropertyValue;
    reviewedId!: number | undefined;
    reviewed!: BusinessServiceOwner;
    responseId!: number | undefined;
    response!: DynamicPropertyValue;
    potentialCost!: number | undefined;
    assignedId!: number | undefined;
    assigned!: BusinessServiceOwner;
    id!: number;

    constructor(data?: IFindingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.findingId = _data["findingId"];
            this.findingTitle = _data["findingTitle"];
            this.findingDetails = _data["findingDetails"];
            this.dateCreated = _data["dateCreated"] ? DateTime.fromISO(_data["dateCreated"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? DynamicPropertyValue.fromJS(_data["category"]) : <any>undefined;
            this.categoryOther = _data["categoryOther"];
            this.findingStatusId = _data["findingStatusId"];
            this.findingStatus = _data["findingStatus"] ? DynamicPropertyValue.fromJS(_data["findingStatus"]) : <any>undefined;
            this.rankingId = _data["rankingId"];
            this.ranking = _data["ranking"] ? DynamicPropertyValue.fromJS(_data["ranking"]) : <any>undefined;
            this.classificationId = _data["classificationId"];
            this.classification = _data["classification"] ? DynamicPropertyValue.fromJS(_data["classification"]) : <any>undefined;
            this.findingManagerId = _data["findingManagerId"];
            this.findingManager = _data["findingManager"] ? BusinessServiceOwner.fromJS(_data["findingManager"]) : <any>undefined;
            this.findingCoordinatorId = _data["findingCoordinatorId"];
            this.findingCoordinator = _data["findingCoordinator"] ? BusinessServiceOwner.fromJS(_data["findingCoordinator"]) : <any>undefined;
            this.findingOwnerId = _data["findingOwnerId"];
            this.findingOwner = _data["findingOwner"] ? BusinessServiceOwner.fromJS(_data["findingOwner"]) : <any>undefined;
            this.criteria = _data["criteria"];
            this.cause = _data["cause"];
            this.condition = _data["condition"];
            this.consequence = _data["consequence"];
            this.actionId = _data["actionId"];
            this.action = _data["action"] ? DynamicPropertyValue.fromJS(_data["action"]) : <any>undefined;
            this.reviewedId = _data["reviewedId"];
            this.reviewed = _data["reviewed"] ? BusinessServiceOwner.fromJS(_data["reviewed"]) : <any>undefined;
            this.responseId = _data["responseId"];
            this.response = _data["response"] ? DynamicPropertyValue.fromJS(_data["response"]) : <any>undefined;
            this.potentialCost = _data["potentialCost"];
            this.assignedId = _data["assignedId"];
            this.assigned = _data["assigned"] ? BusinessServiceOwner.fromJS(_data["assigned"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FindingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["findingId"] = this.findingId;
        data["findingTitle"] = this.findingTitle;
        data["findingDetails"] = this.findingDetails;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["categoryOther"] = this.categoryOther;
        data["findingStatusId"] = this.findingStatusId;
        data["findingStatus"] = this.findingStatus ? this.findingStatus.toJSON() : <any>undefined;
        data["rankingId"] = this.rankingId;
        data["ranking"] = this.ranking ? this.ranking.toJSON() : <any>undefined;
        data["classificationId"] = this.classificationId;
        data["classification"] = this.classification ? this.classification.toJSON() : <any>undefined;
        data["findingManagerId"] = this.findingManagerId;
        data["findingManager"] = this.findingManager ? this.findingManager.toJSON() : <any>undefined;
        data["findingCoordinatorId"] = this.findingCoordinatorId;
        data["findingCoordinator"] = this.findingCoordinator ? this.findingCoordinator.toJSON() : <any>undefined;
        data["findingOwnerId"] = this.findingOwnerId;
        data["findingOwner"] = this.findingOwner ? this.findingOwner.toJSON() : <any>undefined;
        data["criteria"] = this.criteria;
        data["cause"] = this.cause;
        data["condition"] = this.condition;
        data["consequence"] = this.consequence;
        data["actionId"] = this.actionId;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["reviewedId"] = this.reviewedId;
        data["reviewed"] = this.reviewed ? this.reviewed.toJSON() : <any>undefined;
        data["responseId"] = this.responseId;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        data["potentialCost"] = this.potentialCost;
        data["assignedId"] = this.assignedId;
        data["assigned"] = this.assigned ? this.assigned.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IFindingListDto {
    tenantId: number | undefined;
    findingId: string | undefined;
    findingTitle: string | undefined;
    findingDetails: string | undefined;
    dateCreated: DateTime | undefined;
    categoryId: number | undefined;
    category: DynamicPropertyValue;
    categoryOther: string | undefined;
    findingStatusId: number | undefined;
    findingStatus: DynamicPropertyValue;
    rankingId: number | undefined;
    ranking: DynamicPropertyValue;
    classificationId: number | undefined;
    classification: DynamicPropertyValue;
    findingManagerId: number | undefined;
    findingManager: BusinessServiceOwner;
    findingCoordinatorId: number | undefined;
    findingCoordinator: BusinessServiceOwner;
    findingOwnerId: number | undefined;
    findingOwner: BusinessServiceOwner;
    criteria: string | undefined;
    cause: string | undefined;
    condition: string | undefined;
    consequence: string | undefined;
    actionId: number | undefined;
    action: DynamicPropertyValue;
    reviewedId: number | undefined;
    reviewed: BusinessServiceOwner;
    responseId: number | undefined;
    response: DynamicPropertyValue;
    potentialCost: number | undefined;
    assignedId: number | undefined;
    assigned: BusinessServiceOwner;
    id: number;
}

export class PagedResultDtoOfFindingListDto implements IPagedResultDtoOfFindingListDto {
    totalCount!: number;
    items!: FindingListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfFindingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FindingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfFindingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfFindingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfFindingListDto {
    totalCount: number;
    items: FindingListDto[] | undefined;
}

export class ProgramAuthoritativeDocumentsDto implements IProgramAuthoritativeDocumentsDto {
    grcProgramId!: number | undefined;
    authoratativeDocumentId!: number | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProgramAuthoritativeDocumentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grcProgramId = _data["grcProgramId"];
            this.authoratativeDocumentId = _data["authoratativeDocumentId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProgramAuthoritativeDocumentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramAuthoritativeDocumentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grcProgramId"] = this.grcProgramId;
        data["authoratativeDocumentId"] = this.authoratativeDocumentId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProgramAuthoritativeDocumentsDto {
    grcProgramId: number | undefined;
    authoratativeDocumentId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ControlDesignListDto implements IControlDesignListDto {
    id!: number;
    title!: string | undefined;

    constructor(data?: IControlDesignListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ControlDesignListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ControlDesignListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }
}

export interface IControlDesignListDto {
    id: number;
    title: string | undefined;
}

export class ControlOperatingListDto implements IControlOperatingListDto {
    id!: number;
    title!: string | undefined;

    constructor(data?: IControlOperatingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ControlOperatingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ControlOperatingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }
}

export interface IControlOperatingListDto {
    id: number;
    title: string | undefined;
}

export class HardwareAsseDetailListDto implements IHardwareAsseDetailListDto {
    id!: number;
    hardwareAssetName!: string | undefined;

    constructor(data?: IHardwareAsseDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hardwareAssetName = _data["hardwareAssetName"];
        }
    }

    static fromJS(data: any): HardwareAsseDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new HardwareAsseDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hardwareAssetName"] = this.hardwareAssetName;
        return data; 
    }
}

export interface IHardwareAsseDetailListDto {
    id: number;
    hardwareAssetName: string | undefined;
}

export class VirtualListDto implements IVirtualListDto {
    id!: number;
    virtualAssetName!: string | undefined;

    constructor(data?: IVirtualListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.virtualAssetName = _data["virtualAssetName"];
        }
    }

    static fromJS(data: any): VirtualListDto {
        data = typeof data === 'object' ? data : {};
        let result = new VirtualListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["virtualAssetName"] = this.virtualAssetName;
        return data; 
    }
}

export interface IVirtualListDto {
    id: number;
    virtualAssetName: string | undefined;
}

export class FindingIncidentListDto implements IFindingIncidentListDto {
    id!: number;
    incidentTitle!: string | undefined;

    constructor(data?: IFindingIncidentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.incidentTitle = _data["incidentTitle"];
        }
    }

    static fromJS(data: any): FindingIncidentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingIncidentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["incidentTitle"] = this.incidentTitle;
        return data; 
    }
}

export interface IFindingIncidentListDto {
    id: number;
    incidentTitle: string | undefined;
}

export class InternalControlListDto implements IInternalControlListDto {
    id!: number;
    icTitle!: string | undefined;

    constructor(data?: IInternalControlListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.icTitle = _data["icTitle"];
        }
    }

    static fromJS(data: any): InternalControlListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InternalControlListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["icTitle"] = this.icTitle;
        return data; 
    }
}

export interface IInternalControlListDto {
    id: number;
    icTitle: string | undefined;
}

export class StrategicObjectivesDto implements IStrategicObjectivesDto {
    id!: number;
    strategicObjectiveTitle!: string | undefined;

    constructor(data?: IStrategicObjectivesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.strategicObjectiveTitle = _data["strategicObjectiveTitle"];
        }
    }

    static fromJS(data: any): StrategicObjectivesDto {
        data = typeof data === 'object' ? data : {};
        let result = new StrategicObjectivesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["strategicObjectiveTitle"] = this.strategicObjectiveTitle;
        return data; 
    }
}

export interface IStrategicObjectivesDto {
    id: number;
    strategicObjectiveTitle: string | undefined;
}

export class RiskRegisterListDto implements IRiskRegisterListDto {
    id!: number;
    riskTitle!: string | undefined;

    constructor(data?: IRiskRegisterListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.riskTitle = _data["riskTitle"];
        }
    }

    static fromJS(data: any): RiskRegisterListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RiskRegisterListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["riskTitle"] = this.riskTitle;
        return data; 
    }
}

export interface IRiskRegisterListDto {
    id: number;
    riskTitle: string | undefined;
}

export class FindingAssetInformationDto implements IFindingAssetInformationDto {
    id!: number;
    findingId!: number | undefined;
    assetInformationId!: number | undefined;

    constructor(data?: IFindingAssetInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.assetInformationId = _data["assetInformationId"];
        }
    }

    static fromJS(data: any): FindingAssetInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingAssetInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["assetInformationId"] = this.assetInformationId;
        return data; 
    }
}

export interface IFindingAssetInformationDto {
    id: number;
    findingId: number | undefined;
    assetInformationId: number | undefined;
}

export class FindingAuthoratativeSourceDto implements IFindingAuthoratativeSourceDto {
    id!: number;
    findingId!: number | undefined;
    authoratativeDocumentId!: number | undefined;

    constructor(data?: IFindingAuthoratativeSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.authoratativeDocumentId = _data["authoratativeDocumentId"];
        }
    }

    static fromJS(data: any): FindingAuthoratativeSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingAuthoratativeSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["authoratativeDocumentId"] = this.authoratativeDocumentId;
        return data; 
    }
}

export interface IFindingAuthoratativeSourceDto {
    id: number;
    findingId: number | undefined;
    authoratativeDocumentId: number | undefined;
}

export class FindingBusinessUnitDto implements IFindingBusinessUnitDto {
    id!: number;
    findingId!: number | undefined;
    businessUnitId!: number | undefined;

    constructor(data?: IFindingBusinessUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.businessUnitId = _data["businessUnitId"];
        }
    }

    static fromJS(data: any): FindingBusinessUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingBusinessUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["businessUnitId"] = this.businessUnitId;
        return data; 
    }
}

export interface IFindingBusinessUnitDto {
    id: number;
    findingId: number | undefined;
    businessUnitId: number | undefined;
}

export class FindingControlDesignDto implements IFindingControlDesignDto {
    id!: number;
    findingId!: number | undefined;
    controlDesignsId!: number | undefined;

    constructor(data?: IFindingControlDesignDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.controlDesignsId = _data["controlDesignsId"];
        }
    }

    static fromJS(data: any): FindingControlDesignDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingControlDesignDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["controlDesignsId"] = this.controlDesignsId;
        return data; 
    }
}

export interface IFindingControlDesignDto {
    id: number;
    findingId: number | undefined;
    controlDesignsId: number | undefined;
}

export class FindingControlOperatingDto implements IFindingControlOperatingDto {
    id!: number;
    findingId!: number | undefined;
    controlOperatingTestId!: number | undefined;

    constructor(data?: IFindingControlOperatingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.controlOperatingTestId = _data["controlOperatingTestId"];
        }
    }

    static fromJS(data: any): FindingControlOperatingDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingControlOperatingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["controlOperatingTestId"] = this.controlOperatingTestId;
        return data; 
    }
}

export interface IFindingControlOperatingDto {
    id: number;
    findingId: number | undefined;
    controlOperatingTestId: number | undefined;
}

export class FindingFacilitieDatacenterDto implements IFindingFacilitieDatacenterDto {
    id!: number;
    findingId!: number | undefined;
    facilitieDatacenterId!: number | undefined;

    constructor(data?: IFindingFacilitieDatacenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.facilitieDatacenterId = _data["facilitieDatacenterId"];
        }
    }

    static fromJS(data: any): FindingFacilitieDatacenterDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingFacilitieDatacenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["facilitieDatacenterId"] = this.facilitieDatacenterId;
        return data; 
    }
}

export interface IFindingFacilitieDatacenterDto {
    id: number;
    findingId: number | undefined;
    facilitieDatacenterId: number | undefined;
}

export class FindingHardwareAssetDto implements IFindingHardwareAssetDto {
    id!: number;
    findingId!: number | undefined;
    hardwareAssetId!: number | undefined;

    constructor(data?: IFindingHardwareAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.hardwareAssetId = _data["hardwareAssetId"];
        }
    }

    static fromJS(data: any): FindingHardwareAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingHardwareAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["hardwareAssetId"] = this.hardwareAssetId;
        return data; 
    }
}

export interface IFindingHardwareAssetDto {
    id: number;
    findingId: number | undefined;
    hardwareAssetId: number | undefined;
}

export class FindingIncidentDto implements IFindingIncidentDto {
    id!: number;
    findingId!: number | undefined;
    incidentId!: number | undefined;

    constructor(data?: IFindingIncidentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.incidentId = _data["incidentId"];
        }
    }

    static fromJS(data: any): FindingIncidentDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingIncidentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["incidentId"] = this.incidentId;
        return data; 
    }
}

export interface IFindingIncidentDto {
    id: number;
    findingId: number | undefined;
    incidentId: number | undefined;
}

export class FindingInternalControlDto implements IFindingInternalControlDto {
    id!: number;
    findingId!: number | undefined;
    internalControlId!: number | undefined;

    constructor(data?: IFindingInternalControlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.internalControlId = _data["internalControlId"];
        }
    }

    static fromJS(data: any): FindingInternalControlDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingInternalControlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["internalControlId"] = this.internalControlId;
        return data; 
    }
}

export interface IFindingInternalControlDto {
    id: number;
    findingId: number | undefined;
    internalControlId: number | undefined;
}

export class FindingOrganizationDto implements IFindingOrganizationDto {
    id!: number;
    findingId!: number | undefined;
    lockThreatOrganizationId!: number | undefined;

    constructor(data?: IFindingOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
        }
    }

    static fromJS(data: any): FindingOrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingOrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        return data; 
    }
}

export interface IFindingOrganizationDto {
    id: number;
    findingId: number | undefined;
    lockThreatOrganizationId: number | undefined;
}

export class FindingRiskRegisterDto implements IFindingRiskRegisterDto {
    id!: number;
    findingId!: number | undefined;
    riskManagementId!: number | undefined;

    constructor(data?: IFindingRiskRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.riskManagementId = _data["riskManagementId"];
        }
    }

    static fromJS(data: any): FindingRiskRegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingRiskRegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["riskManagementId"] = this.riskManagementId;
        return data; 
    }
}

export interface IFindingRiskRegisterDto {
    id: number;
    findingId: number | undefined;
    riskManagementId: number | undefined;
}

export class FindingStrategicObjectiveDto implements IFindingStrategicObjectiveDto {
    id!: number;
    findingId!: number | undefined;
    strategicObjectiveId!: number | undefined;

    constructor(data?: IFindingStrategicObjectiveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.strategicObjectiveId = _data["strategicObjectiveId"];
        }
    }

    static fromJS(data: any): FindingStrategicObjectiveDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingStrategicObjectiveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["strategicObjectiveId"] = this.strategicObjectiveId;
        return data; 
    }
}

export interface IFindingStrategicObjectiveDto {
    id: number;
    findingId: number | undefined;
    strategicObjectiveId: number | undefined;
}

export class FindingSystemsApplicationDto implements IFindingSystemsApplicationDto {
    id!: number;
    findingId!: number | undefined;
    systemApplicationId!: number | undefined;

    constructor(data?: IFindingSystemsApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.systemApplicationId = _data["systemApplicationId"];
        }
    }

    static fromJS(data: any): FindingSystemsApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingSystemsApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["systemApplicationId"] = this.systemApplicationId;
        return data; 
    }
}

export interface IFindingSystemsApplicationDto {
    id: number;
    findingId: number | undefined;
    systemApplicationId: number | undefined;
}

export class FindingVendorDto implements IFindingVendorDto {
    id!: number;
    findingId!: number | undefined;
    vendorId!: number | undefined;

    constructor(data?: IFindingVendorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.vendorId = _data["vendorId"];
        }
    }

    static fromJS(data: any): FindingVendorDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingVendorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["vendorId"] = this.vendorId;
        return data; 
    }
}

export interface IFindingVendorDto {
    id: number;
    findingId: number | undefined;
    vendorId: number | undefined;
}

export class FindingVirtualHostDto implements IFindingVirtualHostDto {
    id!: number;
    findingId!: number | undefined;
    virtualAssetId!: number | undefined;

    constructor(data?: IFindingVirtualHostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.virtualAssetId = _data["virtualAssetId"];
        }
    }

    static fromJS(data: any): FindingVirtualHostDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingVirtualHostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["virtualAssetId"] = this.virtualAssetId;
        return data; 
    }
}

export interface IFindingVirtualHostDto {
    id: number;
    findingId: number | undefined;
    virtualAssetId: number | undefined;
}

export class FindingVirtualMachineDto implements IFindingVirtualMachineDto {
    id!: number;
    findingId!: number | undefined;
    virtualAssetId!: number | undefined;

    constructor(data?: IFindingVirtualMachineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.findingId = _data["findingId"];
            this.virtualAssetId = _data["virtualAssetId"];
        }
    }

    static fromJS(data: any): FindingVirtualMachineDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingVirtualMachineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["findingId"] = this.findingId;
        data["virtualAssetId"] = this.virtualAssetId;
        return data; 
    }
}

export interface IFindingVirtualMachineDto {
    id: number;
    findingId: number | undefined;
    virtualAssetId: number | undefined;
}

export class FindingInfoDto implements IFindingInfoDto {
    tenantId!: number | undefined;
    findingId!: string | undefined;
    findingTitle!: string | undefined;
    findingDetails!: string | undefined;
    dateCreated!: DateTime | undefined;
    categoryId!: number | undefined;
    categoryList!: GetDynamicValueDto[] | undefined;
    categoryOther!: string | undefined;
    findingStatusId!: number | undefined;
    findingStatusList!: GetDynamicValueDto[] | undefined;
    rankingId!: number | undefined;
    rankingList!: GetDynamicValueDto[] | undefined;
    classificationId!: number | undefined;
    classificationList!: GetDynamicValueDto[] | undefined;
    findingManagerId!: number | undefined;
    findingManagerList!: BusinessServiceOwner[] | undefined;
    findingCoordinatorId!: number | undefined;
    findingCoordinatorList!: BusinessServiceOwner[] | undefined;
    findingOwnerId!: number | undefined;
    findingOwnerList!: BusinessServiceOwner[] | undefined;
    criteria!: string | undefined;
    cause!: string | undefined;
    condition!: string | undefined;
    consequence!: string | undefined;
    actionId!: number | undefined;
    actionLsit!: GetDynamicValueDto[] | undefined;
    reviewedId!: number | undefined;
    reviewesList!: BusinessServiceOwner[] | undefined;
    responseId!: number | undefined;
    responses!: GetDynamicValueDto[] | undefined;
    potentialCost!: number | undefined;
    assignedId!: number | undefined;
    assignedList!: BusinessServiceOwner[] | undefined;
    authoritativeSourceList!: ProgramAuthoritativeDocumentsDto[] | undefined;
    assetInformationList!: AssetInformationListDto[] | undefined;
    businessUnitList!: BusinessUnitGaurdianDto[] | undefined;
    companyList!: GetOrganizationDto[] | undefined;
    controlDesignList!: ControlDesignListDto[] | undefined;
    controlOperatingList!: ControlOperatingListDto[] | undefined;
    facilitieDatacenterList!: FacilitieDatacenterListDto[] | undefined;
    hardwareAssetList!: HardwareAsseDetailListDto[] | undefined;
    virtualHostList!: VirtualListDto[] | undefined;
    virtualMachineList!: VirtualListDto[] | undefined;
    sytemApplicationList!: SytemApplicationDto[] | undefined;
    findingIncidentList!: FindingIncidentListDto[] | undefined;
    internalControlList!: InternalControlListDto[] | undefined;
    vendorList!: VendorListDto[] | undefined;
    strategicObjectiveList!: StrategicObjectivesDto[] | undefined;
    riskRegisterList!: RiskRegisterListDto[] | undefined;
    selectedFindingAssetInformations!: FindingAssetInformationDto[] | undefined;
    selectedFindingAuthoratativeSources!: FindingAuthoratativeSourceDto[] | undefined;
    selectedFindingBusinessUnits!: FindingBusinessUnitDto[] | undefined;
    selectedFindingControlDesigns!: FindingControlDesignDto[] | undefined;
    selectedFindingControlOperatings!: FindingControlOperatingDto[] | undefined;
    selectedFindingFacilitieDatacenters!: FindingFacilitieDatacenterDto[] | undefined;
    selectedFindingHardwareAssets!: FindingHardwareAssetDto[] | undefined;
    selectedFindingIncidents!: FindingIncidentDto[] | undefined;
    selectedFindingInternalControls!: FindingInternalControlDto[] | undefined;
    selectedFindingOrganizations!: FindingOrganizationDto[] | undefined;
    selectedFindingRiskRegisters!: FindingRiskRegisterDto[] | undefined;
    selectedFindingStrategicObjectives!: FindingStrategicObjectiveDto[] | undefined;
    selectedFindingSystemsApplications!: FindingSystemsApplicationDto[] | undefined;
    selectedFindingVendors!: FindingVendorDto[] | undefined;
    selectedFindingVirtualHosts!: FindingVirtualHostDto[] | undefined;
    selectedFindingVirtualMachines!: FindingVirtualMachineDto[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IFindingInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.findingId = _data["findingId"];
            this.findingTitle = _data["findingTitle"];
            this.findingDetails = _data["findingDetails"];
            this.dateCreated = _data["dateCreated"] ? DateTime.fromISO(_data["dateCreated"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["categoryList"])) {
                this.categoryList = [] as any;
                for (let item of _data["categoryList"])
                    this.categoryList!.push(GetDynamicValueDto.fromJS(item));
            }
            this.categoryOther = _data["categoryOther"];
            this.findingStatusId = _data["findingStatusId"];
            if (Array.isArray(_data["findingStatusList"])) {
                this.findingStatusList = [] as any;
                for (let item of _data["findingStatusList"])
                    this.findingStatusList!.push(GetDynamicValueDto.fromJS(item));
            }
            this.rankingId = _data["rankingId"];
            if (Array.isArray(_data["rankingList"])) {
                this.rankingList = [] as any;
                for (let item of _data["rankingList"])
                    this.rankingList!.push(GetDynamicValueDto.fromJS(item));
            }
            this.classificationId = _data["classificationId"];
            if (Array.isArray(_data["classificationList"])) {
                this.classificationList = [] as any;
                for (let item of _data["classificationList"])
                    this.classificationList!.push(GetDynamicValueDto.fromJS(item));
            }
            this.findingManagerId = _data["findingManagerId"];
            if (Array.isArray(_data["findingManagerList"])) {
                this.findingManagerList = [] as any;
                for (let item of _data["findingManagerList"])
                    this.findingManagerList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.findingCoordinatorId = _data["findingCoordinatorId"];
            if (Array.isArray(_data["findingCoordinatorList"])) {
                this.findingCoordinatorList = [] as any;
                for (let item of _data["findingCoordinatorList"])
                    this.findingCoordinatorList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.findingOwnerId = _data["findingOwnerId"];
            if (Array.isArray(_data["findingOwnerList"])) {
                this.findingOwnerList = [] as any;
                for (let item of _data["findingOwnerList"])
                    this.findingOwnerList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.criteria = _data["criteria"];
            this.cause = _data["cause"];
            this.condition = _data["condition"];
            this.consequence = _data["consequence"];
            this.actionId = _data["actionId"];
            if (Array.isArray(_data["actionLsit"])) {
                this.actionLsit = [] as any;
                for (let item of _data["actionLsit"])
                    this.actionLsit!.push(GetDynamicValueDto.fromJS(item));
            }
            this.reviewedId = _data["reviewedId"];
            if (Array.isArray(_data["reviewesList"])) {
                this.reviewesList = [] as any;
                for (let item of _data["reviewesList"])
                    this.reviewesList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.responseId = _data["responseId"];
            if (Array.isArray(_data["responses"])) {
                this.responses = [] as any;
                for (let item of _data["responses"])
                    this.responses!.push(GetDynamicValueDto.fromJS(item));
            }
            this.potentialCost = _data["potentialCost"];
            this.assignedId = _data["assignedId"];
            if (Array.isArray(_data["assignedList"])) {
                this.assignedList = [] as any;
                for (let item of _data["assignedList"])
                    this.assignedList!.push(BusinessServiceOwner.fromJS(item));
            }
            if (Array.isArray(_data["authoritativeSourceList"])) {
                this.authoritativeSourceList = [] as any;
                for (let item of _data["authoritativeSourceList"])
                    this.authoritativeSourceList!.push(ProgramAuthoritativeDocumentsDto.fromJS(item));
            }
            if (Array.isArray(_data["assetInformationList"])) {
                this.assetInformationList = [] as any;
                for (let item of _data["assetInformationList"])
                    this.assetInformationList!.push(AssetInformationListDto.fromJS(item));
            }
            if (Array.isArray(_data["businessUnitList"])) {
                this.businessUnitList = [] as any;
                for (let item of _data["businessUnitList"])
                    this.businessUnitList!.push(BusinessUnitGaurdianDto.fromJS(item));
            }
            if (Array.isArray(_data["companyList"])) {
                this.companyList = [] as any;
                for (let item of _data["companyList"])
                    this.companyList!.push(GetOrganizationDto.fromJS(item));
            }
            if (Array.isArray(_data["controlDesignList"])) {
                this.controlDesignList = [] as any;
                for (let item of _data["controlDesignList"])
                    this.controlDesignList!.push(ControlDesignListDto.fromJS(item));
            }
            if (Array.isArray(_data["controlOperatingList"])) {
                this.controlOperatingList = [] as any;
                for (let item of _data["controlOperatingList"])
                    this.controlOperatingList!.push(ControlOperatingListDto.fromJS(item));
            }
            if (Array.isArray(_data["facilitieDatacenterList"])) {
                this.facilitieDatacenterList = [] as any;
                for (let item of _data["facilitieDatacenterList"])
                    this.facilitieDatacenterList!.push(FacilitieDatacenterListDto.fromJS(item));
            }
            if (Array.isArray(_data["hardwareAssetList"])) {
                this.hardwareAssetList = [] as any;
                for (let item of _data["hardwareAssetList"])
                    this.hardwareAssetList!.push(HardwareAsseDetailListDto.fromJS(item));
            }
            if (Array.isArray(_data["virtualHostList"])) {
                this.virtualHostList = [] as any;
                for (let item of _data["virtualHostList"])
                    this.virtualHostList!.push(VirtualListDto.fromJS(item));
            }
            if (Array.isArray(_data["virtualMachineList"])) {
                this.virtualMachineList = [] as any;
                for (let item of _data["virtualMachineList"])
                    this.virtualMachineList!.push(VirtualListDto.fromJS(item));
            }
            if (Array.isArray(_data["sytemApplicationList"])) {
                this.sytemApplicationList = [] as any;
                for (let item of _data["sytemApplicationList"])
                    this.sytemApplicationList!.push(SytemApplicationDto.fromJS(item));
            }
            if (Array.isArray(_data["findingIncidentList"])) {
                this.findingIncidentList = [] as any;
                for (let item of _data["findingIncidentList"])
                    this.findingIncidentList!.push(FindingIncidentListDto.fromJS(item));
            }
            if (Array.isArray(_data["internalControlList"])) {
                this.internalControlList = [] as any;
                for (let item of _data["internalControlList"])
                    this.internalControlList!.push(InternalControlListDto.fromJS(item));
            }
            if (Array.isArray(_data["vendorList"])) {
                this.vendorList = [] as any;
                for (let item of _data["vendorList"])
                    this.vendorList!.push(VendorListDto.fromJS(item));
            }
            if (Array.isArray(_data["strategicObjectiveList"])) {
                this.strategicObjectiveList = [] as any;
                for (let item of _data["strategicObjectiveList"])
                    this.strategicObjectiveList!.push(StrategicObjectivesDto.fromJS(item));
            }
            if (Array.isArray(_data["riskRegisterList"])) {
                this.riskRegisterList = [] as any;
                for (let item of _data["riskRegisterList"])
                    this.riskRegisterList!.push(RiskRegisterListDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingAssetInformations"])) {
                this.selectedFindingAssetInformations = [] as any;
                for (let item of _data["selectedFindingAssetInformations"])
                    this.selectedFindingAssetInformations!.push(FindingAssetInformationDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingAuthoratativeSources"])) {
                this.selectedFindingAuthoratativeSources = [] as any;
                for (let item of _data["selectedFindingAuthoratativeSources"])
                    this.selectedFindingAuthoratativeSources!.push(FindingAuthoratativeSourceDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingBusinessUnits"])) {
                this.selectedFindingBusinessUnits = [] as any;
                for (let item of _data["selectedFindingBusinessUnits"])
                    this.selectedFindingBusinessUnits!.push(FindingBusinessUnitDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingControlDesigns"])) {
                this.selectedFindingControlDesigns = [] as any;
                for (let item of _data["selectedFindingControlDesigns"])
                    this.selectedFindingControlDesigns!.push(FindingControlDesignDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingControlOperatings"])) {
                this.selectedFindingControlOperatings = [] as any;
                for (let item of _data["selectedFindingControlOperatings"])
                    this.selectedFindingControlOperatings!.push(FindingControlOperatingDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingFacilitieDatacenters"])) {
                this.selectedFindingFacilitieDatacenters = [] as any;
                for (let item of _data["selectedFindingFacilitieDatacenters"])
                    this.selectedFindingFacilitieDatacenters!.push(FindingFacilitieDatacenterDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingHardwareAssets"])) {
                this.selectedFindingHardwareAssets = [] as any;
                for (let item of _data["selectedFindingHardwareAssets"])
                    this.selectedFindingHardwareAssets!.push(FindingHardwareAssetDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingIncidents"])) {
                this.selectedFindingIncidents = [] as any;
                for (let item of _data["selectedFindingIncidents"])
                    this.selectedFindingIncidents!.push(FindingIncidentDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingInternalControls"])) {
                this.selectedFindingInternalControls = [] as any;
                for (let item of _data["selectedFindingInternalControls"])
                    this.selectedFindingInternalControls!.push(FindingInternalControlDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingOrganizations"])) {
                this.selectedFindingOrganizations = [] as any;
                for (let item of _data["selectedFindingOrganizations"])
                    this.selectedFindingOrganizations!.push(FindingOrganizationDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingRiskRegisters"])) {
                this.selectedFindingRiskRegisters = [] as any;
                for (let item of _data["selectedFindingRiskRegisters"])
                    this.selectedFindingRiskRegisters!.push(FindingRiskRegisterDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingStrategicObjectives"])) {
                this.selectedFindingStrategicObjectives = [] as any;
                for (let item of _data["selectedFindingStrategicObjectives"])
                    this.selectedFindingStrategicObjectives!.push(FindingStrategicObjectiveDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingSystemsApplications"])) {
                this.selectedFindingSystemsApplications = [] as any;
                for (let item of _data["selectedFindingSystemsApplications"])
                    this.selectedFindingSystemsApplications!.push(FindingSystemsApplicationDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingVendors"])) {
                this.selectedFindingVendors = [] as any;
                for (let item of _data["selectedFindingVendors"])
                    this.selectedFindingVendors!.push(FindingVendorDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingVirtualHosts"])) {
                this.selectedFindingVirtualHosts = [] as any;
                for (let item of _data["selectedFindingVirtualHosts"])
                    this.selectedFindingVirtualHosts!.push(FindingVirtualHostDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedFindingVirtualMachines"])) {
                this.selectedFindingVirtualMachines = [] as any;
                for (let item of _data["selectedFindingVirtualMachines"])
                    this.selectedFindingVirtualMachines!.push(FindingVirtualMachineDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FindingInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindingInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["findingId"] = this.findingId;
        data["findingTitle"] = this.findingTitle;
        data["findingDetails"] = this.findingDetails;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.categoryList)) {
            data["categoryList"] = [];
            for (let item of this.categoryList)
                data["categoryList"].push(item.toJSON());
        }
        data["categoryOther"] = this.categoryOther;
        data["findingStatusId"] = this.findingStatusId;
        if (Array.isArray(this.findingStatusList)) {
            data["findingStatusList"] = [];
            for (let item of this.findingStatusList)
                data["findingStatusList"].push(item.toJSON());
        }
        data["rankingId"] = this.rankingId;
        if (Array.isArray(this.rankingList)) {
            data["rankingList"] = [];
            for (let item of this.rankingList)
                data["rankingList"].push(item.toJSON());
        }
        data["classificationId"] = this.classificationId;
        if (Array.isArray(this.classificationList)) {
            data["classificationList"] = [];
            for (let item of this.classificationList)
                data["classificationList"].push(item.toJSON());
        }
        data["findingManagerId"] = this.findingManagerId;
        if (Array.isArray(this.findingManagerList)) {
            data["findingManagerList"] = [];
            for (let item of this.findingManagerList)
                data["findingManagerList"].push(item.toJSON());
        }
        data["findingCoordinatorId"] = this.findingCoordinatorId;
        if (Array.isArray(this.findingCoordinatorList)) {
            data["findingCoordinatorList"] = [];
            for (let item of this.findingCoordinatorList)
                data["findingCoordinatorList"].push(item.toJSON());
        }
        data["findingOwnerId"] = this.findingOwnerId;
        if (Array.isArray(this.findingOwnerList)) {
            data["findingOwnerList"] = [];
            for (let item of this.findingOwnerList)
                data["findingOwnerList"].push(item.toJSON());
        }
        data["criteria"] = this.criteria;
        data["cause"] = this.cause;
        data["condition"] = this.condition;
        data["consequence"] = this.consequence;
        data["actionId"] = this.actionId;
        if (Array.isArray(this.actionLsit)) {
            data["actionLsit"] = [];
            for (let item of this.actionLsit)
                data["actionLsit"].push(item.toJSON());
        }
        data["reviewedId"] = this.reviewedId;
        if (Array.isArray(this.reviewesList)) {
            data["reviewesList"] = [];
            for (let item of this.reviewesList)
                data["reviewesList"].push(item.toJSON());
        }
        data["responseId"] = this.responseId;
        if (Array.isArray(this.responses)) {
            data["responses"] = [];
            for (let item of this.responses)
                data["responses"].push(item.toJSON());
        }
        data["potentialCost"] = this.potentialCost;
        data["assignedId"] = this.assignedId;
        if (Array.isArray(this.assignedList)) {
            data["assignedList"] = [];
            for (let item of this.assignedList)
                data["assignedList"].push(item.toJSON());
        }
        if (Array.isArray(this.authoritativeSourceList)) {
            data["authoritativeSourceList"] = [];
            for (let item of this.authoritativeSourceList)
                data["authoritativeSourceList"].push(item.toJSON());
        }
        if (Array.isArray(this.assetInformationList)) {
            data["assetInformationList"] = [];
            for (let item of this.assetInformationList)
                data["assetInformationList"].push(item.toJSON());
        }
        if (Array.isArray(this.businessUnitList)) {
            data["businessUnitList"] = [];
            for (let item of this.businessUnitList)
                data["businessUnitList"].push(item.toJSON());
        }
        if (Array.isArray(this.companyList)) {
            data["companyList"] = [];
            for (let item of this.companyList)
                data["companyList"].push(item.toJSON());
        }
        if (Array.isArray(this.controlDesignList)) {
            data["controlDesignList"] = [];
            for (let item of this.controlDesignList)
                data["controlDesignList"].push(item.toJSON());
        }
        if (Array.isArray(this.controlOperatingList)) {
            data["controlOperatingList"] = [];
            for (let item of this.controlOperatingList)
                data["controlOperatingList"].push(item.toJSON());
        }
        if (Array.isArray(this.facilitieDatacenterList)) {
            data["facilitieDatacenterList"] = [];
            for (let item of this.facilitieDatacenterList)
                data["facilitieDatacenterList"].push(item.toJSON());
        }
        if (Array.isArray(this.hardwareAssetList)) {
            data["hardwareAssetList"] = [];
            for (let item of this.hardwareAssetList)
                data["hardwareAssetList"].push(item.toJSON());
        }
        if (Array.isArray(this.virtualHostList)) {
            data["virtualHostList"] = [];
            for (let item of this.virtualHostList)
                data["virtualHostList"].push(item.toJSON());
        }
        if (Array.isArray(this.virtualMachineList)) {
            data["virtualMachineList"] = [];
            for (let item of this.virtualMachineList)
                data["virtualMachineList"].push(item.toJSON());
        }
        if (Array.isArray(this.sytemApplicationList)) {
            data["sytemApplicationList"] = [];
            for (let item of this.sytemApplicationList)
                data["sytemApplicationList"].push(item.toJSON());
        }
        if (Array.isArray(this.findingIncidentList)) {
            data["findingIncidentList"] = [];
            for (let item of this.findingIncidentList)
                data["findingIncidentList"].push(item.toJSON());
        }
        if (Array.isArray(this.internalControlList)) {
            data["internalControlList"] = [];
            for (let item of this.internalControlList)
                data["internalControlList"].push(item.toJSON());
        }
        if (Array.isArray(this.vendorList)) {
            data["vendorList"] = [];
            for (let item of this.vendorList)
                data["vendorList"].push(item.toJSON());
        }
        if (Array.isArray(this.strategicObjectiveList)) {
            data["strategicObjectiveList"] = [];
            for (let item of this.strategicObjectiveList)
                data["strategicObjectiveList"].push(item.toJSON());
        }
        if (Array.isArray(this.riskRegisterList)) {
            data["riskRegisterList"] = [];
            for (let item of this.riskRegisterList)
                data["riskRegisterList"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingAssetInformations)) {
            data["selectedFindingAssetInformations"] = [];
            for (let item of this.selectedFindingAssetInformations)
                data["selectedFindingAssetInformations"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingAuthoratativeSources)) {
            data["selectedFindingAuthoratativeSources"] = [];
            for (let item of this.selectedFindingAuthoratativeSources)
                data["selectedFindingAuthoratativeSources"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingBusinessUnits)) {
            data["selectedFindingBusinessUnits"] = [];
            for (let item of this.selectedFindingBusinessUnits)
                data["selectedFindingBusinessUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingControlDesigns)) {
            data["selectedFindingControlDesigns"] = [];
            for (let item of this.selectedFindingControlDesigns)
                data["selectedFindingControlDesigns"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingControlOperatings)) {
            data["selectedFindingControlOperatings"] = [];
            for (let item of this.selectedFindingControlOperatings)
                data["selectedFindingControlOperatings"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingFacilitieDatacenters)) {
            data["selectedFindingFacilitieDatacenters"] = [];
            for (let item of this.selectedFindingFacilitieDatacenters)
                data["selectedFindingFacilitieDatacenters"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingHardwareAssets)) {
            data["selectedFindingHardwareAssets"] = [];
            for (let item of this.selectedFindingHardwareAssets)
                data["selectedFindingHardwareAssets"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingIncidents)) {
            data["selectedFindingIncidents"] = [];
            for (let item of this.selectedFindingIncidents)
                data["selectedFindingIncidents"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingInternalControls)) {
            data["selectedFindingInternalControls"] = [];
            for (let item of this.selectedFindingInternalControls)
                data["selectedFindingInternalControls"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingOrganizations)) {
            data["selectedFindingOrganizations"] = [];
            for (let item of this.selectedFindingOrganizations)
                data["selectedFindingOrganizations"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingRiskRegisters)) {
            data["selectedFindingRiskRegisters"] = [];
            for (let item of this.selectedFindingRiskRegisters)
                data["selectedFindingRiskRegisters"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingStrategicObjectives)) {
            data["selectedFindingStrategicObjectives"] = [];
            for (let item of this.selectedFindingStrategicObjectives)
                data["selectedFindingStrategicObjectives"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingSystemsApplications)) {
            data["selectedFindingSystemsApplications"] = [];
            for (let item of this.selectedFindingSystemsApplications)
                data["selectedFindingSystemsApplications"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingVendors)) {
            data["selectedFindingVendors"] = [];
            for (let item of this.selectedFindingVendors)
                data["selectedFindingVendors"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingVirtualHosts)) {
            data["selectedFindingVirtualHosts"] = [];
            for (let item of this.selectedFindingVirtualHosts)
                data["selectedFindingVirtualHosts"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedFindingVirtualMachines)) {
            data["selectedFindingVirtualMachines"] = [];
            for (let item of this.selectedFindingVirtualMachines)
                data["selectedFindingVirtualMachines"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IFindingInfoDto {
    tenantId: number | undefined;
    findingId: string | undefined;
    findingTitle: string | undefined;
    findingDetails: string | undefined;
    dateCreated: DateTime | undefined;
    categoryId: number | undefined;
    categoryList: GetDynamicValueDto[] | undefined;
    categoryOther: string | undefined;
    findingStatusId: number | undefined;
    findingStatusList: GetDynamicValueDto[] | undefined;
    rankingId: number | undefined;
    rankingList: GetDynamicValueDto[] | undefined;
    classificationId: number | undefined;
    classificationList: GetDynamicValueDto[] | undefined;
    findingManagerId: number | undefined;
    findingManagerList: BusinessServiceOwner[] | undefined;
    findingCoordinatorId: number | undefined;
    findingCoordinatorList: BusinessServiceOwner[] | undefined;
    findingOwnerId: number | undefined;
    findingOwnerList: BusinessServiceOwner[] | undefined;
    criteria: string | undefined;
    cause: string | undefined;
    condition: string | undefined;
    consequence: string | undefined;
    actionId: number | undefined;
    actionLsit: GetDynamicValueDto[] | undefined;
    reviewedId: number | undefined;
    reviewesList: BusinessServiceOwner[] | undefined;
    responseId: number | undefined;
    responses: GetDynamicValueDto[] | undefined;
    potentialCost: number | undefined;
    assignedId: number | undefined;
    assignedList: BusinessServiceOwner[] | undefined;
    authoritativeSourceList: ProgramAuthoritativeDocumentsDto[] | undefined;
    assetInformationList: AssetInformationListDto[] | undefined;
    businessUnitList: BusinessUnitGaurdianDto[] | undefined;
    companyList: GetOrganizationDto[] | undefined;
    controlDesignList: ControlDesignListDto[] | undefined;
    controlOperatingList: ControlOperatingListDto[] | undefined;
    facilitieDatacenterList: FacilitieDatacenterListDto[] | undefined;
    hardwareAssetList: HardwareAsseDetailListDto[] | undefined;
    virtualHostList: VirtualListDto[] | undefined;
    virtualMachineList: VirtualListDto[] | undefined;
    sytemApplicationList: SytemApplicationDto[] | undefined;
    findingIncidentList: FindingIncidentListDto[] | undefined;
    internalControlList: InternalControlListDto[] | undefined;
    vendorList: VendorListDto[] | undefined;
    strategicObjectiveList: StrategicObjectivesDto[] | undefined;
    riskRegisterList: RiskRegisterListDto[] | undefined;
    selectedFindingAssetInformations: FindingAssetInformationDto[] | undefined;
    selectedFindingAuthoratativeSources: FindingAuthoratativeSourceDto[] | undefined;
    selectedFindingBusinessUnits: FindingBusinessUnitDto[] | undefined;
    selectedFindingControlDesigns: FindingControlDesignDto[] | undefined;
    selectedFindingControlOperatings: FindingControlOperatingDto[] | undefined;
    selectedFindingFacilitieDatacenters: FindingFacilitieDatacenterDto[] | undefined;
    selectedFindingHardwareAssets: FindingHardwareAssetDto[] | undefined;
    selectedFindingIncidents: FindingIncidentDto[] | undefined;
    selectedFindingInternalControls: FindingInternalControlDto[] | undefined;
    selectedFindingOrganizations: FindingOrganizationDto[] | undefined;
    selectedFindingRiskRegisters: FindingRiskRegisterDto[] | undefined;
    selectedFindingStrategicObjectives: FindingStrategicObjectiveDto[] | undefined;
    selectedFindingSystemsApplications: FindingSystemsApplicationDto[] | undefined;
    selectedFindingVendors: FindingVendorDto[] | undefined;
    selectedFindingVirtualHosts: FindingVirtualHostDto[] | undefined;
    selectedFindingVirtualMachines: FindingVirtualMachineDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IBlockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IUnblockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class HardwareAssetITserviceDto implements IHardwareAssetITserviceDto {
    id!: number;
    hardwareAssetId!: number | undefined;
    itServiceId!: number | undefined;

    constructor(data?: IHardwareAssetITserviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hardwareAssetId = _data["hardwareAssetId"];
            this.itServiceId = _data["itServiceId"];
        }
    }

    static fromJS(data: any): HardwareAssetITserviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new HardwareAssetITserviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hardwareAssetId"] = this.hardwareAssetId;
        data["itServiceId"] = this.itServiceId;
        return data; 
    }
}

export interface IHardwareAssetITserviceDto {
    id: number;
    hardwareAssetId: number | undefined;
    itServiceId: number | undefined;
}

export class HardwareAssetBusinessprocessDto implements IHardwareAssetBusinessprocessDto {
    id!: number;
    hardwareAssetId!: number | undefined;
    businessProcessId!: number | undefined;

    constructor(data?: IHardwareAssetBusinessprocessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hardwareAssetId = _data["hardwareAssetId"];
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static fromJS(data: any): HardwareAssetBusinessprocessDto {
        data = typeof data === 'object' ? data : {};
        let result = new HardwareAssetBusinessprocessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hardwareAssetId"] = this.hardwareAssetId;
        data["businessProcessId"] = this.businessProcessId;
        return data; 
    }
}

export interface IHardwareAssetBusinessprocessDto {
    id: number;
    hardwareAssetId: number | undefined;
    businessProcessId: number | undefined;
}

export class HardwareAssetBusinessServiceDto implements IHardwareAssetBusinessServiceDto {
    id!: number;
    hardwareAssetId!: number | undefined;
    businessServiceId!: number | undefined;

    constructor(data?: IHardwareAssetBusinessServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hardwareAssetId = _data["hardwareAssetId"];
            this.businessServiceId = _data["businessServiceId"];
        }
    }

    static fromJS(data: any): HardwareAssetBusinessServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new HardwareAssetBusinessServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hardwareAssetId"] = this.hardwareAssetId;
        data["businessServiceId"] = this.businessServiceId;
        return data; 
    }
}

export interface IHardwareAssetBusinessServiceDto {
    id: number;
    hardwareAssetId: number | undefined;
    businessServiceId: number | undefined;
}

export class HardwareAssetDto implements IHardwareAssetDto {
    tenantId!: number | undefined;
    assetId!: string | undefined;
    hardwareAssetName!: string | undefined;
    description!: string | undefined;
    assetHardwareId!: string | undefined;
    locationsId!: number | undefined;
    locationLists!: FacilitieDatacenterListDto[] | undefined;
    lockThreatOrganizationId!: number | undefined;
    businessUnitOwnerId!: number | undefined;
    businessUnitOwners!: BusinessUnitPrimaryDto[] | undefined;
    businessUnitGaurdianId!: number | undefined;
    businessUnitGaurdians!: BusinessUnitGaurdianDto[] | undefined;
    employeeId!: number | undefined;
    employeesList!: BusinessServiceOwner[] | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    confidentialityId!: number | undefined;
    confidentialitys!: GetDynamicValueDto[] | undefined;
    availibilityId!: number | undefined;
    availibilitys!: GetDynamicValueDto[] | undefined;
    othersId!: number | undefined;
    otheres!: GetDynamicValueDto[] | undefined;
    integrityId!: number | undefined;
    integritys!: GetDynamicValueDto[] | undefined;
    iTserviceLists!: ITserviceListDto[] | undefined;
    businessServices!: BusinessServiceSDto[] | undefined;
    businessProcess!: BusinessProcessDetailDto[] | undefined;
    selectedHardwareAssetITservices!: HardwareAssetITserviceDto[] | undefined;
    selectedHardwareAssetBusinessprocess!: HardwareAssetBusinessprocessDto[] | undefined;
    selectedHardwareAssetBusinessServices!: HardwareAssetBusinessServiceDto[] | undefined;
    removedHardwareAssetITservice!: number[] | undefined;
    removedHardwareAssetBusinessprocess!: number[] | undefined;
    removedHardwareAssetBusinessService!: number[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IHardwareAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.assetId = _data["assetId"];
            this.hardwareAssetName = _data["hardwareAssetName"];
            this.description = _data["description"];
            this.assetHardwareId = _data["assetHardwareId"];
            this.locationsId = _data["locationsId"];
            if (Array.isArray(_data["locationLists"])) {
                this.locationLists = [] as any;
                for (let item of _data["locationLists"])
                    this.locationLists!.push(FacilitieDatacenterListDto.fromJS(item));
            }
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.businessUnitOwnerId = _data["businessUnitOwnerId"];
            if (Array.isArray(_data["businessUnitOwners"])) {
                this.businessUnitOwners = [] as any;
                for (let item of _data["businessUnitOwners"])
                    this.businessUnitOwners!.push(BusinessUnitPrimaryDto.fromJS(item));
            }
            this.businessUnitGaurdianId = _data["businessUnitGaurdianId"];
            if (Array.isArray(_data["businessUnitGaurdians"])) {
                this.businessUnitGaurdians = [] as any;
                for (let item of _data["businessUnitGaurdians"])
                    this.businessUnitGaurdians!.push(BusinessUnitGaurdianDto.fromJS(item));
            }
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["employeesList"])) {
                this.employeesList = [] as any;
                for (let item of _data["employeesList"])
                    this.employeesList!.push(BusinessServiceOwner.fromJS(item));
            }
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            this.confidentialityId = _data["confidentialityId"];
            if (Array.isArray(_data["confidentialitys"])) {
                this.confidentialitys = [] as any;
                for (let item of _data["confidentialitys"])
                    this.confidentialitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.availibilityId = _data["availibilityId"];
            if (Array.isArray(_data["availibilitys"])) {
                this.availibilitys = [] as any;
                for (let item of _data["availibilitys"])
                    this.availibilitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.othersId = _data["othersId"];
            if (Array.isArray(_data["otheres"])) {
                this.otheres = [] as any;
                for (let item of _data["otheres"])
                    this.otheres!.push(GetDynamicValueDto.fromJS(item));
            }
            this.integrityId = _data["integrityId"];
            if (Array.isArray(_data["integritys"])) {
                this.integritys = [] as any;
                for (let item of _data["integritys"])
                    this.integritys!.push(GetDynamicValueDto.fromJS(item));
            }
            if (Array.isArray(_data["iTserviceLists"])) {
                this.iTserviceLists = [] as any;
                for (let item of _data["iTserviceLists"])
                    this.iTserviceLists!.push(ITserviceListDto.fromJS(item));
            }
            if (Array.isArray(_data["businessServices"])) {
                this.businessServices = [] as any;
                for (let item of _data["businessServices"])
                    this.businessServices!.push(BusinessServiceSDto.fromJS(item));
            }
            if (Array.isArray(_data["businessProcess"])) {
                this.businessProcess = [] as any;
                for (let item of _data["businessProcess"])
                    this.businessProcess!.push(BusinessProcessDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedHardwareAssetITservices"])) {
                this.selectedHardwareAssetITservices = [] as any;
                for (let item of _data["selectedHardwareAssetITservices"])
                    this.selectedHardwareAssetITservices!.push(HardwareAssetITserviceDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedHardwareAssetBusinessprocess"])) {
                this.selectedHardwareAssetBusinessprocess = [] as any;
                for (let item of _data["selectedHardwareAssetBusinessprocess"])
                    this.selectedHardwareAssetBusinessprocess!.push(HardwareAssetBusinessprocessDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedHardwareAssetBusinessServices"])) {
                this.selectedHardwareAssetBusinessServices = [] as any;
                for (let item of _data["selectedHardwareAssetBusinessServices"])
                    this.selectedHardwareAssetBusinessServices!.push(HardwareAssetBusinessServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["removedHardwareAssetITservice"])) {
                this.removedHardwareAssetITservice = [] as any;
                for (let item of _data["removedHardwareAssetITservice"])
                    this.removedHardwareAssetITservice!.push(item);
            }
            if (Array.isArray(_data["removedHardwareAssetBusinessprocess"])) {
                this.removedHardwareAssetBusinessprocess = [] as any;
                for (let item of _data["removedHardwareAssetBusinessprocess"])
                    this.removedHardwareAssetBusinessprocess!.push(item);
            }
            if (Array.isArray(_data["removedHardwareAssetBusinessService"])) {
                this.removedHardwareAssetBusinessService = [] as any;
                for (let item of _data["removedHardwareAssetBusinessService"])
                    this.removedHardwareAssetBusinessService!.push(item);
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HardwareAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new HardwareAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["assetId"] = this.assetId;
        data["hardwareAssetName"] = this.hardwareAssetName;
        data["description"] = this.description;
        data["assetHardwareId"] = this.assetHardwareId;
        data["locationsId"] = this.locationsId;
        if (Array.isArray(this.locationLists)) {
            data["locationLists"] = [];
            for (let item of this.locationLists)
                data["locationLists"].push(item.toJSON());
        }
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["businessUnitOwnerId"] = this.businessUnitOwnerId;
        if (Array.isArray(this.businessUnitOwners)) {
            data["businessUnitOwners"] = [];
            for (let item of this.businessUnitOwners)
                data["businessUnitOwners"].push(item.toJSON());
        }
        data["businessUnitGaurdianId"] = this.businessUnitGaurdianId;
        if (Array.isArray(this.businessUnitGaurdians)) {
            data["businessUnitGaurdians"] = [];
            for (let item of this.businessUnitGaurdians)
                data["businessUnitGaurdians"].push(item.toJSON());
        }
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.employeesList)) {
            data["employeesList"] = [];
            for (let item of this.employeesList)
                data["employeesList"].push(item.toJSON());
        }
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        data["confidentialityId"] = this.confidentialityId;
        if (Array.isArray(this.confidentialitys)) {
            data["confidentialitys"] = [];
            for (let item of this.confidentialitys)
                data["confidentialitys"].push(item.toJSON());
        }
        data["availibilityId"] = this.availibilityId;
        if (Array.isArray(this.availibilitys)) {
            data["availibilitys"] = [];
            for (let item of this.availibilitys)
                data["availibilitys"].push(item.toJSON());
        }
        data["othersId"] = this.othersId;
        if (Array.isArray(this.otheres)) {
            data["otheres"] = [];
            for (let item of this.otheres)
                data["otheres"].push(item.toJSON());
        }
        data["integrityId"] = this.integrityId;
        if (Array.isArray(this.integritys)) {
            data["integritys"] = [];
            for (let item of this.integritys)
                data["integritys"].push(item.toJSON());
        }
        if (Array.isArray(this.iTserviceLists)) {
            data["iTserviceLists"] = [];
            for (let item of this.iTserviceLists)
                data["iTserviceLists"].push(item.toJSON());
        }
        if (Array.isArray(this.businessServices)) {
            data["businessServices"] = [];
            for (let item of this.businessServices)
                data["businessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.businessProcess)) {
            data["businessProcess"] = [];
            for (let item of this.businessProcess)
                data["businessProcess"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedHardwareAssetITservices)) {
            data["selectedHardwareAssetITservices"] = [];
            for (let item of this.selectedHardwareAssetITservices)
                data["selectedHardwareAssetITservices"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedHardwareAssetBusinessprocess)) {
            data["selectedHardwareAssetBusinessprocess"] = [];
            for (let item of this.selectedHardwareAssetBusinessprocess)
                data["selectedHardwareAssetBusinessprocess"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedHardwareAssetBusinessServices)) {
            data["selectedHardwareAssetBusinessServices"] = [];
            for (let item of this.selectedHardwareAssetBusinessServices)
                data["selectedHardwareAssetBusinessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.removedHardwareAssetITservice)) {
            data["removedHardwareAssetITservice"] = [];
            for (let item of this.removedHardwareAssetITservice)
                data["removedHardwareAssetITservice"].push(item);
        }
        if (Array.isArray(this.removedHardwareAssetBusinessprocess)) {
            data["removedHardwareAssetBusinessprocess"] = [];
            for (let item of this.removedHardwareAssetBusinessprocess)
                data["removedHardwareAssetBusinessprocess"].push(item);
        }
        if (Array.isArray(this.removedHardwareAssetBusinessService)) {
            data["removedHardwareAssetBusinessService"] = [];
            for (let item of this.removedHardwareAssetBusinessService)
                data["removedHardwareAssetBusinessService"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IHardwareAssetDto {
    tenantId: number | undefined;
    assetId: string | undefined;
    hardwareAssetName: string | undefined;
    description: string | undefined;
    assetHardwareId: string | undefined;
    locationsId: number | undefined;
    locationLists: FacilitieDatacenterListDto[] | undefined;
    lockThreatOrganizationId: number | undefined;
    businessUnitOwnerId: number | undefined;
    businessUnitOwners: BusinessUnitPrimaryDto[] | undefined;
    businessUnitGaurdianId: number | undefined;
    businessUnitGaurdians: BusinessUnitGaurdianDto[] | undefined;
    employeeId: number | undefined;
    employeesList: BusinessServiceOwner[] | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    confidentialityId: number | undefined;
    confidentialitys: GetDynamicValueDto[] | undefined;
    availibilityId: number | undefined;
    availibilitys: GetDynamicValueDto[] | undefined;
    othersId: number | undefined;
    otheres: GetDynamicValueDto[] | undefined;
    integrityId: number | undefined;
    integritys: GetDynamicValueDto[] | undefined;
    iTserviceLists: ITserviceListDto[] | undefined;
    businessServices: BusinessServiceSDto[] | undefined;
    businessProcess: BusinessProcessDetailDto[] | undefined;
    selectedHardwareAssetITservices: HardwareAssetITserviceDto[] | undefined;
    selectedHardwareAssetBusinessprocess: HardwareAssetBusinessprocessDto[] | undefined;
    selectedHardwareAssetBusinessServices: HardwareAssetBusinessServiceDto[] | undefined;
    removedHardwareAssetITservice: number[] | undefined;
    removedHardwareAssetBusinessprocess: number[] | undefined;
    removedHardwareAssetBusinessService: number[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class HardwareAssetListDto implements IHardwareAssetListDto {
    tenantId!: number | undefined;
    assetId!: string | undefined;
    hardwareAssetName!: string | undefined;
    description!: string | undefined;
    assetHardwareId!: string | undefined;
    locationsId!: number | undefined;
    locations!: FacilitieDatacenterListDto;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationDto;
    confidentialityId!: number | undefined;
    confidentiality!: DynamicPropertyValue;
    availibilityId!: number | undefined;
    availibility!: DynamicPropertyValue;
    othersId!: number | undefined;
    others!: DynamicPropertyValue;
    integrityId!: number | undefined;
    integrity!: DynamicPropertyValue;
    id!: number;

    constructor(data?: IHardwareAssetListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.assetId = _data["assetId"];
            this.hardwareAssetName = _data["hardwareAssetName"];
            this.description = _data["description"];
            this.assetHardwareId = _data["assetHardwareId"];
            this.locationsId = _data["locationsId"];
            this.locations = _data["locations"] ? FacilitieDatacenterListDto.fromJS(_data["locations"]) : <any>undefined;
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.confidentialityId = _data["confidentialityId"];
            this.confidentiality = _data["confidentiality"] ? DynamicPropertyValue.fromJS(_data["confidentiality"]) : <any>undefined;
            this.availibilityId = _data["availibilityId"];
            this.availibility = _data["availibility"] ? DynamicPropertyValue.fromJS(_data["availibility"]) : <any>undefined;
            this.othersId = _data["othersId"];
            this.others = _data["others"] ? DynamicPropertyValue.fromJS(_data["others"]) : <any>undefined;
            this.integrityId = _data["integrityId"];
            this.integrity = _data["integrity"] ? DynamicPropertyValue.fromJS(_data["integrity"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HardwareAssetListDto {
        data = typeof data === 'object' ? data : {};
        let result = new HardwareAssetListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["assetId"] = this.assetId;
        data["hardwareAssetName"] = this.hardwareAssetName;
        data["description"] = this.description;
        data["assetHardwareId"] = this.assetHardwareId;
        data["locationsId"] = this.locationsId;
        data["locations"] = this.locations ? this.locations.toJSON() : <any>undefined;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["confidentialityId"] = this.confidentialityId;
        data["confidentiality"] = this.confidentiality ? this.confidentiality.toJSON() : <any>undefined;
        data["availibilityId"] = this.availibilityId;
        data["availibility"] = this.availibility ? this.availibility.toJSON() : <any>undefined;
        data["othersId"] = this.othersId;
        data["others"] = this.others ? this.others.toJSON() : <any>undefined;
        data["integrityId"] = this.integrityId;
        data["integrity"] = this.integrity ? this.integrity.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IHardwareAssetListDto {
    tenantId: number | undefined;
    assetId: string | undefined;
    hardwareAssetName: string | undefined;
    description: string | undefined;
    assetHardwareId: string | undefined;
    locationsId: number | undefined;
    locations: FacilitieDatacenterListDto;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationDto;
    confidentialityId: number | undefined;
    confidentiality: DynamicPropertyValue;
    availibilityId: number | undefined;
    availibility: DynamicPropertyValue;
    othersId: number | undefined;
    others: DynamicPropertyValue;
    integrityId: number | undefined;
    integrity: DynamicPropertyValue;
    id: number;
}

export class PagedResultDtoOfHardwareAssetListDto implements IPagedResultDtoOfHardwareAssetListDto {
    totalCount!: number;
    items!: HardwareAssetListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfHardwareAssetListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HardwareAssetListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHardwareAssetListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHardwareAssetListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfHardwareAssetListDto {
    totalCount: number;
    items: HardwareAssetListDto[] | undefined;
}

export class TopStatsData implements ITopStatsData {
    newTenantsCount!: number;
    newSubscriptionAmount!: number;
    dashboardPlaceholder1!: number;
    dashboardPlaceholder2!: number;

    constructor(data?: ITopStatsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newTenantsCount = _data["newTenantsCount"];
            this.newSubscriptionAmount = _data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = _data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = _data["dashboardPlaceholder2"];
        }
    }

    static fromJS(data: any): TopStatsData {
        data = typeof data === 'object' ? data : {};
        let result = new TopStatsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        return data; 
    }
}

export interface ITopStatsData {
    newTenantsCount: number;
    newSubscriptionAmount: number;
    dashboardPlaceholder1: number;
    dashboardPlaceholder2: number;
}

export class RecentTenant implements IRecentTenant {
    id!: number;
    name!: string | undefined;
    creationTime!: DateTime;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IRecentTenant {
    id: number;
    name: string | undefined;
    creationTime: DateTime;
}

export class GetRecentTenantsOutput implements IGetRecentTenantsOutput {
    recentTenantsDayCount!: number;
    maxRecentTenantsShownCount!: number;
    tenantCreationStartDate!: DateTime;
    recentTenants!: RecentTenant[] | undefined;

    constructor(data?: IGetRecentTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recentTenantsDayCount = _data["recentTenantsDayCount"];
            this.maxRecentTenantsShownCount = _data["maxRecentTenantsShownCount"];
            this.tenantCreationStartDate = _data["tenantCreationStartDate"] ? DateTime.fromISO(_data["tenantCreationStartDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["recentTenants"])) {
                this.recentTenants = [] as any;
                for (let item of _data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRecentTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toString() : <any>undefined;
        if (Array.isArray(this.recentTenants)) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRecentTenantsOutput {
    recentTenantsDayCount: number;
    maxRecentTenantsShownCount: number;
    tenantCreationStartDate: DateTime;
    recentTenants: RecentTenant[] | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantName = _data["tenantName"];
            this.remainingDayCount = _data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number;
}

export class GetExpiringTenantsOutput implements IGetExpiringTenantsOutput {
    expiringTenants!: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount!: number;
    maxExpiringTenantsShownCount!: number;
    subscriptionEndDateStart!: DateTime;
    subscriptionEndDateEnd!: DateTime;

    constructor(data?: IGetExpiringTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["expiringTenants"])) {
                this.expiringTenants = [] as any;
                for (let item of _data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            this.subscriptionEndAlertDayCount = _data["subscriptionEndAlertDayCount"];
            this.maxExpiringTenantsShownCount = _data["maxExpiringTenantsShownCount"];
            this.subscriptionEndDateStart = _data["subscriptionEndDateStart"] ? DateTime.fromISO(_data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = _data["subscriptionEndDateEnd"] ? DateTime.fromISO(_data["subscriptionEndDateEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetExpiringTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpiringTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.expiringTenants)) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toString() : <any>undefined;
        return data; 
    }
}

export interface IGetExpiringTenantsOutput {
    expiringTenants: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount: number;
    maxExpiringTenantsShownCount: number;
    subscriptionEndDateStart: DateTime;
    subscriptionEndDateEnd: DateTime;
}

export enum ChartDateInterval {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: DateTime;
    amount!: number;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: DateTime;
    amount: number;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["incomeStatistics"])) {
                this.incomeStatistics = [] as any;
                for (let item of _data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.incomeStatistics)) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["editionStatistics"])) {
                this.editionStatistics = [] as any;
                for (let item of _data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.editionStatistics)) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timezone = _data["timezone"];
            this.timezoneForComparison = _data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class SessionTimeOutSettingsEditDto implements ISessionTimeOutSettingsEditDto {
    isEnabled!: boolean;
    timeOutSecond!: number;
    showTimeOutNotificationSecond!: number;
    showLockScreenWhenTimedOut!: boolean;

    constructor(data?: ISessionTimeOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.timeOutSecond = _data["timeOutSecond"];
            this.showTimeOutNotificationSecond = _data["showTimeOutNotificationSecond"];
            this.showLockScreenWhenTimedOut = _data["showLockScreenWhenTimedOut"];
        }
    }

    static fromJS(data: any): SessionTimeOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionTimeOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["timeOutSecond"] = this.timeOutSecond;
        data["showTimeOutNotificationSecond"] = this.showTimeOutNotificationSecond;
        data["showLockScreenWhenTimedOut"] = this.showLockScreenWhenTimedOut;
        return data; 
    }
}

export interface ISessionTimeOutSettingsEditDto {
    isEnabled: boolean;
    timeOutSecond: number;
    showTimeOutNotificationSecond: number;
    showLockScreenWhenTimedOut: boolean;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean;
    smsVerificationEnabled!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    useCaptchaOnLogin!: boolean;
    allowUsingGravatarProfilePicture!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = _data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.allowUsingGravatarProfilePicture = _data["allowUsingGravatarProfilePicture"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["allowUsingGravatarProfilePicture"] = this.allowUsingGravatarProfilePicture;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    useCaptchaOnLogin: boolean;
    allowUsingGravatarProfilePicture: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredTenantActiveByDefault!: boolean;
    useCaptchaOnRegistration!: boolean;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = _data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.defaultEditionId = _data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean;
    requireLowercase!: boolean;
    requireNonAlphanumeric!: boolean;
    requireUppercase!: boolean;
    requiredLength!: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requireDigit = _data["requireDigit"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireUppercase = _data["requireUppercase"];
            this.requiredLength = _data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean;
    maxFailedAccessAttemptsBeforeLockout!: number;
    defaultAccountLockoutSeconds!: number;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = _data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = _data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean;
    isEnabled!: boolean;
    isEmailProviderEnabled!: boolean;
    isSmsProviderEnabled!: boolean;
    isRememberBrowserEnabled!: boolean;
    isGoogleAuthenticatorEnabled!: boolean;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabledForApplication = _data["isEnabledForApplication"];
            this.isEnabled = _data["isEnabled"];
            this.isEmailProviderEnabled = _data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = _data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = _data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser!: boolean;
    useDefaultPasswordComplexitySettings!: boolean;
    passwordComplexity!: PasswordComplexitySetting;
    defaultPasswordComplexity!: PasswordComplexitySetting;
    userLockOut!: UserLockOutSettingsEditDto;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowOneConcurrentLoginPerUser = _data["allowOneConcurrentLoginPerUser"];
            this.useDefaultPasswordComplexitySettings = _data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = _data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = _data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(_data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = _data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(_data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = _data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(_data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowOneConcurrentLoginPerUser"] = this.allowOneConcurrentLoginPerUser;
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean;
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalName = _data["legalName"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class FacebookExternalLoginProviderSettings implements IFacebookExternalLoginProviderSettings {
    appId!: string | undefined;
    appSecret!: string | undefined;

    constructor(data?: IFacebookExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"];
            this.appSecret = _data["appSecret"];
        }
    }

    static fromJS(data: any): FacebookExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["appSecret"] = this.appSecret;
        return data; 
    }
}

export interface IFacebookExternalLoginProviderSettings {
    appId: string | undefined;
    appSecret: string | undefined;
}

export class GoogleExternalLoginProviderSettings implements IGoogleExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    userInfoEndpoint!: string | undefined;

    constructor(data?: IGoogleExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.userInfoEndpoint = _data["userInfoEndpoint"];
        }
    }

    static fromJS(data: any): GoogleExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["userInfoEndpoint"] = this.userInfoEndpoint;
        return data; 
    }
}

export interface IGoogleExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
    userInfoEndpoint: string | undefined;
}

export class TwitterExternalLoginProviderSettings implements ITwitterExternalLoginProviderSettings {
    consumerKey!: string | undefined;
    consumerSecret!: string | undefined;

    constructor(data?: ITwitterExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerKey = _data["consumerKey"];
            this.consumerSecret = _data["consumerSecret"];
        }
    }

    static fromJS(data: any): TwitterExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerKey"] = this.consumerKey;
        data["consumerSecret"] = this.consumerSecret;
        return data; 
    }
}

export interface ITwitterExternalLoginProviderSettings {
    consumerKey: string | undefined;
    consumerSecret: string | undefined;
}

export class MicrosoftExternalLoginProviderSettings implements IMicrosoftExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;

    constructor(data?: IMicrosoftExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
        }
    }

    static fromJS(data: any): MicrosoftExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MicrosoftExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data; 
    }
}

export interface IMicrosoftExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
}

export class OpenIdConnectExternalLoginProviderSettings implements IOpenIdConnectExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    authority!: string | undefined;
    loginUrl!: string | undefined;
    validateIssuer!: boolean;

    constructor(data?: IOpenIdConnectExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.authority = _data["authority"];
            this.loginUrl = _data["loginUrl"];
            this.validateIssuer = _data["validateIssuer"];
        }
    }

    static fromJS(data: any): OpenIdConnectExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new OpenIdConnectExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["authority"] = this.authority;
        data["loginUrl"] = this.loginUrl;
        data["validateIssuer"] = this.validateIssuer;
        return data; 
    }
}

export interface IOpenIdConnectExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
    authority: string | undefined;
    loginUrl: string | undefined;
    validateIssuer: boolean;
}

export class JsonClaimMapDto implements IJsonClaimMapDto {
    claim!: string | undefined;
    key!: string | undefined;

    constructor(data?: IJsonClaimMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claim = _data["claim"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): JsonClaimMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new JsonClaimMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claim"] = this.claim;
        data["key"] = this.key;
        return data; 
    }
}

export interface IJsonClaimMapDto {
    claim: string | undefined;
    key: string | undefined;
}

export class WsFederationExternalLoginProviderSettings implements IWsFederationExternalLoginProviderSettings {
    clientId!: string | undefined;
    tenant!: string | undefined;
    metaDataAddress!: string | undefined;
    wtrealm!: string | undefined;
    authority!: string | undefined;

    constructor(data?: IWsFederationExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.tenant = _data["tenant"];
            this.metaDataAddress = _data["metaDataAddress"];
            this.wtrealm = _data["wtrealm"];
            this.authority = _data["authority"];
        }
    }

    static fromJS(data: any): WsFederationExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new WsFederationExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["tenant"] = this.tenant;
        data["metaDataAddress"] = this.metaDataAddress;
        data["wtrealm"] = this.wtrealm;
        data["authority"] = this.authority;
        return data; 
    }
}

export interface IWsFederationExternalLoginProviderSettings {
    clientId: string | undefined;
    tenant: string | undefined;
    metaDataAddress: string | undefined;
    wtrealm: string | undefined;
    authority: string | undefined;
}

export class ExternalLoginProviderSettingsEditDto implements IExternalLoginProviderSettingsEditDto {
    facebook_IsDeactivated!: boolean;
    facebook!: FacebookExternalLoginProviderSettings;
    google_IsDeactivated!: boolean;
    google!: GoogleExternalLoginProviderSettings;
    twitter_IsDeactivated!: boolean;
    twitter!: TwitterExternalLoginProviderSettings;
    microsoft_IsDeactivated!: boolean;
    microsoft!: MicrosoftExternalLoginProviderSettings;
    openIdConnect_IsDeactivated!: boolean;
    openIdConnect!: OpenIdConnectExternalLoginProviderSettings;
    openIdConnectClaimsMapping!: JsonClaimMapDto[] | undefined;
    wsFederation_IsDeactivated!: boolean;
    wsFederation!: WsFederationExternalLoginProviderSettings;
    wsFederationClaimsMapping!: JsonClaimMapDto[] | undefined;

    constructor(data?: IExternalLoginProviderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facebook_IsDeactivated = _data["facebook_IsDeactivated"];
            this.facebook = _data["facebook"] ? FacebookExternalLoginProviderSettings.fromJS(_data["facebook"]) : <any>undefined;
            this.google_IsDeactivated = _data["google_IsDeactivated"];
            this.google = _data["google"] ? GoogleExternalLoginProviderSettings.fromJS(_data["google"]) : <any>undefined;
            this.twitter_IsDeactivated = _data["twitter_IsDeactivated"];
            this.twitter = _data["twitter"] ? TwitterExternalLoginProviderSettings.fromJS(_data["twitter"]) : <any>undefined;
            this.microsoft_IsDeactivated = _data["microsoft_IsDeactivated"];
            this.microsoft = _data["microsoft"] ? MicrosoftExternalLoginProviderSettings.fromJS(_data["microsoft"]) : <any>undefined;
            this.openIdConnect_IsDeactivated = _data["openIdConnect_IsDeactivated"];
            this.openIdConnect = _data["openIdConnect"] ? OpenIdConnectExternalLoginProviderSettings.fromJS(_data["openIdConnect"]) : <any>undefined;
            if (Array.isArray(_data["openIdConnectClaimsMapping"])) {
                this.openIdConnectClaimsMapping = [] as any;
                for (let item of _data["openIdConnectClaimsMapping"])
                    this.openIdConnectClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
            }
            this.wsFederation_IsDeactivated = _data["wsFederation_IsDeactivated"];
            this.wsFederation = _data["wsFederation"] ? WsFederationExternalLoginProviderSettings.fromJS(_data["wsFederation"]) : <any>undefined;
            if (Array.isArray(_data["wsFederationClaimsMapping"])) {
                this.wsFederationClaimsMapping = [] as any;
                for (let item of _data["wsFederationClaimsMapping"])
                    this.wsFederationClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facebook_IsDeactivated"] = this.facebook_IsDeactivated;
        data["facebook"] = this.facebook ? this.facebook.toJSON() : <any>undefined;
        data["google_IsDeactivated"] = this.google_IsDeactivated;
        data["google"] = this.google ? this.google.toJSON() : <any>undefined;
        data["twitter_IsDeactivated"] = this.twitter_IsDeactivated;
        data["twitter"] = this.twitter ? this.twitter.toJSON() : <any>undefined;
        data["microsoft_IsDeactivated"] = this.microsoft_IsDeactivated;
        data["microsoft"] = this.microsoft ? this.microsoft.toJSON() : <any>undefined;
        data["openIdConnect_IsDeactivated"] = this.openIdConnect_IsDeactivated;
        data["openIdConnect"] = this.openIdConnect ? this.openIdConnect.toJSON() : <any>undefined;
        if (Array.isArray(this.openIdConnectClaimsMapping)) {
            data["openIdConnectClaimsMapping"] = [];
            for (let item of this.openIdConnectClaimsMapping)
                data["openIdConnectClaimsMapping"].push(item.toJSON());
        }
        data["wsFederation_IsDeactivated"] = this.wsFederation_IsDeactivated;
        data["wsFederation"] = this.wsFederation ? this.wsFederation.toJSON() : <any>undefined;
        if (Array.isArray(this.wsFederationClaimsMapping)) {
            data["wsFederationClaimsMapping"] = [];
            for (let item of this.wsFederationClaimsMapping)
                data["wsFederationClaimsMapping"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IExternalLoginProviderSettingsEditDto {
    facebook_IsDeactivated: boolean;
    facebook: FacebookExternalLoginProviderSettings;
    google_IsDeactivated: boolean;
    google: GoogleExternalLoginProviderSettings;
    twitter_IsDeactivated: boolean;
    twitter: TwitterExternalLoginProviderSettings;
    microsoft_IsDeactivated: boolean;
    microsoft: MicrosoftExternalLoginProviderSettings;
    openIdConnect_IsDeactivated: boolean;
    openIdConnect: OpenIdConnectExternalLoginProviderSettings;
    openIdConnectClaimsMapping: JsonClaimMapDto[] | undefined;
    wsFederation_IsDeactivated: boolean;
    wsFederation: WsFederationExternalLoginProviderSettings;
    wsFederationClaimsMapping: JsonClaimMapDto[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto;
    otherSettings!: OtherSettingsEditDto;
    externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = _data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = _data["email"] ? EmailSettingsEditDto.fromJS(_data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = _data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(_data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? HostBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? OtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
            this.externalLoginProviderSettings = _data["externalLoginProviderSettings"] ? ExternalLoginProviderSettingsEditDto.fromJS(_data["externalLoginProviderSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["externalLoginProviderSettings"] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;
    otherSettings: OtherSettingsEditDto;
    externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class ExternalLoginSettingsDto implements IExternalLoginSettingsDto {
    enabledSocialLoginSettings!: string[] | undefined;

    constructor(data?: IExternalLoginSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["enabledSocialLoginSettings"])) {
                this.enabledSocialLoginSettings = [] as any;
                for (let item of _data["enabledSocialLoginSettings"])
                    this.enabledSocialLoginSettings!.push(item);
            }
        }
    }

    static fromJS(data: any): ExternalLoginSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enabledSocialLoginSettings)) {
            data["enabledSocialLoginSettings"] = [];
            for (let item of this.enabledSocialLoginSettings)
                data["enabledSocialLoginSettings"].push(item);
        }
        return data; 
    }
}

export interface IExternalLoginSettingsDto {
    enabledSocialLoginSettings: string[] | undefined;
}

export class IndustrySectorDto implements IIndustrySectorDto {
    id!: number;
    name!: string | undefined;
    isActive!: boolean;

    constructor(data?: IIndustrySectorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): IndustrySectorDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndustrySectorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IIndustrySectorDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto;
    billInfo!: HostBillingSettingsEditDto;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionString = _data["connectionString"];
            this.adminPassword = _data["adminPassword"];
            this.webSiteUrl = _data["webSiteUrl"];
            this.serverUrl = _data["serverUrl"];
            this.defaultLanguage = _data["defaultLanguage"];
            this.smtpSettings = _data["smtpSettings"] ? EmailSettingsEditDto.fromJS(_data["smtpSettings"]) : <any>undefined;
            this.billInfo = _data["billInfo"] ? HostBillingSettingsEditDto.fromJS(_data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto;
    billInfo: HostBillingSettingsEditDto;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webSiteUrl = _data["webSiteUrl"];
            this.serverSiteUrl = _data["serverSiteUrl"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isDatabaseExist = _data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: DateTime;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.invoiceNo = _data["invoiceNo"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = _data["tenantLegalName"];
            if (Array.isArray(_data["tenantAddress"])) {
                this.tenantAddress = [] as any;
                for (let item of _data["tenantAddress"])
                    this.tenantAddress!.push(item);
            }
            this.tenantTaxNo = _data["tenantTaxNo"];
            this.hostLegalName = _data["hostLegalName"];
            if (Array.isArray(_data["hostAddress"])) {
                this.hostAddress = [] as any;
                for (let item of _data["hostAddress"])
                    this.hostAddress!.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (Array.isArray(this.tenantAddress)) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (Array.isArray(this.hostAddress)) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }
}

export interface IInvoiceDto {
    amount: number;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: DateTime;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionPaymentId = _data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number;
}

export class GetITserviceForBusinessServiceDto implements IGetITserviceForBusinessServiceDto {
    id!: number;
    itServiceName!: string | undefined;

    constructor(data?: IGetITserviceForBusinessServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itServiceName = _data["itServiceName"];
        }
    }

    static fromJS(data: any): GetITserviceForBusinessServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetITserviceForBusinessServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itServiceName"] = this.itServiceName;
        return data; 
    }
}

export interface IGetITserviceForBusinessServiceDto {
    id: number;
    itServiceName: string | undefined;
}

export class ITserviceBusinessUnitDto implements IITserviceBusinessUnitDto {
    itServiceId!: number | undefined;
    businessUnitId!: number | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IITserviceBusinessUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itServiceId = _data["itServiceId"];
            this.businessUnitId = _data["businessUnitId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ITserviceBusinessUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ITserviceBusinessUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itServiceId"] = this.itServiceId;
        data["businessUnitId"] = this.businessUnitId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IITserviceBusinessUnitDto {
    itServiceId: number | undefined;
    businessUnitId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ITserviceDto implements IITserviceDto {
    tenantId!: number | undefined;
    itServicesId!: string | undefined;
    itServiceName!: string | undefined;
    serviceTypeId!: number | undefined;
    serviceTypes!: GetDynamicValueDto[] | undefined;
    serviceClassificationId!: number | undefined;
    serviceClassifications!: GetDynamicValueDto[] | undefined;
    addressLineOne!: string | undefined;
    addressLineTwo!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number | undefined;
    countries!: CountryDto[] | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    itServiceOwnerId!: number | undefined;
    itServiceOwners!: BusinessServiceOwner[] | undefined;
    itServiceManagerId!: number | undefined;
    itServiceManagers!: BusinessServiceOwner[] | undefined;
    businessUnitId!: number | undefined;
    businessUnits!: BusinessUnitPrimaryDto[] | undefined;
    regulatoryMandateId!: number | undefined;
    regulatoryMandates!: GetDynamicValueDto[] | undefined;
    confidentialityId!: number | undefined;
    confidentialitys!: GetDynamicValueDto[] | undefined;
    integrityId!: number | undefined;
    integritys!: GetDynamicValueDto[] | undefined;
    othersId!: number | undefined;
    otheres!: GetDynamicValueDto[] | undefined;
    availibilityId!: number | undefined;
    availibilitys!: GetDynamicValueDto[] | undefined;
    selectedITserviceBusinessServices!: ITserviceBusinessServiceDto[] | undefined;
    removeITserviceBusinessServices!: number[] | undefined;
    selectedITserviceBusinessUnit!: ITserviceBusinessUnitDto[] | undefined;
    businessServices!: BusinessServiceSDto[] | undefined;
    removeITserviceBusinessUnit!: number[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IITserviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.itServicesId = _data["itServicesId"];
            this.itServiceName = _data["itServiceName"];
            this.serviceTypeId = _data["serviceTypeId"];
            if (Array.isArray(_data["serviceTypes"])) {
                this.serviceTypes = [] as any;
                for (let item of _data["serviceTypes"])
                    this.serviceTypes!.push(GetDynamicValueDto.fromJS(item));
            }
            this.serviceClassificationId = _data["serviceClassificationId"];
            if (Array.isArray(_data["serviceClassifications"])) {
                this.serviceClassifications = [] as any;
                for (let item of _data["serviceClassifications"])
                    this.serviceClassifications!.push(GetDynamicValueDto.fromJS(item));
            }
            this.addressLineOne = _data["addressLineOne"];
            this.addressLineTwo = _data["addressLineTwo"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(CountryDto.fromJS(item));
            }
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            this.itServiceOwnerId = _data["itServiceOwnerId"];
            if (Array.isArray(_data["itServiceOwners"])) {
                this.itServiceOwners = [] as any;
                for (let item of _data["itServiceOwners"])
                    this.itServiceOwners!.push(BusinessServiceOwner.fromJS(item));
            }
            this.itServiceManagerId = _data["itServiceManagerId"];
            if (Array.isArray(_data["itServiceManagers"])) {
                this.itServiceManagers = [] as any;
                for (let item of _data["itServiceManagers"])
                    this.itServiceManagers!.push(BusinessServiceOwner.fromJS(item));
            }
            this.businessUnitId = _data["businessUnitId"];
            if (Array.isArray(_data["businessUnits"])) {
                this.businessUnits = [] as any;
                for (let item of _data["businessUnits"])
                    this.businessUnits!.push(BusinessUnitPrimaryDto.fromJS(item));
            }
            this.regulatoryMandateId = _data["regulatoryMandateId"];
            if (Array.isArray(_data["regulatoryMandates"])) {
                this.regulatoryMandates = [] as any;
                for (let item of _data["regulatoryMandates"])
                    this.regulatoryMandates!.push(GetDynamicValueDto.fromJS(item));
            }
            this.confidentialityId = _data["confidentialityId"];
            if (Array.isArray(_data["confidentialitys"])) {
                this.confidentialitys = [] as any;
                for (let item of _data["confidentialitys"])
                    this.confidentialitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.integrityId = _data["integrityId"];
            if (Array.isArray(_data["integritys"])) {
                this.integritys = [] as any;
                for (let item of _data["integritys"])
                    this.integritys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.othersId = _data["othersId"];
            if (Array.isArray(_data["otheres"])) {
                this.otheres = [] as any;
                for (let item of _data["otheres"])
                    this.otheres!.push(GetDynamicValueDto.fromJS(item));
            }
            this.availibilityId = _data["availibilityId"];
            if (Array.isArray(_data["availibilitys"])) {
                this.availibilitys = [] as any;
                for (let item of _data["availibilitys"])
                    this.availibilitys!.push(GetDynamicValueDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedITserviceBusinessServices"])) {
                this.selectedITserviceBusinessServices = [] as any;
                for (let item of _data["selectedITserviceBusinessServices"])
                    this.selectedITserviceBusinessServices!.push(ITserviceBusinessServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["removeITserviceBusinessServices"])) {
                this.removeITserviceBusinessServices = [] as any;
                for (let item of _data["removeITserviceBusinessServices"])
                    this.removeITserviceBusinessServices!.push(item);
            }
            if (Array.isArray(_data["selectedITserviceBusinessUnit"])) {
                this.selectedITserviceBusinessUnit = [] as any;
                for (let item of _data["selectedITserviceBusinessUnit"])
                    this.selectedITserviceBusinessUnit!.push(ITserviceBusinessUnitDto.fromJS(item));
            }
            if (Array.isArray(_data["businessServices"])) {
                this.businessServices = [] as any;
                for (let item of _data["businessServices"])
                    this.businessServices!.push(BusinessServiceSDto.fromJS(item));
            }
            if (Array.isArray(_data["removeITserviceBusinessUnit"])) {
                this.removeITserviceBusinessUnit = [] as any;
                for (let item of _data["removeITserviceBusinessUnit"])
                    this.removeITserviceBusinessUnit!.push(item);
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ITserviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ITserviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["itServicesId"] = this.itServicesId;
        data["itServiceName"] = this.itServiceName;
        data["serviceTypeId"] = this.serviceTypeId;
        if (Array.isArray(this.serviceTypes)) {
            data["serviceTypes"] = [];
            for (let item of this.serviceTypes)
                data["serviceTypes"].push(item.toJSON());
        }
        data["serviceClassificationId"] = this.serviceClassificationId;
        if (Array.isArray(this.serviceClassifications)) {
            data["serviceClassifications"] = [];
            for (let item of this.serviceClassifications)
                data["serviceClassifications"].push(item.toJSON());
        }
        data["addressLineOne"] = this.addressLineOne;
        data["addressLineTwo"] = this.addressLineTwo;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        data["itServiceOwnerId"] = this.itServiceOwnerId;
        if (Array.isArray(this.itServiceOwners)) {
            data["itServiceOwners"] = [];
            for (let item of this.itServiceOwners)
                data["itServiceOwners"].push(item.toJSON());
        }
        data["itServiceManagerId"] = this.itServiceManagerId;
        if (Array.isArray(this.itServiceManagers)) {
            data["itServiceManagers"] = [];
            for (let item of this.itServiceManagers)
                data["itServiceManagers"].push(item.toJSON());
        }
        data["businessUnitId"] = this.businessUnitId;
        if (Array.isArray(this.businessUnits)) {
            data["businessUnits"] = [];
            for (let item of this.businessUnits)
                data["businessUnits"].push(item.toJSON());
        }
        data["regulatoryMandateId"] = this.regulatoryMandateId;
        if (Array.isArray(this.regulatoryMandates)) {
            data["regulatoryMandates"] = [];
            for (let item of this.regulatoryMandates)
                data["regulatoryMandates"].push(item.toJSON());
        }
        data["confidentialityId"] = this.confidentialityId;
        if (Array.isArray(this.confidentialitys)) {
            data["confidentialitys"] = [];
            for (let item of this.confidentialitys)
                data["confidentialitys"].push(item.toJSON());
        }
        data["integrityId"] = this.integrityId;
        if (Array.isArray(this.integritys)) {
            data["integritys"] = [];
            for (let item of this.integritys)
                data["integritys"].push(item.toJSON());
        }
        data["othersId"] = this.othersId;
        if (Array.isArray(this.otheres)) {
            data["otheres"] = [];
            for (let item of this.otheres)
                data["otheres"].push(item.toJSON());
        }
        data["availibilityId"] = this.availibilityId;
        if (Array.isArray(this.availibilitys)) {
            data["availibilitys"] = [];
            for (let item of this.availibilitys)
                data["availibilitys"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedITserviceBusinessServices)) {
            data["selectedITserviceBusinessServices"] = [];
            for (let item of this.selectedITserviceBusinessServices)
                data["selectedITserviceBusinessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.removeITserviceBusinessServices)) {
            data["removeITserviceBusinessServices"] = [];
            for (let item of this.removeITserviceBusinessServices)
                data["removeITserviceBusinessServices"].push(item);
        }
        if (Array.isArray(this.selectedITserviceBusinessUnit)) {
            data["selectedITserviceBusinessUnit"] = [];
            for (let item of this.selectedITserviceBusinessUnit)
                data["selectedITserviceBusinessUnit"].push(item.toJSON());
        }
        if (Array.isArray(this.businessServices)) {
            data["businessServices"] = [];
            for (let item of this.businessServices)
                data["businessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.removeITserviceBusinessUnit)) {
            data["removeITserviceBusinessUnit"] = [];
            for (let item of this.removeITserviceBusinessUnit)
                data["removeITserviceBusinessUnit"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IITserviceDto {
    tenantId: number | undefined;
    itServicesId: string | undefined;
    itServiceName: string | undefined;
    serviceTypeId: number | undefined;
    serviceTypes: GetDynamicValueDto[] | undefined;
    serviceClassificationId: number | undefined;
    serviceClassifications: GetDynamicValueDto[] | undefined;
    addressLineOne: string | undefined;
    addressLineTwo: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    countryId: number | undefined;
    countries: CountryDto[] | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    itServiceOwnerId: number | undefined;
    itServiceOwners: BusinessServiceOwner[] | undefined;
    itServiceManagerId: number | undefined;
    itServiceManagers: BusinessServiceOwner[] | undefined;
    businessUnitId: number | undefined;
    businessUnits: BusinessUnitPrimaryDto[] | undefined;
    regulatoryMandateId: number | undefined;
    regulatoryMandates: GetDynamicValueDto[] | undefined;
    confidentialityId: number | undefined;
    confidentialitys: GetDynamicValueDto[] | undefined;
    integrityId: number | undefined;
    integritys: GetDynamicValueDto[] | undefined;
    othersId: number | undefined;
    otheres: GetDynamicValueDto[] | undefined;
    availibilityId: number | undefined;
    availibilitys: GetDynamicValueDto[] | undefined;
    selectedITserviceBusinessServices: ITserviceBusinessServiceDto[] | undefined;
    removeITserviceBusinessServices: number[] | undefined;
    selectedITserviceBusinessUnit: ITserviceBusinessUnitDto[] | undefined;
    businessServices: BusinessServiceSDto[] | undefined;
    removeITserviceBusinessUnit: number[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class GetITserviceListDto implements IGetITserviceListDto {
    itServicesId!: string | undefined;
    itServiceName!: string | undefined;
    serviceTypeId!: number | undefined;
    serviceType!: DynamicPropertyValue;
    serviceClassificationId!: number | undefined;
    serviceClassification!: DynamicPropertyValue;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationDto;
    itServiceOwnerId!: number | undefined;
    itServiceOwner!: GetEmployeeForEditDto;
    businessUnitId!: number | undefined;
    businessUnit!: BusinessUnitPrimaryDto;
    confidentialityId!: number | undefined;
    confidentiality!: DynamicPropertyValue;
    integrityId!: number | undefined;
    integrity!: DynamicPropertyValue;
    othersId!: number | undefined;
    others!: DynamicPropertyValue;
    availibilityId!: number | undefined;
    availibility!: DynamicPropertyValue;
    id!: number;

    constructor(data?: IGetITserviceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itServicesId = _data["itServicesId"];
            this.itServiceName = _data["itServiceName"];
            this.serviceTypeId = _data["serviceTypeId"];
            this.serviceType = _data["serviceType"] ? DynamicPropertyValue.fromJS(_data["serviceType"]) : <any>undefined;
            this.serviceClassificationId = _data["serviceClassificationId"];
            this.serviceClassification = _data["serviceClassification"] ? DynamicPropertyValue.fromJS(_data["serviceClassification"]) : <any>undefined;
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.itServiceOwnerId = _data["itServiceOwnerId"];
            this.itServiceOwner = _data["itServiceOwner"] ? GetEmployeeForEditDto.fromJS(_data["itServiceOwner"]) : <any>undefined;
            this.businessUnitId = _data["businessUnitId"];
            this.businessUnit = _data["businessUnit"] ? BusinessUnitPrimaryDto.fromJS(_data["businessUnit"]) : <any>undefined;
            this.confidentialityId = _data["confidentialityId"];
            this.confidentiality = _data["confidentiality"] ? DynamicPropertyValue.fromJS(_data["confidentiality"]) : <any>undefined;
            this.integrityId = _data["integrityId"];
            this.integrity = _data["integrity"] ? DynamicPropertyValue.fromJS(_data["integrity"]) : <any>undefined;
            this.othersId = _data["othersId"];
            this.others = _data["others"] ? DynamicPropertyValue.fromJS(_data["others"]) : <any>undefined;
            this.availibilityId = _data["availibilityId"];
            this.availibility = _data["availibility"] ? DynamicPropertyValue.fromJS(_data["availibility"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetITserviceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetITserviceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itServicesId"] = this.itServicesId;
        data["itServiceName"] = this.itServiceName;
        data["serviceTypeId"] = this.serviceTypeId;
        data["serviceType"] = this.serviceType ? this.serviceType.toJSON() : <any>undefined;
        data["serviceClassificationId"] = this.serviceClassificationId;
        data["serviceClassification"] = this.serviceClassification ? this.serviceClassification.toJSON() : <any>undefined;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["itServiceOwnerId"] = this.itServiceOwnerId;
        data["itServiceOwner"] = this.itServiceOwner ? this.itServiceOwner.toJSON() : <any>undefined;
        data["businessUnitId"] = this.businessUnitId;
        data["businessUnit"] = this.businessUnit ? this.businessUnit.toJSON() : <any>undefined;
        data["confidentialityId"] = this.confidentialityId;
        data["confidentiality"] = this.confidentiality ? this.confidentiality.toJSON() : <any>undefined;
        data["integrityId"] = this.integrityId;
        data["integrity"] = this.integrity ? this.integrity.toJSON() : <any>undefined;
        data["othersId"] = this.othersId;
        data["others"] = this.others ? this.others.toJSON() : <any>undefined;
        data["availibilityId"] = this.availibilityId;
        data["availibility"] = this.availibility ? this.availibility.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetITserviceListDto {
    itServicesId: string | undefined;
    itServiceName: string | undefined;
    serviceTypeId: number | undefined;
    serviceType: DynamicPropertyValue;
    serviceClassificationId: number | undefined;
    serviceClassification: DynamicPropertyValue;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationDto;
    itServiceOwnerId: number | undefined;
    itServiceOwner: GetEmployeeForEditDto;
    businessUnitId: number | undefined;
    businessUnit: BusinessUnitPrimaryDto;
    confidentialityId: number | undefined;
    confidentiality: DynamicPropertyValue;
    integrityId: number | undefined;
    integrity: DynamicPropertyValue;
    othersId: number | undefined;
    others: DynamicPropertyValue;
    availibilityId: number | undefined;
    availibility: DynamicPropertyValue;
    id: number;
}

export class PagedResultDtoOfGetITserviceListDto implements IPagedResultDtoOfGetITserviceListDto {
    totalCount!: number;
    items!: GetITserviceListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetITserviceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetITserviceListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetITserviceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetITserviceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetITserviceListDto {
    totalCount: number;
    items: GetITserviceListDto[] | undefined;
}

export class KPIAdminisratorDto implements IKPIAdminisratorDto {
    id!: number;
    keyPerformanceIndicatorId!: number | undefined;
    employeeId!: number | undefined;

    constructor(data?: IKPIAdminisratorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.keyPerformanceIndicatorId = _data["keyPerformanceIndicatorId"];
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): KPIAdminisratorDto {
        data = typeof data === 'object' ? data : {};
        let result = new KPIAdminisratorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["keyPerformanceIndicatorId"] = this.keyPerformanceIndicatorId;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface IKPIAdminisratorDto {
    id: number;
    keyPerformanceIndicatorId: number | undefined;
    employeeId: number | undefined;
}

export class KPIBusinessUnitDto implements IKPIBusinessUnitDto {
    id!: number;
    keyPerformanceIndicatorId!: number | undefined;
    businessUnitId!: number | undefined;

    constructor(data?: IKPIBusinessUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.keyPerformanceIndicatorId = _data["keyPerformanceIndicatorId"];
            this.businessUnitId = _data["businessUnitId"];
        }
    }

    static fromJS(data: any): KPIBusinessUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new KPIBusinessUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["keyPerformanceIndicatorId"] = this.keyPerformanceIndicatorId;
        data["businessUnitId"] = this.businessUnitId;
        return data; 
    }
}

export interface IKPIBusinessUnitDto {
    id: number;
    keyPerformanceIndicatorId: number | undefined;
    businessUnitId: number | undefined;
}

export class KeyPerformanceDto implements IKeyPerformanceDto {
    tenantId!: number | undefined;
    keyPerformanceIndicatorId!: string | undefined;
    keyPerformanceIndicatorTitle!: string | undefined;
    statusId!: number | undefined;
    statuses!: GetDynamicValueDto[] | undefined;
    frequencyId!: number | undefined;
    frequencys!: GetDynamicValueDto[] | undefined;
    description!: string | undefined;
    employeeId!: number | undefined;
    businessUnits!: BusinessUnitPrimaryDto[] | undefined;
    programUser!: ProgramUser[] | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    selectedAdministrators!: KPIAdminisratorDto[] | undefined;
    removeAdministrators!: number[] | undefined;
    selectedBusinessUnits!: KPIBusinessUnitDto[] | undefined;
    removeBusinessUnits!: number[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IKeyPerformanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.keyPerformanceIndicatorId = _data["keyPerformanceIndicatorId"];
            this.keyPerformanceIndicatorTitle = _data["keyPerformanceIndicatorTitle"];
            this.statusId = _data["statusId"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(GetDynamicValueDto.fromJS(item));
            }
            this.frequencyId = _data["frequencyId"];
            if (Array.isArray(_data["frequencys"])) {
                this.frequencys = [] as any;
                for (let item of _data["frequencys"])
                    this.frequencys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.description = _data["description"];
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["businessUnits"])) {
                this.businessUnits = [] as any;
                for (let item of _data["businessUnits"])
                    this.businessUnits!.push(BusinessUnitPrimaryDto.fromJS(item));
            }
            if (Array.isArray(_data["programUser"])) {
                this.programUser = [] as any;
                for (let item of _data["programUser"])
                    this.programUser!.push(ProgramUser.fromJS(item));
            }
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAdministrators"])) {
                this.selectedAdministrators = [] as any;
                for (let item of _data["selectedAdministrators"])
                    this.selectedAdministrators!.push(KPIAdminisratorDto.fromJS(item));
            }
            if (Array.isArray(_data["removeAdministrators"])) {
                this.removeAdministrators = [] as any;
                for (let item of _data["removeAdministrators"])
                    this.removeAdministrators!.push(item);
            }
            if (Array.isArray(_data["selectedBusinessUnits"])) {
                this.selectedBusinessUnits = [] as any;
                for (let item of _data["selectedBusinessUnits"])
                    this.selectedBusinessUnits!.push(KPIBusinessUnitDto.fromJS(item));
            }
            if (Array.isArray(_data["removeBusinessUnits"])) {
                this.removeBusinessUnits = [] as any;
                for (let item of _data["removeBusinessUnits"])
                    this.removeBusinessUnits!.push(item);
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): KeyPerformanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyPerformanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["keyPerformanceIndicatorId"] = this.keyPerformanceIndicatorId;
        data["keyPerformanceIndicatorTitle"] = this.keyPerformanceIndicatorTitle;
        data["statusId"] = this.statusId;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        data["frequencyId"] = this.frequencyId;
        if (Array.isArray(this.frequencys)) {
            data["frequencys"] = [];
            for (let item of this.frequencys)
                data["frequencys"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.businessUnits)) {
            data["businessUnits"] = [];
            for (let item of this.businessUnits)
                data["businessUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.programUser)) {
            data["programUser"] = [];
            for (let item of this.programUser)
                data["programUser"].push(item.toJSON());
        }
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAdministrators)) {
            data["selectedAdministrators"] = [];
            for (let item of this.selectedAdministrators)
                data["selectedAdministrators"].push(item.toJSON());
        }
        if (Array.isArray(this.removeAdministrators)) {
            data["removeAdministrators"] = [];
            for (let item of this.removeAdministrators)
                data["removeAdministrators"].push(item);
        }
        if (Array.isArray(this.selectedBusinessUnits)) {
            data["selectedBusinessUnits"] = [];
            for (let item of this.selectedBusinessUnits)
                data["selectedBusinessUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.removeBusinessUnits)) {
            data["removeBusinessUnits"] = [];
            for (let item of this.removeBusinessUnits)
                data["removeBusinessUnits"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IKeyPerformanceDto {
    tenantId: number | undefined;
    keyPerformanceIndicatorId: string | undefined;
    keyPerformanceIndicatorTitle: string | undefined;
    statusId: number | undefined;
    statuses: GetDynamicValueDto[] | undefined;
    frequencyId: number | undefined;
    frequencys: GetDynamicValueDto[] | undefined;
    description: string | undefined;
    employeeId: number | undefined;
    businessUnits: BusinessUnitPrimaryDto[] | undefined;
    programUser: ProgramUser[] | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    selectedAdministrators: KPIAdminisratorDto[] | undefined;
    removeAdministrators: number[] | undefined;
    selectedBusinessUnits: KPIBusinessUnitDto[] | undefined;
    removeBusinessUnits: number[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class KeyPerformanceIndicatorListDto implements IKeyPerformanceIndicatorListDto {
    keyPerformanceIndicatorId!: string | undefined;
    keyPerformanceIndicatorTitle!: string;
    statusId!: number | undefined;
    status!: DynamicPropertyValue;
    frequencyId!: number | undefined;
    frequency!: DynamicPropertyValue;
    isActive!: boolean;
    creationTime!: DateTime;
    description!: string | undefined;
    id!: number;

    constructor(data?: IKeyPerformanceIndicatorListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyPerformanceIndicatorId = _data["keyPerformanceIndicatorId"];
            this.keyPerformanceIndicatorTitle = _data["keyPerformanceIndicatorTitle"];
            this.statusId = _data["statusId"];
            this.status = _data["status"] ? DynamicPropertyValue.fromJS(_data["status"]) : <any>undefined;
            this.frequencyId = _data["frequencyId"];
            this.frequency = _data["frequency"] ? DynamicPropertyValue.fromJS(_data["frequency"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): KeyPerformanceIndicatorListDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyPerformanceIndicatorListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyPerformanceIndicatorId"] = this.keyPerformanceIndicatorId;
        data["keyPerformanceIndicatorTitle"] = this.keyPerformanceIndicatorTitle;
        data["statusId"] = this.statusId;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IKeyPerformanceIndicatorListDto {
    keyPerformanceIndicatorId: string | undefined;
    keyPerformanceIndicatorTitle: string;
    statusId: number | undefined;
    status: DynamicPropertyValue;
    frequencyId: number | undefined;
    frequency: DynamicPropertyValue;
    isActive: boolean;
    creationTime: DateTime;
    description: string | undefined;
    id: number;
}

export class PagedResultDtoOfKeyPerformanceIndicatorListDto implements IPagedResultDtoOfKeyPerformanceIndicatorListDto {
    totalCount!: number;
    items!: KeyPerformanceIndicatorListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfKeyPerformanceIndicatorListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(KeyPerformanceIndicatorListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfKeyPerformanceIndicatorListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfKeyPerformanceIndicatorListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfKeyPerformanceIndicatorListDto {
    totalCount: number;
    items: KeyPerformanceIndicatorListDto[] | undefined;
}

export class BusinessUnitKeyRiskDto implements IBusinessUnitKeyRiskDto {
    id!: number;
    keyRiskIndicatorId!: number | undefined;
    businessUnitId!: number | undefined;

    constructor(data?: IBusinessUnitKeyRiskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.keyRiskIndicatorId = _data["keyRiskIndicatorId"];
            this.businessUnitId = _data["businessUnitId"];
        }
    }

    static fromJS(data: any): BusinessUnitKeyRiskDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUnitKeyRiskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["keyRiskIndicatorId"] = this.keyRiskIndicatorId;
        data["businessUnitId"] = this.businessUnitId;
        return data; 
    }
}

export interface IBusinessUnitKeyRiskDto {
    id: number;
    keyRiskIndicatorId: number | undefined;
    businessUnitId: number | undefined;
}

export class KeyRiskIndicatorDto implements IKeyRiskIndicatorDto {
    tenantId!: number | undefined;
    keyRiskIndicatorsId!: string | undefined;
    statusId!: number | undefined;
    statuses!: GetDynamicValueDto[] | undefined;
    keyRiskIndicatorTitle!: string | undefined;
    description!: string | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    removeBusinessUnit!: number[] | undefined;
    businessUnits!: BusinessUnitPrimaryDto[] | undefined;
    selectdBusinessUnits!: BusinessUnitKeyRiskDto[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IKeyRiskIndicatorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.keyRiskIndicatorsId = _data["keyRiskIndicatorsId"];
            this.statusId = _data["statusId"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(GetDynamicValueDto.fromJS(item));
            }
            this.keyRiskIndicatorTitle = _data["keyRiskIndicatorTitle"];
            this.description = _data["description"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            if (Array.isArray(_data["removeBusinessUnit"])) {
                this.removeBusinessUnit = [] as any;
                for (let item of _data["removeBusinessUnit"])
                    this.removeBusinessUnit!.push(item);
            }
            if (Array.isArray(_data["businessUnits"])) {
                this.businessUnits = [] as any;
                for (let item of _data["businessUnits"])
                    this.businessUnits!.push(BusinessUnitPrimaryDto.fromJS(item));
            }
            if (Array.isArray(_data["selectdBusinessUnits"])) {
                this.selectdBusinessUnits = [] as any;
                for (let item of _data["selectdBusinessUnits"])
                    this.selectdBusinessUnits!.push(BusinessUnitKeyRiskDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): KeyRiskIndicatorDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyRiskIndicatorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["keyRiskIndicatorsId"] = this.keyRiskIndicatorsId;
        data["statusId"] = this.statusId;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        data["keyRiskIndicatorTitle"] = this.keyRiskIndicatorTitle;
        data["description"] = this.description;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        if (Array.isArray(this.removeBusinessUnit)) {
            data["removeBusinessUnit"] = [];
            for (let item of this.removeBusinessUnit)
                data["removeBusinessUnit"].push(item);
        }
        if (Array.isArray(this.businessUnits)) {
            data["businessUnits"] = [];
            for (let item of this.businessUnits)
                data["businessUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.selectdBusinessUnits)) {
            data["selectdBusinessUnits"] = [];
            for (let item of this.selectdBusinessUnits)
                data["selectdBusinessUnits"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IKeyRiskIndicatorDto {
    tenantId: number | undefined;
    keyRiskIndicatorsId: string | undefined;
    statusId: number | undefined;
    statuses: GetDynamicValueDto[] | undefined;
    keyRiskIndicatorTitle: string | undefined;
    description: string | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    removeBusinessUnit: number[] | undefined;
    businessUnits: BusinessUnitPrimaryDto[] | undefined;
    selectdBusinessUnits: BusinessUnitKeyRiskDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class KeyRiskIndicatorListDto implements IKeyRiskIndicatorListDto {
    keyRiskIndicatorsId!: string | undefined;
    statusId!: number | undefined;
    status!: DynamicPropertyValue;
    keyRiskIndicatorTitle!: string | undefined;
    description!: string | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IKeyRiskIndicatorListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyRiskIndicatorsId = _data["keyRiskIndicatorsId"];
            this.statusId = _data["statusId"];
            this.status = _data["status"] ? DynamicPropertyValue.fromJS(_data["status"]) : <any>undefined;
            this.keyRiskIndicatorTitle = _data["keyRiskIndicatorTitle"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): KeyRiskIndicatorListDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyRiskIndicatorListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyRiskIndicatorsId"] = this.keyRiskIndicatorsId;
        data["statusId"] = this.statusId;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["keyRiskIndicatorTitle"] = this.keyRiskIndicatorTitle;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IKeyRiskIndicatorListDto {
    keyRiskIndicatorsId: string | undefined;
    statusId: number | undefined;
    status: DynamicPropertyValue;
    keyRiskIndicatorTitle: string | undefined;
    description: string | undefined;
    isActive: boolean;
    creationTime: DateTime;
    id: number;
}

export class PagedResultDtoOfKeyRiskIndicatorListDto implements IPagedResultDtoOfKeyRiskIndicatorListDto {
    totalCount!: number;
    items!: KeyRiskIndicatorListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfKeyRiskIndicatorListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(KeyRiskIndicatorListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfKeyRiskIndicatorListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfKeyRiskIndicatorListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfKeyRiskIndicatorListDto {
    totalCount: number;
    items: KeyRiskIndicatorListDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.isDisabled = _data["isDisabled"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultLanguageName = _data["defaultLanguageName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : <any>undefined;
            if (Array.isArray(_data["languageNames"])) {
                this.languageNames = [] as any;
                for (let item of _data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(_data["flags"])) {
                this.flags = [] as any;
                for (let item of _data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (Array.isArray(this.languageNames)) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (Array.isArray(this.flags)) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.baseValue = _data["baseValue"];
            this.targetValue = _data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
            this.sourceName = _data["sourceName"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class MeetingListDto implements IMeetingListDto {
    id!: number;
    tenantId!: number | undefined;
    meetingId!: string | undefined;
    meetingTitle!: string | undefined;
    meetingDescription!: string | undefined;
    meetingStartDate!: DateTime | undefined;
    meetingEndDate!: DateTime | undefined;
    meetingVenue!: string | undefined;
    meetingLocation!: string | undefined;
    city!: string | undefined;
    countryId!: number | undefined;
    country!: DynamicPropertyValue;
    meetingAgenda!: string | undefined;
    employeeId!: number | undefined;
    employee!: GetEmployeeForEditDto;
    minutesofMeeting!: string | undefined;
    minutesofMeetingAttachedment!: string | undefined;
    meetingConclusion!: string | undefined;
    organizerId!: number | undefined;
    organizer!: GetEmployeeForEditDto;
    meetingTypeId!: number | undefined;
    meetingType!: DynamicPropertyValue;
    meetingClassificationId!: number | undefined;
    meetingClassification!: DynamicPropertyValue;

    constructor(data?: IMeetingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.meetingId = _data["meetingId"];
            this.meetingTitle = _data["meetingTitle"];
            this.meetingDescription = _data["meetingDescription"];
            this.meetingStartDate = _data["meetingStartDate"] ? DateTime.fromISO(_data["meetingStartDate"].toString()) : <any>undefined;
            this.meetingEndDate = _data["meetingEndDate"] ? DateTime.fromISO(_data["meetingEndDate"].toString()) : <any>undefined;
            this.meetingVenue = _data["meetingVenue"];
            this.meetingLocation = _data["meetingLocation"];
            this.city = _data["city"];
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? DynamicPropertyValue.fromJS(_data["country"]) : <any>undefined;
            this.meetingAgenda = _data["meetingAgenda"];
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? GetEmployeeForEditDto.fromJS(_data["employee"]) : <any>undefined;
            this.minutesofMeeting = _data["minutesofMeeting"];
            this.minutesofMeetingAttachedment = _data["minutesofMeetingAttachedment"];
            this.meetingConclusion = _data["meetingConclusion"];
            this.organizerId = _data["organizerId"];
            this.organizer = _data["organizer"] ? GetEmployeeForEditDto.fromJS(_data["organizer"]) : <any>undefined;
            this.meetingTypeId = _data["meetingTypeId"];
            this.meetingType = _data["meetingType"] ? DynamicPropertyValue.fromJS(_data["meetingType"]) : <any>undefined;
            this.meetingClassificationId = _data["meetingClassificationId"];
            this.meetingClassification = _data["meetingClassification"] ? DynamicPropertyValue.fromJS(_data["meetingClassification"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MeetingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["meetingId"] = this.meetingId;
        data["meetingTitle"] = this.meetingTitle;
        data["meetingDescription"] = this.meetingDescription;
        data["meetingStartDate"] = this.meetingStartDate ? this.meetingStartDate.toString() : <any>undefined;
        data["meetingEndDate"] = this.meetingEndDate ? this.meetingEndDate.toString() : <any>undefined;
        data["meetingVenue"] = this.meetingVenue;
        data["meetingLocation"] = this.meetingLocation;
        data["city"] = this.city;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["meetingAgenda"] = this.meetingAgenda;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["minutesofMeeting"] = this.minutesofMeeting;
        data["minutesofMeetingAttachedment"] = this.minutesofMeetingAttachedment;
        data["meetingConclusion"] = this.meetingConclusion;
        data["organizerId"] = this.organizerId;
        data["organizer"] = this.organizer ? this.organizer.toJSON() : <any>undefined;
        data["meetingTypeId"] = this.meetingTypeId;
        data["meetingType"] = this.meetingType ? this.meetingType.toJSON() : <any>undefined;
        data["meetingClassificationId"] = this.meetingClassificationId;
        data["meetingClassification"] = this.meetingClassification ? this.meetingClassification.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMeetingListDto {
    id: number;
    tenantId: number | undefined;
    meetingId: string | undefined;
    meetingTitle: string | undefined;
    meetingDescription: string | undefined;
    meetingStartDate: DateTime | undefined;
    meetingEndDate: DateTime | undefined;
    meetingVenue: string | undefined;
    meetingLocation: string | undefined;
    city: string | undefined;
    countryId: number | undefined;
    country: DynamicPropertyValue;
    meetingAgenda: string | undefined;
    employeeId: number | undefined;
    employee: GetEmployeeForEditDto;
    minutesofMeeting: string | undefined;
    minutesofMeetingAttachedment: string | undefined;
    meetingConclusion: string | undefined;
    organizerId: number | undefined;
    organizer: GetEmployeeForEditDto;
    meetingTypeId: number | undefined;
    meetingType: DynamicPropertyValue;
    meetingClassificationId: number | undefined;
    meetingClassification: DynamicPropertyValue;
}

export class PagedResultDtoOfMeetingListDto implements IPagedResultDtoOfMeetingListDto {
    totalCount!: number;
    items!: MeetingListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMeetingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MeetingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMeetingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMeetingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMeetingListDto {
    totalCount: number;
    items: MeetingListDto[] | undefined;
}

export class MeetingAbsenteeUserDto implements IMeetingAbsenteeUserDto {
    id!: number;
    meetingId!: number | undefined;
    employeeId!: number | undefined;

    constructor(data?: IMeetingAbsenteeUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.meetingId = _data["meetingId"];
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): MeetingAbsenteeUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingAbsenteeUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["meetingId"] = this.meetingId;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface IMeetingAbsenteeUserDto {
    id: number;
    meetingId: number | undefined;
    employeeId: number | undefined;
}

export class MeetingAttendUserDto implements IMeetingAttendUserDto {
    id!: number;
    meetingId!: number | undefined;
    employeeId!: number | undefined;

    constructor(data?: IMeetingAttendUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.meetingId = _data["meetingId"];
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): MeetingAttendUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingAttendUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["meetingId"] = this.meetingId;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface IMeetingAttendUserDto {
    id: number;
    meetingId: number | undefined;
    employeeId: number | undefined;
}

export class MeetingInfoDto implements IMeetingInfoDto {
    tenantId!: number | undefined;
    meetingId!: string | undefined;
    meetingTitle!: string | undefined;
    meetingDescription!: string | undefined;
    meetingStartDate!: DateTime | undefined;
    meetingEndDate!: DateTime | undefined;
    meetingvenueId!: number | undefined;
    meetingLocation!: string | undefined;
    city!: string | undefined;
    countryId!: number | undefined;
    countries!: CountryDto[] | undefined;
    meetingAgenda!: string | undefined;
    employeeId!: number | undefined;
    employeeLists!: ProgramUser[] | undefined;
    minutesofMeeting!: string | undefined;
    minutesofMeetingAttachedment!: string | undefined;
    meetingConclusion!: string | undefined;
    organizerId!: number | undefined;
    employeeOrganizerLists!: ProgramUser[] | undefined;
    meetingTypeId!: number | undefined;
    meetingTypes!: GetDynamicValueDto[] | undefined;
    meetingClassificationId!: number | undefined;
    meetingClassifications!: GetDynamicValueDto[] | undefined;
    selectedMeetingAbsenteeUsers!: MeetingAbsenteeUserDto[] | undefined;
    removeMeetingAbsenteeUsers!: number[] | undefined;
    selectedMeetingAttendUsers!: MeetingAttendUserDto[] | undefined;
    removeMeetingAttendUsers!: number[] | undefined;
    meetingLocationList!: FacilitieDatacenterListDto[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IMeetingInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.meetingId = _data["meetingId"];
            this.meetingTitle = _data["meetingTitle"];
            this.meetingDescription = _data["meetingDescription"];
            this.meetingStartDate = _data["meetingStartDate"] ? DateTime.fromISO(_data["meetingStartDate"].toString()) : <any>undefined;
            this.meetingEndDate = _data["meetingEndDate"] ? DateTime.fromISO(_data["meetingEndDate"].toString()) : <any>undefined;
            this.meetingvenueId = _data["meetingvenueId"];
            this.meetingLocation = _data["meetingLocation"];
            this.city = _data["city"];
            this.countryId = _data["countryId"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(CountryDto.fromJS(item));
            }
            this.meetingAgenda = _data["meetingAgenda"];
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["employeeLists"])) {
                this.employeeLists = [] as any;
                for (let item of _data["employeeLists"])
                    this.employeeLists!.push(ProgramUser.fromJS(item));
            }
            this.minutesofMeeting = _data["minutesofMeeting"];
            this.minutesofMeetingAttachedment = _data["minutesofMeetingAttachedment"];
            this.meetingConclusion = _data["meetingConclusion"];
            this.organizerId = _data["organizerId"];
            if (Array.isArray(_data["employeeOrganizerLists"])) {
                this.employeeOrganizerLists = [] as any;
                for (let item of _data["employeeOrganizerLists"])
                    this.employeeOrganizerLists!.push(ProgramUser.fromJS(item));
            }
            this.meetingTypeId = _data["meetingTypeId"];
            if (Array.isArray(_data["meetingTypes"])) {
                this.meetingTypes = [] as any;
                for (let item of _data["meetingTypes"])
                    this.meetingTypes!.push(GetDynamicValueDto.fromJS(item));
            }
            this.meetingClassificationId = _data["meetingClassificationId"];
            if (Array.isArray(_data["meetingClassifications"])) {
                this.meetingClassifications = [] as any;
                for (let item of _data["meetingClassifications"])
                    this.meetingClassifications!.push(GetDynamicValueDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedMeetingAbsenteeUsers"])) {
                this.selectedMeetingAbsenteeUsers = [] as any;
                for (let item of _data["selectedMeetingAbsenteeUsers"])
                    this.selectedMeetingAbsenteeUsers!.push(MeetingAbsenteeUserDto.fromJS(item));
            }
            if (Array.isArray(_data["removeMeetingAbsenteeUsers"])) {
                this.removeMeetingAbsenteeUsers = [] as any;
                for (let item of _data["removeMeetingAbsenteeUsers"])
                    this.removeMeetingAbsenteeUsers!.push(item);
            }
            if (Array.isArray(_data["selectedMeetingAttendUsers"])) {
                this.selectedMeetingAttendUsers = [] as any;
                for (let item of _data["selectedMeetingAttendUsers"])
                    this.selectedMeetingAttendUsers!.push(MeetingAttendUserDto.fromJS(item));
            }
            if (Array.isArray(_data["removeMeetingAttendUsers"])) {
                this.removeMeetingAttendUsers = [] as any;
                for (let item of _data["removeMeetingAttendUsers"])
                    this.removeMeetingAttendUsers!.push(item);
            }
            if (Array.isArray(_data["meetingLocationList"])) {
                this.meetingLocationList = [] as any;
                for (let item of _data["meetingLocationList"])
                    this.meetingLocationList!.push(FacilitieDatacenterListDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MeetingInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["meetingId"] = this.meetingId;
        data["meetingTitle"] = this.meetingTitle;
        data["meetingDescription"] = this.meetingDescription;
        data["meetingStartDate"] = this.meetingStartDate ? this.meetingStartDate.toString() : <any>undefined;
        data["meetingEndDate"] = this.meetingEndDate ? this.meetingEndDate.toString() : <any>undefined;
        data["meetingvenueId"] = this.meetingvenueId;
        data["meetingLocation"] = this.meetingLocation;
        data["city"] = this.city;
        data["countryId"] = this.countryId;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        data["meetingAgenda"] = this.meetingAgenda;
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.employeeLists)) {
            data["employeeLists"] = [];
            for (let item of this.employeeLists)
                data["employeeLists"].push(item.toJSON());
        }
        data["minutesofMeeting"] = this.minutesofMeeting;
        data["minutesofMeetingAttachedment"] = this.minutesofMeetingAttachedment;
        data["meetingConclusion"] = this.meetingConclusion;
        data["organizerId"] = this.organizerId;
        if (Array.isArray(this.employeeOrganizerLists)) {
            data["employeeOrganizerLists"] = [];
            for (let item of this.employeeOrganizerLists)
                data["employeeOrganizerLists"].push(item.toJSON());
        }
        data["meetingTypeId"] = this.meetingTypeId;
        if (Array.isArray(this.meetingTypes)) {
            data["meetingTypes"] = [];
            for (let item of this.meetingTypes)
                data["meetingTypes"].push(item.toJSON());
        }
        data["meetingClassificationId"] = this.meetingClassificationId;
        if (Array.isArray(this.meetingClassifications)) {
            data["meetingClassifications"] = [];
            for (let item of this.meetingClassifications)
                data["meetingClassifications"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedMeetingAbsenteeUsers)) {
            data["selectedMeetingAbsenteeUsers"] = [];
            for (let item of this.selectedMeetingAbsenteeUsers)
                data["selectedMeetingAbsenteeUsers"].push(item.toJSON());
        }
        if (Array.isArray(this.removeMeetingAbsenteeUsers)) {
            data["removeMeetingAbsenteeUsers"] = [];
            for (let item of this.removeMeetingAbsenteeUsers)
                data["removeMeetingAbsenteeUsers"].push(item);
        }
        if (Array.isArray(this.selectedMeetingAttendUsers)) {
            data["selectedMeetingAttendUsers"] = [];
            for (let item of this.selectedMeetingAttendUsers)
                data["selectedMeetingAttendUsers"].push(item.toJSON());
        }
        if (Array.isArray(this.removeMeetingAttendUsers)) {
            data["removeMeetingAttendUsers"] = [];
            for (let item of this.removeMeetingAttendUsers)
                data["removeMeetingAttendUsers"].push(item);
        }
        if (Array.isArray(this.meetingLocationList)) {
            data["meetingLocationList"] = [];
            for (let item of this.meetingLocationList)
                data["meetingLocationList"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMeetingInfoDto {
    tenantId: number | undefined;
    meetingId: string | undefined;
    meetingTitle: string | undefined;
    meetingDescription: string | undefined;
    meetingStartDate: DateTime | undefined;
    meetingEndDate: DateTime | undefined;
    meetingvenueId: number | undefined;
    meetingLocation: string | undefined;
    city: string | undefined;
    countryId: number | undefined;
    countries: CountryDto[] | undefined;
    meetingAgenda: string | undefined;
    employeeId: number | undefined;
    employeeLists: ProgramUser[] | undefined;
    minutesofMeeting: string | undefined;
    minutesofMeetingAttachedment: string | undefined;
    meetingConclusion: string | undefined;
    organizerId: number | undefined;
    employeeOrganizerLists: ProgramUser[] | undefined;
    meetingTypeId: number | undefined;
    meetingTypes: GetDynamicValueDto[] | undefined;
    meetingClassificationId: number | undefined;
    meetingClassifications: GetDynamicValueDto[] | undefined;
    selectedMeetingAbsenteeUsers: MeetingAbsenteeUserDto[] | undefined;
    removeMeetingAbsenteeUsers: number[] | undefined;
    selectedMeetingAttendUsers: MeetingAttendUserDto[] | undefined;
    removeMeetingAttendUsers: number[] | undefined;
    meetingLocationList: FacilitieDatacenterListDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export enum UserNotificationState {
    Unread = 0,
    Read = 1,
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string]: any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        this.properties![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string]: any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0,
    Success = 1,
    Warn = 2,
    Error = 3,
    Fatal = 4,
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity;
    creationTime!: DateTime;
    id!: string;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.notificationName = _data["notificationName"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            this.entityType = _data["entityType"];
            this.entityTypeName = _data["entityTypeName"];
            this.entityId = _data["entityId"];
            this.severity = _data["severity"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity;
    creationTime: DateTime;
    id: string;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number;
    state!: UserNotificationState;
    notification!: TenantNotification;
    id!: string;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.state = _data["state"];
            this.notification = _data["notification"] ? TenantNotification.fromJS(_data["notification"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    id: string;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number;
    totalCount!: number;
    items!: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unreadCount = _data["unreadCount"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number;
    totalCount: number;
    items: UserNotification[] | undefined;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfGuid {
    id: string;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class OrganizationCountDto implements IOrganizationCountDto {
    organizationCount!: number | undefined;
    businessUnitCount!: number | undefined;
    businessServieCount!: number | undefined;
    businessProcessCount!: number | undefined;
    iTserviceCount!: number | undefined;
    strategicObjectiveCount!: number | undefined;
    kriCount!: number | undefined;
    kpiCount!: number | undefined;

    constructor(data?: IOrganizationCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationCount = _data["organizationCount"];
            this.businessUnitCount = _data["businessUnitCount"];
            this.businessServieCount = _data["businessServieCount"];
            this.businessProcessCount = _data["businessProcessCount"];
            this.iTserviceCount = _data["iTserviceCount"];
            this.strategicObjectiveCount = _data["strategicObjectiveCount"];
            this.kriCount = _data["kriCount"];
            this.kpiCount = _data["kpiCount"];
        }
    }

    static fromJS(data: any): OrganizationCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationCount"] = this.organizationCount;
        data["businessUnitCount"] = this.businessUnitCount;
        data["businessServieCount"] = this.businessServieCount;
        data["businessProcessCount"] = this.businessProcessCount;
        data["iTserviceCount"] = this.iTserviceCount;
        data["strategicObjectiveCount"] = this.strategicObjectiveCount;
        data["kriCount"] = this.kriCount;
        data["kpiCount"] = this.kpiCount;
        return data; 
    }
}

export interface IOrganizationCountDto {
    organizationCount: number | undefined;
    businessUnitCount: number | undefined;
    businessServieCount: number | undefined;
    businessProcessCount: number | undefined;
    iTserviceCount: number | undefined;
    strategicObjectiveCount: number | undefined;
    kriCount: number | undefined;
    kpiCount: number | undefined;
}

export class OrganizationSetupListDto implements IOrganizationSetupListDto {
    companyName!: string | undefined;
    companyId!: string | undefined;
    industrySectorId!: number | undefined;
    industrySector!: DynamicPropertyValue;
    email!: string | undefined;
    phone!: string | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IOrganizationSetupListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyName = _data["companyName"];
            this.companyId = _data["companyId"];
            this.industrySectorId = _data["industrySectorId"];
            this.industrySector = _data["industrySector"] ? DynamicPropertyValue.fromJS(_data["industrySector"]) : <any>undefined;
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationSetupListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationSetupListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["companyId"] = this.companyId;
        data["industrySectorId"] = this.industrySectorId;
        data["industrySector"] = this.industrySector ? this.industrySector.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationSetupListDto {
    companyName: string | undefined;
    companyId: string | undefined;
    industrySectorId: number | undefined;
    industrySector: DynamicPropertyValue;
    email: string | undefined;
    phone: string | undefined;
    isActive: boolean;
    creationTime: DateTime;
    id: number;
}

export class PagedResultDtoOfOrganizationSetupListDto implements IPagedResultDtoOfOrganizationSetupListDto {
    totalCount!: number;
    items!: OrganizationSetupListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationSetupListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationSetupListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationSetupListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationSetupListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationSetupListDto {
    totalCount: number;
    items: OrganizationSetupListDto[] | undefined;
}

export class CreateOrUpdateOrganizationSetupInput implements ICreateOrUpdateOrganizationSetupInput {
    id!: number | undefined;
    tenantId!: number | undefined;
    companyId!: string | undefined;
    companyName!: string | undefined;
    leveltype!: LevelType;
    organizationUnitId!: number | undefined;
    parentOrganizationId!: number | undefined;
    industrySectorId!: number | undefined;
    isAuditableEntity!: boolean;
    description!: string | undefined;
    countryId!: number | undefined;
    employeeSize!: number | undefined;
    companyWebsite!: string | undefined;
    companyLogo!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    addressCountryId!: number | undefined;
    contactFirstName!: string | undefined;
    contactLastName!: string | undefined;
    jobTitle!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    primaryContactId!: number | undefined;
    companyAdministratorId!: number | undefined;
    isActive!: boolean;

    constructor(data?: ICreateOrUpdateOrganizationSetupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.leveltype = _data["leveltype"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.parentOrganizationId = _data["parentOrganizationId"];
            this.industrySectorId = _data["industrySectorId"];
            this.isAuditableEntity = _data["isAuditableEntity"];
            this.description = _data["description"];
            this.countryId = _data["countryId"];
            this.employeeSize = _data["employeeSize"];
            this.companyWebsite = _data["companyWebsite"];
            this.companyLogo = _data["companyLogo"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.addressCountryId = _data["addressCountryId"];
            this.contactFirstName = _data["contactFirstName"];
            this.contactLastName = _data["contactLastName"];
            this.jobTitle = _data["jobTitle"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            this.primaryContactId = _data["primaryContactId"];
            this.companyAdministratorId = _data["companyAdministratorId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrUpdateOrganizationSetupInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateOrganizationSetupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["leveltype"] = this.leveltype;
        data["organizationUnitId"] = this.organizationUnitId;
        data["parentOrganizationId"] = this.parentOrganizationId;
        data["industrySectorId"] = this.industrySectorId;
        data["isAuditableEntity"] = this.isAuditableEntity;
        data["description"] = this.description;
        data["countryId"] = this.countryId;
        data["employeeSize"] = this.employeeSize;
        data["companyWebsite"] = this.companyWebsite;
        data["companyLogo"] = this.companyLogo;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["addressCountryId"] = this.addressCountryId;
        data["contactFirstName"] = this.contactFirstName;
        data["contactLastName"] = this.contactLastName;
        data["jobTitle"] = this.jobTitle;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["primaryContactId"] = this.primaryContactId;
        data["companyAdministratorId"] = this.companyAdministratorId;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ICreateOrUpdateOrganizationSetupInput {
    id: number | undefined;
    tenantId: number | undefined;
    companyId: string | undefined;
    companyName: string | undefined;
    leveltype: LevelType;
    organizationUnitId: number | undefined;
    parentOrganizationId: number | undefined;
    industrySectorId: number | undefined;
    isAuditableEntity: boolean;
    description: string | undefined;
    countryId: number | undefined;
    employeeSize: number | undefined;
    companyWebsite: string | undefined;
    companyLogo: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    addressCountryId: number | undefined;
    contactFirstName: string | undefined;
    contactLastName: string | undefined;
    jobTitle: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    primaryContactId: number | undefined;
    companyAdministratorId: number | undefined;
    isActive: boolean;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;
    roleCount!: number;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
            this.roleCount = _data["roleCount"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: DateTime;
    id!: number;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.addedTime = _data["addedTime"] ? DateTime.fromISO(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: DateTime;
    id: number;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: DateTime;
    id!: number;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.name = _data["name"];
            this.addedTime = _data["addedTime"] ? DateTime.fromISO(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: DateTime;
    id: number;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number;
    items!: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newParentId = _data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean;
    additionalData!: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.expiringEditionId = _data["expiringEditionId"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.isFree = _data["isFree"];
            this.additionalData = _data["additionalData"] ? AdditionalData.fromJS(_data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEditionSelectDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean;
    additionalData: AdditionalData | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto;
    additionalPrice!: number;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionSelectDto.fromJS(_data["edition"]) : <any>undefined;
            this.additionalPrice = _data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto;
    additionalPrice: number;
}

export enum EditionPaymentType {
    NewRegistration = 0,
    BuyNow = 1,
    Upgrade = 2,
    Extend = 3,
}

export enum PaymentPeriodType {
    Daily = 1,
    Weekly = 7,
    Monthly = 30,
    Annual = 365,
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1,
    Stripe = 2,
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number;
    editionPaymentType!: EditionPaymentType;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled!: boolean;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.editionId = _data["editionId"];
            this.editionPaymentType = _data["editionPaymentType"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = _data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = _data["recurringPaymentEnabled"];
            this.successUrl = _data["successUrl"];
            this.errorUrl = _data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data; 
    }
}

export interface ICreatePaymentDto {
    editionId: number;
    editionPaymentType: EditionPaymentType;
    paymentPeriodType: PaymentPeriodType;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled: boolean;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.gateway = _data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data; 
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number;
    editionId!: number;
    dayCount!: number;
    paymentPeriodType!: string | undefined;
    externalPaymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number;
    invoiceNo!: string | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gateway = _data["gateway"];
            this.amount = _data["amount"];
            this.editionId = _data["editionId"];
            this.dayCount = _data["dayCount"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.externalPaymentId = _data["externalPaymentId"];
            this.payerId = _data["payerId"];
            this.status = _data["status"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.tenantId = _data["tenantId"];
            this.invoiceNo = _data["invoiceNo"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["externalPaymentId"] = this.externalPaymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number;
    editionId: number;
    dayCount: number;
    paymentPeriodType: string | undefined;
    externalPaymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number;
    invoiceNo: string | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number;
    items!: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType!: SubscriptionPaymentGatewayType;
    supportsRecurringPayments!: boolean;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayType = _data["gatewayType"];
            this.supportsRecurringPayments = _data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data; 
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType;
    supportsRecurringPayments: boolean;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1,
    Paid = 2,
    Failed = 3,
    Cancelled = 4,
    Completed = 5,
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;
    amount!: number;
    editionId!: number;
    tenantId!: number;
    dayCount!: number;
    paymentPeriodType!: PaymentPeriodType;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: number;
    status!: SubscriptionPaymentStatus;
    isRecurring!: boolean;
    externalPaymentId!: string | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;
    editionPaymentType!: EditionPaymentType;
    id!: number;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.gateway = _data["gateway"];
            this.amount = _data["amount"];
            this.editionId = _data["editionId"];
            this.tenantId = _data["tenantId"];
            this.dayCount = _data["dayCount"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.paymentId = _data["paymentId"];
            this.payerId = _data["payerId"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.invoiceNo = _data["invoiceNo"];
            this.status = _data["status"];
            this.isRecurring = _data["isRecurring"];
            this.externalPaymentId = _data["externalPaymentId"];
            this.successUrl = _data["successUrl"];
            this.errorUrl = _data["errorUrl"];
            this.editionPaymentType = _data["editionPaymentType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["editionPaymentType"] = this.editionPaymentType;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
    amount: number;
    editionId: number;
    tenantId: number;
    dayCount: number;
    paymentPeriodType: PaymentPeriodType;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number;
    status: SubscriptionPaymentStatus;
    isRecurring: boolean;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    editionPaymentType: EditionPaymentType;
    id: number;
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId!: string | undefined;
    demoUsername!: string | undefined;
    demoPassword!: string | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.demoUsername = _data["demoUsername"];
            this.demoPassword = _data["demoPassword"];
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        return data; 
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.timezone = _data["timezone"];
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class SendVerificationSmsInputDto implements ISendVerificationSmsInputDto {
    phoneNumber!: string | undefined;

    constructor(data?: ISendVerificationSmsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendVerificationSmsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationSmsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ISendVerificationSmsInputDto {
    phoneNumber: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken!: string | undefined;
    x!: number;
    y!: number;
    width!: number;
    height!: number;
    useGravatarProfilePicture!: boolean;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileToken = _data["fileToken"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.useGravatarProfilePicture = _data["useGravatarProfilePicture"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        data["useGravatarProfilePicture"] = this.useGravatarProfilePicture;
        return data; 
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string | undefined;
    x: number;
    y: number;
    width: number;
    height: number;
    useGravatarProfilePicture: boolean;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting = _data["setting"] ? PasswordComplexitySetting.fromJS(_data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ProgramTeamDto implements IProgramTeamDto {
    id!: number;
    grcProgramId!: number | undefined;
    programTeamsId!: number | undefined;

    constructor(data?: IProgramTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.grcProgramId = _data["grcProgramId"];
            this.programTeamsId = _data["programTeamsId"];
        }
    }

    static fromJS(data: any): ProgramTeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramTeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["grcProgramId"] = this.grcProgramId;
        data["programTeamsId"] = this.programTeamsId;
        return data; 
    }
}

export interface IProgramTeamDto {
    id: number;
    grcProgramId: number | undefined;
    programTeamsId: number | undefined;
}

export class ProgramCoordinatorDto implements IProgramCoordinatorDto {
    id!: number;
    grcProgramId!: number | undefined;
    programCoordinatorsId!: number | undefined;

    constructor(data?: IProgramCoordinatorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.grcProgramId = _data["grcProgramId"];
            this.programCoordinatorsId = _data["programCoordinatorsId"];
        }
    }

    static fromJS(data: any): ProgramCoordinatorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramCoordinatorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["grcProgramId"] = this.grcProgramId;
        data["programCoordinatorsId"] = this.programCoordinatorsId;
        return data; 
    }
}

export interface IProgramCoordinatorDto {
    id: number;
    grcProgramId: number | undefined;
    programCoordinatorsId: number | undefined;
}

export class ProgramCountriesDto implements IProgramCountriesDto {
    id!: number;
    projectId!: number;
    countryId!: number;

    constructor(data?: IProgramCountriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectId = _data["projectId"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): ProgramCountriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramCountriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export interface IProgramCountriesDto {
    id: number;
    projectId: number;
    countryId: number;
}

export class ProgramDto implements IProgramDto {
    tenantId!: number | undefined;
    programId!: string | undefined;
    programTitle!: string | undefined;
    programTeamEmail!: string | undefined;
    startDate!: DateTime | undefined;
    description!: string | undefined;
    programLogo!: string | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    countryId!: number | undefined;
    countries!: CountryDto[] | undefined;
    programSponsorId!: number | undefined;
    programSponsors!: ProgramUser[] | undefined;
    programDirectorId!: number | undefined;
    programDirectors!: ProgramUser[] | undefined;
    selectedProgramTeams!: ProgramTeamDto[] | undefined;
    removedProgramTeams!: number[] | undefined;
    selectedProgramCoordinators!: ProgramCoordinatorDto[] | undefined;
    removedProgramCoordinators!: number[] | undefined;
    programTeams!: ProgramUser[] | undefined;
    programCoordinators!: ProgramUser[] | undefined;
    selectedProgramAuthoritativeDocuments!: ProgramAuthoritativeDocumentsDto[] | undefined;
    removedProgramAuthDocs!: number[] | undefined;
    authoratativeDocuments!: AuthoratativeDocumentsDto[] | undefined;
    selectedCountries!: ProgramCountriesDto[] | undefined;
    removedCountries!: number[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProgramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.programId = _data["programId"];
            this.programTitle = _data["programTitle"];
            this.programTeamEmail = _data["programTeamEmail"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.programLogo = _data["programLogo"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            this.countryId = _data["countryId"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(CountryDto.fromJS(item));
            }
            this.programSponsorId = _data["programSponsorId"];
            if (Array.isArray(_data["programSponsors"])) {
                this.programSponsors = [] as any;
                for (let item of _data["programSponsors"])
                    this.programSponsors!.push(ProgramUser.fromJS(item));
            }
            this.programDirectorId = _data["programDirectorId"];
            if (Array.isArray(_data["programDirectors"])) {
                this.programDirectors = [] as any;
                for (let item of _data["programDirectors"])
                    this.programDirectors!.push(ProgramUser.fromJS(item));
            }
            if (Array.isArray(_data["selectedProgramTeams"])) {
                this.selectedProgramTeams = [] as any;
                for (let item of _data["selectedProgramTeams"])
                    this.selectedProgramTeams!.push(ProgramTeamDto.fromJS(item));
            }
            if (Array.isArray(_data["removedProgramTeams"])) {
                this.removedProgramTeams = [] as any;
                for (let item of _data["removedProgramTeams"])
                    this.removedProgramTeams!.push(item);
            }
            if (Array.isArray(_data["selectedProgramCoordinators"])) {
                this.selectedProgramCoordinators = [] as any;
                for (let item of _data["selectedProgramCoordinators"])
                    this.selectedProgramCoordinators!.push(ProgramCoordinatorDto.fromJS(item));
            }
            if (Array.isArray(_data["removedProgramCoordinators"])) {
                this.removedProgramCoordinators = [] as any;
                for (let item of _data["removedProgramCoordinators"])
                    this.removedProgramCoordinators!.push(item);
            }
            if (Array.isArray(_data["programTeams"])) {
                this.programTeams = [] as any;
                for (let item of _data["programTeams"])
                    this.programTeams!.push(ProgramUser.fromJS(item));
            }
            if (Array.isArray(_data["programCoordinators"])) {
                this.programCoordinators = [] as any;
                for (let item of _data["programCoordinators"])
                    this.programCoordinators!.push(ProgramUser.fromJS(item));
            }
            if (Array.isArray(_data["selectedProgramAuthoritativeDocuments"])) {
                this.selectedProgramAuthoritativeDocuments = [] as any;
                for (let item of _data["selectedProgramAuthoritativeDocuments"])
                    this.selectedProgramAuthoritativeDocuments!.push(ProgramAuthoritativeDocumentsDto.fromJS(item));
            }
            if (Array.isArray(_data["removedProgramAuthDocs"])) {
                this.removedProgramAuthDocs = [] as any;
                for (let item of _data["removedProgramAuthDocs"])
                    this.removedProgramAuthDocs!.push(item);
            }
            if (Array.isArray(_data["authoratativeDocuments"])) {
                this.authoratativeDocuments = [] as any;
                for (let item of _data["authoratativeDocuments"])
                    this.authoratativeDocuments!.push(AuthoratativeDocumentsDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedCountries"])) {
                this.selectedCountries = [] as any;
                for (let item of _data["selectedCountries"])
                    this.selectedCountries!.push(ProgramCountriesDto.fromJS(item));
            }
            if (Array.isArray(_data["removedCountries"])) {
                this.removedCountries = [] as any;
                for (let item of _data["removedCountries"])
                    this.removedCountries!.push(item);
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProgramDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["programId"] = this.programId;
        data["programTitle"] = this.programTitle;
        data["programTeamEmail"] = this.programTeamEmail;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["description"] = this.description;
        data["programLogo"] = this.programLogo;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        data["countryId"] = this.countryId;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        data["programSponsorId"] = this.programSponsorId;
        if (Array.isArray(this.programSponsors)) {
            data["programSponsors"] = [];
            for (let item of this.programSponsors)
                data["programSponsors"].push(item.toJSON());
        }
        data["programDirectorId"] = this.programDirectorId;
        if (Array.isArray(this.programDirectors)) {
            data["programDirectors"] = [];
            for (let item of this.programDirectors)
                data["programDirectors"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedProgramTeams)) {
            data["selectedProgramTeams"] = [];
            for (let item of this.selectedProgramTeams)
                data["selectedProgramTeams"].push(item.toJSON());
        }
        if (Array.isArray(this.removedProgramTeams)) {
            data["removedProgramTeams"] = [];
            for (let item of this.removedProgramTeams)
                data["removedProgramTeams"].push(item);
        }
        if (Array.isArray(this.selectedProgramCoordinators)) {
            data["selectedProgramCoordinators"] = [];
            for (let item of this.selectedProgramCoordinators)
                data["selectedProgramCoordinators"].push(item.toJSON());
        }
        if (Array.isArray(this.removedProgramCoordinators)) {
            data["removedProgramCoordinators"] = [];
            for (let item of this.removedProgramCoordinators)
                data["removedProgramCoordinators"].push(item);
        }
        if (Array.isArray(this.programTeams)) {
            data["programTeams"] = [];
            for (let item of this.programTeams)
                data["programTeams"].push(item.toJSON());
        }
        if (Array.isArray(this.programCoordinators)) {
            data["programCoordinators"] = [];
            for (let item of this.programCoordinators)
                data["programCoordinators"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedProgramAuthoritativeDocuments)) {
            data["selectedProgramAuthoritativeDocuments"] = [];
            for (let item of this.selectedProgramAuthoritativeDocuments)
                data["selectedProgramAuthoritativeDocuments"].push(item.toJSON());
        }
        if (Array.isArray(this.removedProgramAuthDocs)) {
            data["removedProgramAuthDocs"] = [];
            for (let item of this.removedProgramAuthDocs)
                data["removedProgramAuthDocs"].push(item);
        }
        if (Array.isArray(this.authoratativeDocuments)) {
            data["authoratativeDocuments"] = [];
            for (let item of this.authoratativeDocuments)
                data["authoratativeDocuments"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedCountries)) {
            data["selectedCountries"] = [];
            for (let item of this.selectedCountries)
                data["selectedCountries"].push(item.toJSON());
        }
        if (Array.isArray(this.removedCountries)) {
            data["removedCountries"] = [];
            for (let item of this.removedCountries)
                data["removedCountries"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProgramDto {
    tenantId: number | undefined;
    programId: string | undefined;
    programTitle: string | undefined;
    programTeamEmail: string | undefined;
    startDate: DateTime | undefined;
    description: string | undefined;
    programLogo: string | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    countryId: number | undefined;
    countries: CountryDto[] | undefined;
    programSponsorId: number | undefined;
    programSponsors: ProgramUser[] | undefined;
    programDirectorId: number | undefined;
    programDirectors: ProgramUser[] | undefined;
    selectedProgramTeams: ProgramTeamDto[] | undefined;
    removedProgramTeams: number[] | undefined;
    selectedProgramCoordinators: ProgramCoordinatorDto[] | undefined;
    removedProgramCoordinators: number[] | undefined;
    programTeams: ProgramUser[] | undefined;
    programCoordinators: ProgramUser[] | undefined;
    selectedProgramAuthoritativeDocuments: ProgramAuthoritativeDocumentsDto[] | undefined;
    removedProgramAuthDocs: number[] | undefined;
    authoratativeDocuments: AuthoratativeDocumentsDto[] | undefined;
    selectedCountries: ProgramCountriesDto[] | undefined;
    removedCountries: number[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ProgramListDto implements IProgramListDto {
    id!: number;
    sponserName!: string | undefined;
    sponserPosition!: string | undefined;
    sponserCompany!: string | undefined;
    directorName!: string | undefined;
    directorPosition!: string | undefined;
    directorCompany!: string | undefined;
    programId!: string | undefined;
    programTitle!: string | undefined;
    companyName!: string | undefined;

    constructor(data?: IProgramListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sponserName = _data["sponserName"];
            this.sponserPosition = _data["sponserPosition"];
            this.sponserCompany = _data["sponserCompany"];
            this.directorName = _data["directorName"];
            this.directorPosition = _data["directorPosition"];
            this.directorCompany = _data["directorCompany"];
            this.programId = _data["programId"];
            this.programTitle = _data["programTitle"];
            this.companyName = _data["companyName"];
        }
    }

    static fromJS(data: any): ProgramListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sponserName"] = this.sponserName;
        data["sponserPosition"] = this.sponserPosition;
        data["sponserCompany"] = this.sponserCompany;
        data["directorName"] = this.directorName;
        data["directorPosition"] = this.directorPosition;
        data["directorCompany"] = this.directorCompany;
        data["programId"] = this.programId;
        data["programTitle"] = this.programTitle;
        data["companyName"] = this.companyName;
        return data; 
    }
}

export interface IProgramListDto {
    id: number;
    sponserName: string | undefined;
    sponserPosition: string | undefined;
    sponserCompany: string | undefined;
    directorName: string | undefined;
    directorPosition: string | undefined;
    directorCompany: string | undefined;
    programId: string | undefined;
    programTitle: string | undefined;
    companyName: string | undefined;
}

export class PagedResultDtoOfProgramListDto implements IPagedResultDtoOfProgramListDto {
    totalCount!: number;
    items!: ProgramListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProgramListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProgramListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProgramListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProgramListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProgramListDto {
    totalCount: number;
    items: ProgramListDto[] | undefined;
}

export class EmployeeDto implements IEmployeeDto {
    id!: number;
    name!: string | undefined;
    employeeId!: string | undefined;
    employeePosition!: string | undefined;
    lockThreatOrganizationId!: number;
    lockThreatOrganization!: string | undefined;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.employeeId = _data["employeeId"];
            this.employeePosition = _data["employeePosition"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["employeeId"] = this.employeeId;
        data["employeePosition"] = this.employeePosition;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization;
        return data; 
    }
}

export interface IEmployeeDto {
    id: number;
    name: string | undefined;
    employeeId: string | undefined;
    employeePosition: string | undefined;
    lockThreatOrganizationId: number;
    lockThreatOrganization: string | undefined;
}

export class ProjectUser implements IProjectUser {
    id!: number;
    employeeName!: string | undefined;
    organizationId!: number;

    constructor(data?: IProjectUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeName = _data["employeeName"];
            this.organizationId = _data["organizationId"];
        }
    }

    static fromJS(data: any): ProjectUser {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeName"] = this.employeeName;
        data["organizationId"] = this.organizationId;
        return data; 
    }
}

export interface IProjectUser {
    id: number;
    employeeName: string | undefined;
    organizationId: number;
}

export class ProjectCountriesDto implements IProjectCountriesDto {
    id!: number;
    projectId!: number;
    countryId!: number;

    constructor(data?: IProjectCountriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectId = _data["projectId"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): ProjectCountriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectCountriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export interface IProjectCountriesDto {
    id: number;
    projectId: number;
    countryId: number;
}

export class ProjectTeamMemberInternalDto implements IProjectTeamMemberInternalDto {
    id!: number;
    projectId!: number;
    teamMembersInternalId!: number;

    constructor(data?: IProjectTeamMemberInternalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectId = _data["projectId"];
            this.teamMembersInternalId = _data["teamMembersInternalId"];
        }
    }

    static fromJS(data: any): ProjectTeamMemberInternalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTeamMemberInternalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["teamMembersInternalId"] = this.teamMembersInternalId;
        return data; 
    }
}

export interface IProjectTeamMemberInternalDto {
    id: number;
    projectId: number;
    teamMembersInternalId: number;
}

export class ProjectTeamMemberExternalDto implements IProjectTeamMemberExternalDto {
    id!: number;
    projectId!: number;
    teamMembersExternalId!: number;

    constructor(data?: IProjectTeamMemberExternalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectId = _data["projectId"];
            this.teamMembersExternalId = _data["teamMembersExternalId"];
        }
    }

    static fromJS(data: any): ProjectTeamMemberExternalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTeamMemberExternalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["teamMembersExternalId"] = this.teamMembersExternalId;
        return data; 
    }
}

export interface IProjectTeamMemberExternalDto {
    id: number;
    projectId: number;
    teamMembersExternalId: number;
}

export class ProjectTeamMemberDto implements IProjectTeamMemberDto {
    id!: number;
    projectId!: number;
    teamMembersId!: number;

    constructor(data?: IProjectTeamMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectId = _data["projectId"];
            this.teamMembersId = _data["teamMembersId"];
        }
    }

    static fromJS(data: any): ProjectTeamMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTeamMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["teamMembersId"] = this.teamMembersId;
        return data; 
    }
}

export interface IProjectTeamMemberDto {
    id: number;
    projectId: number;
    teamMembersId: number;
}

export class ProjectAuthoratativeDocumentDto implements IProjectAuthoratativeDocumentDto {
    id!: number;
    projectId!: number;
    authoratativeDocumentId!: number;

    constructor(data?: IProjectAuthoratativeDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectId = _data["projectId"];
            this.authoratativeDocumentId = _data["authoratativeDocumentId"];
        }
    }

    static fromJS(data: any): ProjectAuthoratativeDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectAuthoratativeDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["authoratativeDocumentId"] = this.authoratativeDocumentId;
        return data; 
    }
}

export interface IProjectAuthoratativeDocumentDto {
    id: number;
    projectId: number;
    authoratativeDocumentId: number;
}

export class ProjectComponentsDto implements IProjectComponentsDto {
    id!: number;
    projectId!: number | undefined;
    projectComponentId!: number | undefined;

    constructor(data?: IProjectComponentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectId = _data["projectId"];
            this.projectComponentId = _data["projectComponentId"];
        }
    }

    static fromJS(data: any): ProjectComponentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectComponentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["projectComponentId"] = this.projectComponentId;
        return data; 
    }
}

export interface IProjectComponentsDto {
    id: number;
    projectId: number | undefined;
    projectComponentId: number | undefined;
}

export class ProjectDto implements IProjectDto {
    tenantId!: number | undefined;
    projectId!: string | undefined;
    projectName!: string | undefined;
    description!: string | undefined;
    address!: string | undefined;
    city!: string | undefined;
    postalCode!: string | undefined;
    industryId!: number | undefined;
    projectLogo!: string | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    countries!: CountryDto[] | undefined;
    parentProgramId!: number | undefined;
    parentProgramsList!: ProgramDto[] | undefined;
    projectScope!: string | undefined;
    projectSponsorId!: number | undefined;
    projectSponsor!: EmployeeDto;
    projectDirectorId!: number | undefined;
    projectDirector!: EmployeeDto;
    projectTeamMembersInternal!: ProjectUser[] | undefined;
    projectTeamMembersExternal!: ProjectUser[] | undefined;
    projectDirectors!: ProjectUser[] | undefined;
    projectSponsors!: ProjectUser[] | undefined;
    projectTeamMembers!: ProjectUser[] | undefined;
    authoratativeDocuments!: AuthoratativeDocumentsDto[] | undefined;
    selectedCountries!: ProjectCountriesDto[] | undefined;
    removedCountries!: number[] | undefined;
    selectedInternalTeams!: ProjectTeamMemberInternalDto[] | undefined;
    removedInternalTeams!: number[] | undefined;
    selectedExternalTeams!: ProjectTeamMemberExternalDto[] | undefined;
    removedExternalTeams!: number[] | undefined;
    selectedTeams!: ProjectTeamMemberDto[] | undefined;
    removedTeams!: number[] | undefined;
    selectedAuthProjDocuments!: ProjectAuthoratativeDocumentDto[] | undefined;
    removedAuthProjDocuments!: number[] | undefined;
    selectedProjectComponents!: ProjectComponentsDto[] | undefined;
    removedProjectComponents!: number[] | undefined;
    projectComponents!: DynamicNameValueDto[] | undefined;
    projectIndustries!: DynamicNameValueDto[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.projectId = _data["projectId"];
            this.projectName = _data["projectName"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.industryId = _data["industryId"];
            this.projectLogo = _data["projectLogo"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(CountryDto.fromJS(item));
            }
            this.parentProgramId = _data["parentProgramId"];
            if (Array.isArray(_data["parentProgramsList"])) {
                this.parentProgramsList = [] as any;
                for (let item of _data["parentProgramsList"])
                    this.parentProgramsList!.push(ProgramDto.fromJS(item));
            }
            this.projectScope = _data["projectScope"];
            this.projectSponsorId = _data["projectSponsorId"];
            this.projectSponsor = _data["projectSponsor"] ? EmployeeDto.fromJS(_data["projectSponsor"]) : <any>undefined;
            this.projectDirectorId = _data["projectDirectorId"];
            this.projectDirector = _data["projectDirector"] ? EmployeeDto.fromJS(_data["projectDirector"]) : <any>undefined;
            if (Array.isArray(_data["projectTeamMembersInternal"])) {
                this.projectTeamMembersInternal = [] as any;
                for (let item of _data["projectTeamMembersInternal"])
                    this.projectTeamMembersInternal!.push(ProjectUser.fromJS(item));
            }
            if (Array.isArray(_data["projectTeamMembersExternal"])) {
                this.projectTeamMembersExternal = [] as any;
                for (let item of _data["projectTeamMembersExternal"])
                    this.projectTeamMembersExternal!.push(ProjectUser.fromJS(item));
            }
            if (Array.isArray(_data["projectDirectors"])) {
                this.projectDirectors = [] as any;
                for (let item of _data["projectDirectors"])
                    this.projectDirectors!.push(ProjectUser.fromJS(item));
            }
            if (Array.isArray(_data["projectSponsors"])) {
                this.projectSponsors = [] as any;
                for (let item of _data["projectSponsors"])
                    this.projectSponsors!.push(ProjectUser.fromJS(item));
            }
            if (Array.isArray(_data["projectTeamMembers"])) {
                this.projectTeamMembers = [] as any;
                for (let item of _data["projectTeamMembers"])
                    this.projectTeamMembers!.push(ProjectUser.fromJS(item));
            }
            if (Array.isArray(_data["authoratativeDocuments"])) {
                this.authoratativeDocuments = [] as any;
                for (let item of _data["authoratativeDocuments"])
                    this.authoratativeDocuments!.push(AuthoratativeDocumentsDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedCountries"])) {
                this.selectedCountries = [] as any;
                for (let item of _data["selectedCountries"])
                    this.selectedCountries!.push(ProjectCountriesDto.fromJS(item));
            }
            if (Array.isArray(_data["removedCountries"])) {
                this.removedCountries = [] as any;
                for (let item of _data["removedCountries"])
                    this.removedCountries!.push(item);
            }
            if (Array.isArray(_data["selectedInternalTeams"])) {
                this.selectedInternalTeams = [] as any;
                for (let item of _data["selectedInternalTeams"])
                    this.selectedInternalTeams!.push(ProjectTeamMemberInternalDto.fromJS(item));
            }
            if (Array.isArray(_data["removedInternalTeams"])) {
                this.removedInternalTeams = [] as any;
                for (let item of _data["removedInternalTeams"])
                    this.removedInternalTeams!.push(item);
            }
            if (Array.isArray(_data["selectedExternalTeams"])) {
                this.selectedExternalTeams = [] as any;
                for (let item of _data["selectedExternalTeams"])
                    this.selectedExternalTeams!.push(ProjectTeamMemberExternalDto.fromJS(item));
            }
            if (Array.isArray(_data["removedExternalTeams"])) {
                this.removedExternalTeams = [] as any;
                for (let item of _data["removedExternalTeams"])
                    this.removedExternalTeams!.push(item);
            }
            if (Array.isArray(_data["selectedTeams"])) {
                this.selectedTeams = [] as any;
                for (let item of _data["selectedTeams"])
                    this.selectedTeams!.push(ProjectTeamMemberDto.fromJS(item));
            }
            if (Array.isArray(_data["removedTeams"])) {
                this.removedTeams = [] as any;
                for (let item of _data["removedTeams"])
                    this.removedTeams!.push(item);
            }
            if (Array.isArray(_data["selectedAuthProjDocuments"])) {
                this.selectedAuthProjDocuments = [] as any;
                for (let item of _data["selectedAuthProjDocuments"])
                    this.selectedAuthProjDocuments!.push(ProjectAuthoratativeDocumentDto.fromJS(item));
            }
            if (Array.isArray(_data["removedAuthProjDocuments"])) {
                this.removedAuthProjDocuments = [] as any;
                for (let item of _data["removedAuthProjDocuments"])
                    this.removedAuthProjDocuments!.push(item);
            }
            if (Array.isArray(_data["selectedProjectComponents"])) {
                this.selectedProjectComponents = [] as any;
                for (let item of _data["selectedProjectComponents"])
                    this.selectedProjectComponents!.push(ProjectComponentsDto.fromJS(item));
            }
            if (Array.isArray(_data["removedProjectComponents"])) {
                this.removedProjectComponents = [] as any;
                for (let item of _data["removedProjectComponents"])
                    this.removedProjectComponents!.push(item);
            }
            if (Array.isArray(_data["projectComponents"])) {
                this.projectComponents = [] as any;
                for (let item of _data["projectComponents"])
                    this.projectComponents!.push(DynamicNameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["projectIndustries"])) {
                this.projectIndustries = [] as any;
                for (let item of _data["projectIndustries"])
                    this.projectIndustries!.push(DynamicNameValueDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["projectId"] = this.projectId;
        data["projectName"] = this.projectName;
        data["description"] = this.description;
        data["address"] = this.address;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["industryId"] = this.industryId;
        data["projectLogo"] = this.projectLogo;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        data["parentProgramId"] = this.parentProgramId;
        if (Array.isArray(this.parentProgramsList)) {
            data["parentProgramsList"] = [];
            for (let item of this.parentProgramsList)
                data["parentProgramsList"].push(item.toJSON());
        }
        data["projectScope"] = this.projectScope;
        data["projectSponsorId"] = this.projectSponsorId;
        data["projectSponsor"] = this.projectSponsor ? this.projectSponsor.toJSON() : <any>undefined;
        data["projectDirectorId"] = this.projectDirectorId;
        data["projectDirector"] = this.projectDirector ? this.projectDirector.toJSON() : <any>undefined;
        if (Array.isArray(this.projectTeamMembersInternal)) {
            data["projectTeamMembersInternal"] = [];
            for (let item of this.projectTeamMembersInternal)
                data["projectTeamMembersInternal"].push(item.toJSON());
        }
        if (Array.isArray(this.projectTeamMembersExternal)) {
            data["projectTeamMembersExternal"] = [];
            for (let item of this.projectTeamMembersExternal)
                data["projectTeamMembersExternal"].push(item.toJSON());
        }
        if (Array.isArray(this.projectDirectors)) {
            data["projectDirectors"] = [];
            for (let item of this.projectDirectors)
                data["projectDirectors"].push(item.toJSON());
        }
        if (Array.isArray(this.projectSponsors)) {
            data["projectSponsors"] = [];
            for (let item of this.projectSponsors)
                data["projectSponsors"].push(item.toJSON());
        }
        if (Array.isArray(this.projectTeamMembers)) {
            data["projectTeamMembers"] = [];
            for (let item of this.projectTeamMembers)
                data["projectTeamMembers"].push(item.toJSON());
        }
        if (Array.isArray(this.authoratativeDocuments)) {
            data["authoratativeDocuments"] = [];
            for (let item of this.authoratativeDocuments)
                data["authoratativeDocuments"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedCountries)) {
            data["selectedCountries"] = [];
            for (let item of this.selectedCountries)
                data["selectedCountries"].push(item.toJSON());
        }
        if (Array.isArray(this.removedCountries)) {
            data["removedCountries"] = [];
            for (let item of this.removedCountries)
                data["removedCountries"].push(item);
        }
        if (Array.isArray(this.selectedInternalTeams)) {
            data["selectedInternalTeams"] = [];
            for (let item of this.selectedInternalTeams)
                data["selectedInternalTeams"].push(item.toJSON());
        }
        if (Array.isArray(this.removedInternalTeams)) {
            data["removedInternalTeams"] = [];
            for (let item of this.removedInternalTeams)
                data["removedInternalTeams"].push(item);
        }
        if (Array.isArray(this.selectedExternalTeams)) {
            data["selectedExternalTeams"] = [];
            for (let item of this.selectedExternalTeams)
                data["selectedExternalTeams"].push(item.toJSON());
        }
        if (Array.isArray(this.removedExternalTeams)) {
            data["removedExternalTeams"] = [];
            for (let item of this.removedExternalTeams)
                data["removedExternalTeams"].push(item);
        }
        if (Array.isArray(this.selectedTeams)) {
            data["selectedTeams"] = [];
            for (let item of this.selectedTeams)
                data["selectedTeams"].push(item.toJSON());
        }
        if (Array.isArray(this.removedTeams)) {
            data["removedTeams"] = [];
            for (let item of this.removedTeams)
                data["removedTeams"].push(item);
        }
        if (Array.isArray(this.selectedAuthProjDocuments)) {
            data["selectedAuthProjDocuments"] = [];
            for (let item of this.selectedAuthProjDocuments)
                data["selectedAuthProjDocuments"].push(item.toJSON());
        }
        if (Array.isArray(this.removedAuthProjDocuments)) {
            data["removedAuthProjDocuments"] = [];
            for (let item of this.removedAuthProjDocuments)
                data["removedAuthProjDocuments"].push(item);
        }
        if (Array.isArray(this.selectedProjectComponents)) {
            data["selectedProjectComponents"] = [];
            for (let item of this.selectedProjectComponents)
                data["selectedProjectComponents"].push(item.toJSON());
        }
        if (Array.isArray(this.removedProjectComponents)) {
            data["removedProjectComponents"] = [];
            for (let item of this.removedProjectComponents)
                data["removedProjectComponents"].push(item);
        }
        if (Array.isArray(this.projectComponents)) {
            data["projectComponents"] = [];
            for (let item of this.projectComponents)
                data["projectComponents"].push(item.toJSON());
        }
        if (Array.isArray(this.projectIndustries)) {
            data["projectIndustries"] = [];
            for (let item of this.projectIndustries)
                data["projectIndustries"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProjectDto {
    tenantId: number | undefined;
    projectId: string | undefined;
    projectName: string | undefined;
    description: string | undefined;
    address: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    industryId: number | undefined;
    projectLogo: string | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    countries: CountryDto[] | undefined;
    parentProgramId: number | undefined;
    parentProgramsList: ProgramDto[] | undefined;
    projectScope: string | undefined;
    projectSponsorId: number | undefined;
    projectSponsor: EmployeeDto;
    projectDirectorId: number | undefined;
    projectDirector: EmployeeDto;
    projectTeamMembersInternal: ProjectUser[] | undefined;
    projectTeamMembersExternal: ProjectUser[] | undefined;
    projectDirectors: ProjectUser[] | undefined;
    projectSponsors: ProjectUser[] | undefined;
    projectTeamMembers: ProjectUser[] | undefined;
    authoratativeDocuments: AuthoratativeDocumentsDto[] | undefined;
    selectedCountries: ProjectCountriesDto[] | undefined;
    removedCountries: number[] | undefined;
    selectedInternalTeams: ProjectTeamMemberInternalDto[] | undefined;
    removedInternalTeams: number[] | undefined;
    selectedExternalTeams: ProjectTeamMemberExternalDto[] | undefined;
    removedExternalTeams: number[] | undefined;
    selectedTeams: ProjectTeamMemberDto[] | undefined;
    removedTeams: number[] | undefined;
    selectedAuthProjDocuments: ProjectAuthoratativeDocumentDto[] | undefined;
    removedAuthProjDocuments: number[] | undefined;
    selectedProjectComponents: ProjectComponentsDto[] | undefined;
    removedProjectComponents: number[] | undefined;
    projectComponents: DynamicNameValueDto[] | undefined;
    projectIndustries: DynamicNameValueDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ProjectListDto implements IProjectListDto {
    id!: number;
    projectId!: string | undefined;
    projectName!: string | undefined;
    sponserName!: string | undefined;
    sponserPosition!: string | undefined;
    sponserCompany!: string | undefined;
    directorName!: string | undefined;
    directorPosition!: string | undefined;
    directorCompany!: string | undefined;
    lockThreatOrganization!: string | undefined;
    parentProgramName!: string | undefined;

    constructor(data?: IProjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectId = _data["projectId"];
            this.projectName = _data["projectName"];
            this.sponserName = _data["sponserName"];
            this.sponserPosition = _data["sponserPosition"];
            this.sponserCompany = _data["sponserCompany"];
            this.directorName = _data["directorName"];
            this.directorPosition = _data["directorPosition"];
            this.directorCompany = _data["directorCompany"];
            this.lockThreatOrganization = _data["lockThreatOrganization"];
            this.parentProgramName = _data["parentProgramName"];
        }
    }

    static fromJS(data: any): ProjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["projectName"] = this.projectName;
        data["sponserName"] = this.sponserName;
        data["sponserPosition"] = this.sponserPosition;
        data["sponserCompany"] = this.sponserCompany;
        data["directorName"] = this.directorName;
        data["directorPosition"] = this.directorPosition;
        data["directorCompany"] = this.directorCompany;
        data["lockThreatOrganization"] = this.lockThreatOrganization;
        data["parentProgramName"] = this.parentProgramName;
        return data; 
    }
}

export interface IProjectListDto {
    id: number;
    projectId: string | undefined;
    projectName: string | undefined;
    sponserName: string | undefined;
    sponserPosition: string | undefined;
    sponserCompany: string | undefined;
    directorName: string | undefined;
    directorPosition: string | undefined;
    directorCompany: string | undefined;
    lockThreatOrganization: string | undefined;
    parentProgramName: string | undefined;
}

export class PagedResultDtoOfProjectListDto implements IPagedResultDtoOfProjectListDto {
    totalCount!: number;
    items!: ProjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProjectListDto {
    totalCount: number;
    items: ProjectListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: DateTime;
    id: number;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : new RoleEditDto();
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    id!: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number;
}

export enum SubscriptionPaymentType {
    Manual = 0,
    RecurringAutomatic = 1,
    RecurringManual = 2,
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean;
    isFree!: boolean;
    id!: number;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.trialDayCount = _data["trialDayCount"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.isHighestEdition = _data["isHighestEdition"];
            this.isFree = _data["isFree"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;
    subscriptionPaymentType!: SubscriptionPaymentType;
    edition!: EditionInfoDto;
    creationTime!: DateTime;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    id!: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.logoId = _data["logoId"];
            this.logoFileType = _data["logoFileType"];
            this.customCssId = _data["customCssId"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.subscriptionPaymentType = _data["subscriptionPaymentType"];
            this.edition = _data["edition"] ? EditionInfoDto.fromJS(_data["edition"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.subscriptionDateString = _data["subscriptionDateString"];
            this.creationTimeString = _data["creationTimeString"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
    subscriptionPaymentType: SubscriptionPaymentType;
    edition: EditionInfoDto;
    creationTime: DateTime;
    paymentPeriodType: PaymentPeriodType;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: DateTime;
    currency!: string | undefined;
    currencySign!: string | undefined;
    allowTenantsToChangeEmailSettings!: boolean;
    userDelegationIsEnabled!: boolean;
    features!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? DateTime.fromISO(_data["releaseDate"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.currencySign = _data["currencySign"];
            this.allowTenantsToChangeEmailSettings = _data["allowTenantsToChangeEmailSettings"];
            this.userDelegationIsEnabled = _data["userDelegationIsEnabled"];
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        this.features![key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        data["userDelegationIsEnabled"] = this.userDelegationIsEnabled;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: DateTime;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean;
    userDelegationIsEnabled: boolean;
    features: { [key: string]: boolean; } | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layoutType = _data["layoutType"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        return data; 
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    desktopFixedHeader!: boolean;
    mobileFixedHeader!: boolean;
    headerSkin!: string | undefined;
    minimizeDesktopHeaderType!: string | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.desktopFixedHeader = _data["desktopFixedHeader"];
            this.mobileFixedHeader = _data["mobileFixedHeader"];
            this.headerSkin = _data["headerSkin"];
            this.minimizeDesktopHeaderType = _data["minimizeDesktopHeaderType"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        return data; 
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean;
    mobileFixedHeader: boolean;
    headerSkin: string | undefined;
    minimizeDesktopHeaderType: string | undefined;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader!: boolean;
    subheaderStyle!: string | undefined;
    subheaderSize!: number;
    titleStlye!: string | undefined;
    containerStyle!: string | undefined;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fixedSubHeader = _data["fixedSubHeader"];
            this.subheaderStyle = _data["subheaderStyle"];
            this.subheaderSize = _data["subheaderSize"];
            this.titleStlye = _data["titleStlye"];
            this.containerStyle = _data["containerStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        data["subheaderSize"] = this.subheaderSize;
        data["titleStlye"] = this.titleStlye;
        data["containerStyle"] = this.containerStyle;
        return data; 
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean;
    subheaderStyle: string | undefined;
    subheaderSize: number;
    titleStlye: string | undefined;
    containerStyle: string | undefined;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean;
    allowAsideMinimizing!: boolean;
    defaultMinimizedAside!: boolean;
    submenuToggle!: string | undefined;
    searchActive!: boolean;
    enableSecondary!: boolean;
    hoverableAside!: boolean;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
            this.asideSkin = _data["asideSkin"];
            this.fixedAside = _data["fixedAside"];
            this.allowAsideMinimizing = _data["allowAsideMinimizing"];
            this.defaultMinimizedAside = _data["defaultMinimizedAside"];
            this.submenuToggle = _data["submenuToggle"];
            this.searchActive = _data["searchActive"];
            this.enableSecondary = _data["enableSecondary"];
            this.hoverableAside = _data["hoverableAside"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        data["searchActive"] = this.searchActive;
        data["enableSecondary"] = this.enableSecondary;
        data["hoverableAside"] = this.hoverableAside;
        return data; 
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean;
    allowAsideMinimizing: boolean;
    defaultMinimizedAside: boolean;
    submenuToggle: string | undefined;
    searchActive: boolean;
    enableSecondary: boolean;
    hoverableAside: boolean;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fixedFooter = _data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto;
    header!: ThemeHeaderSettingsDto;
    subHeader!: ThemeSubHeaderSettingsDto;
    menu!: ThemeMenuSettingsDto;
    footer!: ThemeFooterSettingsDto;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
            this.layout = _data["layout"] ? ThemeLayoutSettingsDto.fromJS(_data["layout"]) : <any>undefined;
            this.header = _data["header"] ? ThemeHeaderSettingsDto.fromJS(_data["header"]) : <any>undefined;
            this.subHeader = _data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(_data["subHeader"]) : <any>undefined;
            this.menu = _data["menu"] ? ThemeMenuSettingsDto.fromJS(_data["menu"]) : <any>undefined;
            this.footer = _data["footer"] ? ThemeFooterSettingsDto.fromJS(_data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto;
    header: ThemeHeaderSettingsDto;
    subHeader: ThemeSubHeaderSettingsDto;
    menu: ThemeMenuSettingsDto;
    footer: ThemeFooterSettingsDto;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto;
    isLeftMenuUsed!: boolean;
    isTopMenuUsed!: boolean;
    isTabMenuUsed!: boolean;
    allowMenuScroll!: boolean;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseSettings = _data["baseSettings"] ? ThemeSettingsDto.fromJS(_data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = _data["isLeftMenuUsed"];
            this.isTopMenuUsed = _data["isTopMenuUsed"];
            this.isTabMenuUsed = _data["isTabMenuUsed"];
            this.allowMenuScroll = _data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data; 
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto;
    isLeftMenuUsed: boolean;
    isTopMenuUsed: boolean;
    isTabMenuUsed: boolean;
    allowMenuScroll: boolean;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto;
    impersonatorUser!: UserLoginInfoDto;
    tenant!: TenantLoginInfoDto;
    impersonatorTenant!: TenantLoginInfoDto;
    application!: ApplicationInfoDto;
    theme!: UiCustomizationSettingsDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.impersonatorUser = _data["impersonatorUser"] ? UserLoginInfoDto.fromJS(_data["impersonatorUser"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            this.impersonatorTenant = _data["impersonatorTenant"] ? TenantLoginInfoDto.fromJS(_data["impersonatorTenant"]) : <any>undefined;
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.theme = _data["theme"] ? UiCustomizationSettingsDto.fromJS(_data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["impersonatorUser"] = this.impersonatorUser ? this.impersonatorUser.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["impersonatorTenant"] = this.impersonatorTenant ? this.impersonatorTenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    impersonatorUser: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    impersonatorTenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
    theme: UiCustomizationSettingsDto;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signInToken = _data["signInToken"];
            this.encodedUserId = _data["encodedUserId"];
            this.encodedTenantId = _data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class OranizationGoalDto implements IOranizationGoalDto {
    id!: number;
    goal!: string | undefined;
    lockThreatOrganizationId!: number | undefined;

    constructor(data?: IOranizationGoalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.goal = _data["goal"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
        }
    }

    static fromJS(data: any): OranizationGoalDto {
        data = typeof data === 'object' ? data : {};
        let result = new OranizationGoalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["goal"] = this.goal;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        return data; 
    }
}

export interface IOranizationGoalDto {
    id: number;
    goal: string | undefined;
    lockThreatOrganizationId: number | undefined;
}

export class StrategicObjectiveDto implements IStrategicObjectiveDto {
    tenantId!: number | undefined;
    strategicObjectiveId!: string | undefined;
    executiveSponsorId!: number | undefined;
    executiveSponsors!: ProgramUser[] | undefined;
    strategicObjectiveTitle!: string | undefined;
    description!: string | undefined;
    effectiveDate!: DateTime | undefined;
    statusId!: number | undefined;
    statuses!: GetDynamicValueDto[] | undefined;
    typeId!: number | undefined;
    types!: GetDynamicValueDto[] | undefined;
    goal!: string | undefined;
    goals!: OranizationGoalDto[] | undefined;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganizations!: GetOrganizationDto[] | undefined;
    id!: number;

    constructor(data?: IStrategicObjectiveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.strategicObjectiveId = _data["strategicObjectiveId"];
            this.executiveSponsorId = _data["executiveSponsorId"];
            if (Array.isArray(_data["executiveSponsors"])) {
                this.executiveSponsors = [] as any;
                for (let item of _data["executiveSponsors"])
                    this.executiveSponsors!.push(ProgramUser.fromJS(item));
            }
            this.strategicObjectiveTitle = _data["strategicObjectiveTitle"];
            this.description = _data["description"];
            this.effectiveDate = _data["effectiveDate"] ? DateTime.fromISO(_data["effectiveDate"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(GetDynamicValueDto.fromJS(item));
            }
            this.typeId = _data["typeId"];
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types!.push(GetDynamicValueDto.fromJS(item));
            }
            this.goal = _data["goal"];
            if (Array.isArray(_data["goals"])) {
                this.goals = [] as any;
                for (let item of _data["goals"])
                    this.goals!.push(OranizationGoalDto.fromJS(item));
            }
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["lockThreatOrganizations"])) {
                this.lockThreatOrganizations = [] as any;
                for (let item of _data["lockThreatOrganizations"])
                    this.lockThreatOrganizations!.push(GetOrganizationDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StrategicObjectiveDto {
        data = typeof data === 'object' ? data : {};
        let result = new StrategicObjectiveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["strategicObjectiveId"] = this.strategicObjectiveId;
        data["executiveSponsorId"] = this.executiveSponsorId;
        if (Array.isArray(this.executiveSponsors)) {
            data["executiveSponsors"] = [];
            for (let item of this.executiveSponsors)
                data["executiveSponsors"].push(item.toJSON());
        }
        data["strategicObjectiveTitle"] = this.strategicObjectiveTitle;
        data["description"] = this.description;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toString() : <any>undefined;
        data["statusId"] = this.statusId;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        data["typeId"] = this.typeId;
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item.toJSON());
        }
        data["goal"] = this.goal;
        if (Array.isArray(this.goals)) {
            data["goals"] = [];
            for (let item of this.goals)
                data["goals"].push(item.toJSON());
        }
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.lockThreatOrganizations)) {
            data["lockThreatOrganizations"] = [];
            for (let item of this.lockThreatOrganizations)
                data["lockThreatOrganizations"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IStrategicObjectiveDto {
    tenantId: number | undefined;
    strategicObjectiveId: string | undefined;
    executiveSponsorId: number | undefined;
    executiveSponsors: ProgramUser[] | undefined;
    strategicObjectiveTitle: string | undefined;
    description: string | undefined;
    effectiveDate: DateTime | undefined;
    statusId: number | undefined;
    statuses: GetDynamicValueDto[] | undefined;
    typeId: number | undefined;
    types: GetDynamicValueDto[] | undefined;
    goal: string | undefined;
    goals: OranizationGoalDto[] | undefined;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganizations: GetOrganizationDto[] | undefined;
    id: number;
}

export class StrategicObjectiveListDto implements IStrategicObjectiveListDto {
    strategicObjectiveId!: string | undefined;
    executiveSponsorId!: number | undefined;
    executiveSponsor!: ProgramUser;
    strategicObjectiveTitle!: string | undefined;
    description!: string | undefined;
    effectiveDate!: DateTime | undefined;
    statusId!: number | undefined;
    status!: DynamicPropertyValue;
    typeId!: number | undefined;
    type!: DynamicPropertyValue;
    goal!: string | undefined;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationDto;
    id!: number;

    constructor(data?: IStrategicObjectiveListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.strategicObjectiveId = _data["strategicObjectiveId"];
            this.executiveSponsorId = _data["executiveSponsorId"];
            this.executiveSponsor = _data["executiveSponsor"] ? ProgramUser.fromJS(_data["executiveSponsor"]) : <any>undefined;
            this.strategicObjectiveTitle = _data["strategicObjectiveTitle"];
            this.description = _data["description"];
            this.effectiveDate = _data["effectiveDate"] ? DateTime.fromISO(_data["effectiveDate"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.status = _data["status"] ? DynamicPropertyValue.fromJS(_data["status"]) : <any>undefined;
            this.typeId = _data["typeId"];
            this.type = _data["type"] ? DynamicPropertyValue.fromJS(_data["type"]) : <any>undefined;
            this.goal = _data["goal"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StrategicObjectiveListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StrategicObjectiveListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["strategicObjectiveId"] = this.strategicObjectiveId;
        data["executiveSponsorId"] = this.executiveSponsorId;
        data["executiveSponsor"] = this.executiveSponsor ? this.executiveSponsor.toJSON() : <any>undefined;
        data["strategicObjectiveTitle"] = this.strategicObjectiveTitle;
        data["description"] = this.description;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["typeId"] = this.typeId;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["goal"] = this.goal;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStrategicObjectiveListDto {
    strategicObjectiveId: string | undefined;
    executiveSponsorId: number | undefined;
    executiveSponsor: ProgramUser;
    strategicObjectiveTitle: string | undefined;
    description: string | undefined;
    effectiveDate: DateTime | undefined;
    statusId: number | undefined;
    status: DynamicPropertyValue;
    typeId: number | undefined;
    type: DynamicPropertyValue;
    goal: string | undefined;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationDto;
    id: number;
}

export class PagedResultDtoOfStrategicObjectiveListDto implements IPagedResultDtoOfStrategicObjectiveListDto {
    totalCount!: number;
    items!: StrategicObjectiveListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStrategicObjectiveListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StrategicObjectiveListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStrategicObjectiveListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStrategicObjectiveListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfStrategicObjectiveListDto {
    totalCount: number;
    items: StrategicObjectiveListDto[] | undefined;
}

export class GetEditStrategicObjectiveDto implements IGetEditStrategicObjectiveDto {
    id!: number | undefined;
    strategicObjectiveId!: string | undefined;
    executiveSponsorId!: number | undefined;
    executiveSponsor!: ProgramUser;
    strategicObjectiveTitle!: string | undefined;
    description!: string | undefined;
    effectiveDate!: DateTime | undefined;
    statusId!: number | undefined;
    status!: DynamicPropertyValue;
    typeId!: number | undefined;
    type!: DynamicPropertyValue;
    goalId!: number | undefined;
    goal!: DynamicPropertyValue;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationDto;

    constructor(data?: IGetEditStrategicObjectiveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.strategicObjectiveId = _data["strategicObjectiveId"];
            this.executiveSponsorId = _data["executiveSponsorId"];
            this.executiveSponsor = _data["executiveSponsor"] ? ProgramUser.fromJS(_data["executiveSponsor"]) : <any>undefined;
            this.strategicObjectiveTitle = _data["strategicObjectiveTitle"];
            this.description = _data["description"];
            this.effectiveDate = _data["effectiveDate"] ? DateTime.fromISO(_data["effectiveDate"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.status = _data["status"] ? DynamicPropertyValue.fromJS(_data["status"]) : <any>undefined;
            this.typeId = _data["typeId"];
            this.type = _data["type"] ? DynamicPropertyValue.fromJS(_data["type"]) : <any>undefined;
            this.goalId = _data["goalId"];
            this.goal = _data["goal"] ? DynamicPropertyValue.fromJS(_data["goal"]) : <any>undefined;
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEditStrategicObjectiveDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditStrategicObjectiveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["strategicObjectiveId"] = this.strategicObjectiveId;
        data["executiveSponsorId"] = this.executiveSponsorId;
        data["executiveSponsor"] = this.executiveSponsor ? this.executiveSponsor.toJSON() : <any>undefined;
        data["strategicObjectiveTitle"] = this.strategicObjectiveTitle;
        data["description"] = this.description;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["typeId"] = this.typeId;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["goalId"] = this.goalId;
        data["goal"] = this.goal ? this.goal.toJSON() : <any>undefined;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetEditStrategicObjectiveDto {
    id: number | undefined;
    strategicObjectiveId: string | undefined;
    executiveSponsorId: number | undefined;
    executiveSponsor: ProgramUser;
    strategicObjectiveTitle: string | undefined;
    description: string | undefined;
    effectiveDate: DateTime | undefined;
    statusId: number | undefined;
    status: DynamicPropertyValue;
    typeId: number | undefined;
    type: DynamicPropertyValue;
    goalId: number | undefined;
    goal: DynamicPropertyValue;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationDto;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey!: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publishableKey = _data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data; 
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class StripeCreatePaymentSessionInput implements IStripeCreatePaymentSessionInput {
    paymentId!: number;
    successUrl!: string | undefined;
    cancelUrl!: string | undefined;

    constructor(data?: IStripeCreatePaymentSessionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.successUrl = _data["successUrl"];
            this.cancelUrl = _data["cancelUrl"];
        }
    }

    static fromJS(data: any): StripeCreatePaymentSessionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreatePaymentSessionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["successUrl"] = this.successUrl;
        data["cancelUrl"] = this.cancelUrl;
        return data; 
    }
}

export interface IStripeCreatePaymentSessionInput {
    paymentId: number;
    successUrl: string | undefined;
    cancelUrl: string | undefined;
}

export class StripePaymentResultOutput implements IStripePaymentResultOutput {
    paymentDone!: boolean;

    constructor(data?: IStripePaymentResultOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentDone = _data["paymentDone"];
        }
    }

    static fromJS(data: any): StripePaymentResultOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StripePaymentResultOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentDone"] = this.paymentDone;
        return data; 
    }
}

export interface IStripePaymentResultOutput {
    paymentDone: boolean;
}

export class SysteamApplicationITserviceDto implements ISysteamApplicationITserviceDto {
    id!: number;
    systemApplicationId!: number | undefined;
    itServiceId!: number | undefined;

    constructor(data?: ISysteamApplicationITserviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.systemApplicationId = _data["systemApplicationId"];
            this.itServiceId = _data["itServiceId"];
        }
    }

    static fromJS(data: any): SysteamApplicationITserviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SysteamApplicationITserviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["systemApplicationId"] = this.systemApplicationId;
        data["itServiceId"] = this.itServiceId;
        return data; 
    }
}

export interface ISysteamApplicationITserviceDto {
    id: number;
    systemApplicationId: number | undefined;
    itServiceId: number | undefined;
}

export class SysteamApplicationBusinessProcessDto implements ISysteamApplicationBusinessProcessDto {
    id!: number;
    systemApplicationId!: number | undefined;
    businessProcessId!: number | undefined;

    constructor(data?: ISysteamApplicationBusinessProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.systemApplicationId = _data["systemApplicationId"];
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static fromJS(data: any): SysteamApplicationBusinessProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new SysteamApplicationBusinessProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["systemApplicationId"] = this.systemApplicationId;
        data["businessProcessId"] = this.businessProcessId;
        return data; 
    }
}

export interface ISysteamApplicationBusinessProcessDto {
    id: number;
    systemApplicationId: number | undefined;
    businessProcessId: number | undefined;
}

export class SystemApplicationServiceDto implements ISystemApplicationServiceDto {
    id!: number;
    systemApplicationId!: number | undefined;
    businessServiceId!: number | undefined;

    constructor(data?: ISystemApplicationServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.systemApplicationId = _data["systemApplicationId"];
            this.businessServiceId = _data["businessServiceId"];
        }
    }

    static fromJS(data: any): SystemApplicationServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemApplicationServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["systemApplicationId"] = this.systemApplicationId;
        data["businessServiceId"] = this.businessServiceId;
        return data; 
    }
}

export interface ISystemApplicationServiceDto {
    id: number;
    systemApplicationId: number | undefined;
    businessServiceId: number | undefined;
}

export class SystemApplicationDto implements ISystemApplicationDto {
    tenantId!: number | undefined;
    systemId!: string | undefined;
    systemApplicationName!: string | undefined;
    addressOne!: string | undefined;
    addressTwo!: string | undefined;
    state!: string | undefined;
    city!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number | undefined;
    countries!: CountryDto[] | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    businessUnitId!: number | undefined;
    businessUnits!: BusinessUnitPrimaryDto[] | undefined;
    businessOwnerId!: number | undefined;
    employeesList!: BusinessServiceOwner[] | undefined;
    businessUnitGaurdianId!: number | undefined;
    businessUnitGaurdians!: BusinessUnitGaurdianDto[] | undefined;
    confidentialityId!: number | undefined;
    confidentialitys!: GetDynamicValueDto[] | undefined;
    availibilityId!: number | undefined;
    availibilitys!: GetDynamicValueDto[] | undefined;
    integrityId!: number | undefined;
    integritys!: GetDynamicValueDto[] | undefined;
    othersId!: number | undefined;
    otheres!: GetDynamicValueDto[] | undefined;
    iTserviceLists!: ITserviceListDto[] | undefined;
    businessServices!: BusinessServiceSDto[] | undefined;
    businessProcess!: BusinessProcessDetailDto[] | undefined;
    selectedSysteamApplicationITservices!: SysteamApplicationITserviceDto[] | undefined;
    selectedSysteamApplicationBusinessProcess!: SysteamApplicationBusinessProcessDto[] | undefined;
    selectedSystemApplicationServices!: SystemApplicationServiceDto[] | undefined;
    removedSysteamApplicationITservice!: number[] | undefined;
    removedSysteamApplicationBusinessProcess!: number[] | undefined;
    removedSystemApplicationService!: number[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISystemApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.systemId = _data["systemId"];
            this.systemApplicationName = _data["systemApplicationName"];
            this.addressOne = _data["addressOne"];
            this.addressTwo = _data["addressTwo"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(CountryDto.fromJS(item));
            }
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            this.businessUnitId = _data["businessUnitId"];
            if (Array.isArray(_data["businessUnits"])) {
                this.businessUnits = [] as any;
                for (let item of _data["businessUnits"])
                    this.businessUnits!.push(BusinessUnitPrimaryDto.fromJS(item));
            }
            this.businessOwnerId = _data["businessOwnerId"];
            if (Array.isArray(_data["employeesList"])) {
                this.employeesList = [] as any;
                for (let item of _data["employeesList"])
                    this.employeesList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.businessUnitGaurdianId = _data["businessUnitGaurdianId"];
            if (Array.isArray(_data["businessUnitGaurdians"])) {
                this.businessUnitGaurdians = [] as any;
                for (let item of _data["businessUnitGaurdians"])
                    this.businessUnitGaurdians!.push(BusinessUnitGaurdianDto.fromJS(item));
            }
            this.confidentialityId = _data["confidentialityId"];
            if (Array.isArray(_data["confidentialitys"])) {
                this.confidentialitys = [] as any;
                for (let item of _data["confidentialitys"])
                    this.confidentialitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.availibilityId = _data["availibilityId"];
            if (Array.isArray(_data["availibilitys"])) {
                this.availibilitys = [] as any;
                for (let item of _data["availibilitys"])
                    this.availibilitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.integrityId = _data["integrityId"];
            if (Array.isArray(_data["integritys"])) {
                this.integritys = [] as any;
                for (let item of _data["integritys"])
                    this.integritys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.othersId = _data["othersId"];
            if (Array.isArray(_data["otheres"])) {
                this.otheres = [] as any;
                for (let item of _data["otheres"])
                    this.otheres!.push(GetDynamicValueDto.fromJS(item));
            }
            if (Array.isArray(_data["iTserviceLists"])) {
                this.iTserviceLists = [] as any;
                for (let item of _data["iTserviceLists"])
                    this.iTserviceLists!.push(ITserviceListDto.fromJS(item));
            }
            if (Array.isArray(_data["businessServices"])) {
                this.businessServices = [] as any;
                for (let item of _data["businessServices"])
                    this.businessServices!.push(BusinessServiceSDto.fromJS(item));
            }
            if (Array.isArray(_data["businessProcess"])) {
                this.businessProcess = [] as any;
                for (let item of _data["businessProcess"])
                    this.businessProcess!.push(BusinessProcessDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedSysteamApplicationITservices"])) {
                this.selectedSysteamApplicationITservices = [] as any;
                for (let item of _data["selectedSysteamApplicationITservices"])
                    this.selectedSysteamApplicationITservices!.push(SysteamApplicationITserviceDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedSysteamApplicationBusinessProcess"])) {
                this.selectedSysteamApplicationBusinessProcess = [] as any;
                for (let item of _data["selectedSysteamApplicationBusinessProcess"])
                    this.selectedSysteamApplicationBusinessProcess!.push(SysteamApplicationBusinessProcessDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedSystemApplicationServices"])) {
                this.selectedSystemApplicationServices = [] as any;
                for (let item of _data["selectedSystemApplicationServices"])
                    this.selectedSystemApplicationServices!.push(SystemApplicationServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["removedSysteamApplicationITservice"])) {
                this.removedSysteamApplicationITservice = [] as any;
                for (let item of _data["removedSysteamApplicationITservice"])
                    this.removedSysteamApplicationITservice!.push(item);
            }
            if (Array.isArray(_data["removedSysteamApplicationBusinessProcess"])) {
                this.removedSysteamApplicationBusinessProcess = [] as any;
                for (let item of _data["removedSysteamApplicationBusinessProcess"])
                    this.removedSysteamApplicationBusinessProcess!.push(item);
            }
            if (Array.isArray(_data["removedSystemApplicationService"])) {
                this.removedSystemApplicationService = [] as any;
                for (let item of _data["removedSystemApplicationService"])
                    this.removedSystemApplicationService!.push(item);
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SystemApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["systemId"] = this.systemId;
        data["systemApplicationName"] = this.systemApplicationName;
        data["addressOne"] = this.addressOne;
        data["addressTwo"] = this.addressTwo;
        data["state"] = this.state;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        data["businessUnitId"] = this.businessUnitId;
        if (Array.isArray(this.businessUnits)) {
            data["businessUnits"] = [];
            for (let item of this.businessUnits)
                data["businessUnits"].push(item.toJSON());
        }
        data["businessOwnerId"] = this.businessOwnerId;
        if (Array.isArray(this.employeesList)) {
            data["employeesList"] = [];
            for (let item of this.employeesList)
                data["employeesList"].push(item.toJSON());
        }
        data["businessUnitGaurdianId"] = this.businessUnitGaurdianId;
        if (Array.isArray(this.businessUnitGaurdians)) {
            data["businessUnitGaurdians"] = [];
            for (let item of this.businessUnitGaurdians)
                data["businessUnitGaurdians"].push(item.toJSON());
        }
        data["confidentialityId"] = this.confidentialityId;
        if (Array.isArray(this.confidentialitys)) {
            data["confidentialitys"] = [];
            for (let item of this.confidentialitys)
                data["confidentialitys"].push(item.toJSON());
        }
        data["availibilityId"] = this.availibilityId;
        if (Array.isArray(this.availibilitys)) {
            data["availibilitys"] = [];
            for (let item of this.availibilitys)
                data["availibilitys"].push(item.toJSON());
        }
        data["integrityId"] = this.integrityId;
        if (Array.isArray(this.integritys)) {
            data["integritys"] = [];
            for (let item of this.integritys)
                data["integritys"].push(item.toJSON());
        }
        data["othersId"] = this.othersId;
        if (Array.isArray(this.otheres)) {
            data["otheres"] = [];
            for (let item of this.otheres)
                data["otheres"].push(item.toJSON());
        }
        if (Array.isArray(this.iTserviceLists)) {
            data["iTserviceLists"] = [];
            for (let item of this.iTserviceLists)
                data["iTserviceLists"].push(item.toJSON());
        }
        if (Array.isArray(this.businessServices)) {
            data["businessServices"] = [];
            for (let item of this.businessServices)
                data["businessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.businessProcess)) {
            data["businessProcess"] = [];
            for (let item of this.businessProcess)
                data["businessProcess"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedSysteamApplicationITservices)) {
            data["selectedSysteamApplicationITservices"] = [];
            for (let item of this.selectedSysteamApplicationITservices)
                data["selectedSysteamApplicationITservices"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedSysteamApplicationBusinessProcess)) {
            data["selectedSysteamApplicationBusinessProcess"] = [];
            for (let item of this.selectedSysteamApplicationBusinessProcess)
                data["selectedSysteamApplicationBusinessProcess"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedSystemApplicationServices)) {
            data["selectedSystemApplicationServices"] = [];
            for (let item of this.selectedSystemApplicationServices)
                data["selectedSystemApplicationServices"].push(item.toJSON());
        }
        if (Array.isArray(this.removedSysteamApplicationITservice)) {
            data["removedSysteamApplicationITservice"] = [];
            for (let item of this.removedSysteamApplicationITservice)
                data["removedSysteamApplicationITservice"].push(item);
        }
        if (Array.isArray(this.removedSysteamApplicationBusinessProcess)) {
            data["removedSysteamApplicationBusinessProcess"] = [];
            for (let item of this.removedSysteamApplicationBusinessProcess)
                data["removedSysteamApplicationBusinessProcess"].push(item);
        }
        if (Array.isArray(this.removedSystemApplicationService)) {
            data["removedSystemApplicationService"] = [];
            for (let item of this.removedSystemApplicationService)
                data["removedSystemApplicationService"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISystemApplicationDto {
    tenantId: number | undefined;
    systemId: string | undefined;
    systemApplicationName: string | undefined;
    addressOne: string | undefined;
    addressTwo: string | undefined;
    state: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    countryId: number | undefined;
    countries: CountryDto[] | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    businessUnitId: number | undefined;
    businessUnits: BusinessUnitPrimaryDto[] | undefined;
    businessOwnerId: number | undefined;
    employeesList: BusinessServiceOwner[] | undefined;
    businessUnitGaurdianId: number | undefined;
    businessUnitGaurdians: BusinessUnitGaurdianDto[] | undefined;
    confidentialityId: number | undefined;
    confidentialitys: GetDynamicValueDto[] | undefined;
    availibilityId: number | undefined;
    availibilitys: GetDynamicValueDto[] | undefined;
    integrityId: number | undefined;
    integritys: GetDynamicValueDto[] | undefined;
    othersId: number | undefined;
    otheres: GetDynamicValueDto[] | undefined;
    iTserviceLists: ITserviceListDto[] | undefined;
    businessServices: BusinessServiceSDto[] | undefined;
    businessProcess: BusinessProcessDetailDto[] | undefined;
    selectedSysteamApplicationITservices: SysteamApplicationITserviceDto[] | undefined;
    selectedSysteamApplicationBusinessProcess: SysteamApplicationBusinessProcessDto[] | undefined;
    selectedSystemApplicationServices: SystemApplicationServiceDto[] | undefined;
    removedSysteamApplicationITservice: number[] | undefined;
    removedSysteamApplicationBusinessProcess: number[] | undefined;
    removedSystemApplicationService: number[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class SystemApplicationListDto implements ISystemApplicationListDto {
    tenantId!: number | undefined;
    systemId!: string | undefined;
    systemApplicationName!: string | undefined;
    addressOne!: string | undefined;
    addressTwo!: string | undefined;
    state!: string | undefined;
    city!: string | undefined;
    postalCode!: string | undefined;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationDto;
    businessUnitId!: number | undefined;
    businessUnit!: BusinessUnitPrimaryDto;
    businessOwnerId!: number | undefined;
    businessOwner!: BusinessServiceOwner;
    confidentialityId!: number | undefined;
    confidentiality!: DynamicPropertyValue;
    availibilityId!: number | undefined;
    availibility!: DynamicPropertyValue;
    integrityId!: number | undefined;
    integrity!: DynamicPropertyValue;
    othersId!: number | undefined;
    others!: DynamicPropertyValue;
    id!: number;

    constructor(data?: ISystemApplicationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.systemId = _data["systemId"];
            this.systemApplicationName = _data["systemApplicationName"];
            this.addressOne = _data["addressOne"];
            this.addressTwo = _data["addressTwo"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.businessUnitId = _data["businessUnitId"];
            this.businessUnit = _data["businessUnit"] ? BusinessUnitPrimaryDto.fromJS(_data["businessUnit"]) : <any>undefined;
            this.businessOwnerId = _data["businessOwnerId"];
            this.businessOwner = _data["businessOwner"] ? BusinessServiceOwner.fromJS(_data["businessOwner"]) : <any>undefined;
            this.confidentialityId = _data["confidentialityId"];
            this.confidentiality = _data["confidentiality"] ? DynamicPropertyValue.fromJS(_data["confidentiality"]) : <any>undefined;
            this.availibilityId = _data["availibilityId"];
            this.availibility = _data["availibility"] ? DynamicPropertyValue.fromJS(_data["availibility"]) : <any>undefined;
            this.integrityId = _data["integrityId"];
            this.integrity = _data["integrity"] ? DynamicPropertyValue.fromJS(_data["integrity"]) : <any>undefined;
            this.othersId = _data["othersId"];
            this.others = _data["others"] ? DynamicPropertyValue.fromJS(_data["others"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SystemApplicationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemApplicationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["systemId"] = this.systemId;
        data["systemApplicationName"] = this.systemApplicationName;
        data["addressOne"] = this.addressOne;
        data["addressTwo"] = this.addressTwo;
        data["state"] = this.state;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["businessUnitId"] = this.businessUnitId;
        data["businessUnit"] = this.businessUnit ? this.businessUnit.toJSON() : <any>undefined;
        data["businessOwnerId"] = this.businessOwnerId;
        data["businessOwner"] = this.businessOwner ? this.businessOwner.toJSON() : <any>undefined;
        data["confidentialityId"] = this.confidentialityId;
        data["confidentiality"] = this.confidentiality ? this.confidentiality.toJSON() : <any>undefined;
        data["availibilityId"] = this.availibilityId;
        data["availibility"] = this.availibility ? this.availibility.toJSON() : <any>undefined;
        data["integrityId"] = this.integrityId;
        data["integrity"] = this.integrity ? this.integrity.toJSON() : <any>undefined;
        data["othersId"] = this.othersId;
        data["others"] = this.others ? this.others.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISystemApplicationListDto {
    tenantId: number | undefined;
    systemId: string | undefined;
    systemApplicationName: string | undefined;
    addressOne: string | undefined;
    addressTwo: string | undefined;
    state: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationDto;
    businessUnitId: number | undefined;
    businessUnit: BusinessUnitPrimaryDto;
    businessOwnerId: number | undefined;
    businessOwner: BusinessServiceOwner;
    confidentialityId: number | undefined;
    confidentiality: DynamicPropertyValue;
    availibilityId: number | undefined;
    availibility: DynamicPropertyValue;
    integrityId: number | undefined;
    integrity: DynamicPropertyValue;
    othersId: number | undefined;
    others: DynamicPropertyValue;
    id: number;
}

export class PagedResultDtoOfSystemApplicationListDto implements IPagedResultDtoOfSystemApplicationListDto {
    totalCount!: number;
    items!: SystemApplicationListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSystemApplicationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SystemApplicationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSystemApplicationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSystemApplicationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSystemApplicationListDto {
    totalCount: number;
    items: SystemApplicationListDto[] | undefined;
}

export enum Frequency {
    OneTime = 1,
    Daily = 2,
    Periodic = 3,
}

export enum Priority {
    High = 1,
    Medium = 2,
    Low = 3,
}

export class ProjectListsDto implements IProjectListsDto {
    id!: number;
    projectName!: string | undefined;

    constructor(data?: IProjectListsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectName = _data["projectName"];
        }
    }

    static fromJS(data: any): ProjectListsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectListsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectName"] = this.projectName;
        return data; 
    }
}

export interface IProjectListsDto {
    id: number;
    projectName: string | undefined;
}

export class MeetingsDto implements IMeetingsDto {
    id!: number;
    meetingTitle!: string | undefined;

    constructor(data?: IMeetingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.meetingTitle = _data["meetingTitle"];
        }
    }

    static fromJS(data: any): MeetingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["meetingTitle"] = this.meetingTitle;
        return data; 
    }
}

export interface IMeetingsDto {
    id: number;
    meetingTitle: string | undefined;
}

export class TaskAssociatedProjectDto implements ITaskAssociatedProjectDto {
    id!: number;
    addTaskId!: number | undefined;
    projectId!: number | undefined;

    constructor(data?: ITaskAssociatedProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addTaskId = _data["addTaskId"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): TaskAssociatedProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskAssociatedProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addTaskId"] = this.addTaskId;
        data["projectId"] = this.projectId;
        return data; 
    }
}

export interface ITaskAssociatedProjectDto {
    id: number;
    addTaskId: number | undefined;
    projectId: number | undefined;
}

export class TaskRelatedMemberDto implements ITaskRelatedMemberDto {
    id!: number;
    addTaskId!: number | undefined;
    employeeId!: number | undefined;

    constructor(data?: ITaskRelatedMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addTaskId = _data["addTaskId"];
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): TaskRelatedMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskRelatedMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addTaskId"] = this.addTaskId;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface ITaskRelatedMemberDto {
    id: number;
    addTaskId: number | undefined;
    employeeId: number | undefined;
}

export class TaskNotificationDto implements ITaskNotificationDto {
    id!: number;
    addTaskId!: number | undefined;
    employeeId!: number | undefined;

    constructor(data?: ITaskNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addTaskId = _data["addTaskId"];
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): TaskNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addTaskId"] = this.addTaskId;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface ITaskNotificationDto {
    id: number;
    addTaskId: number | undefined;
    employeeId: number | undefined;
}

export class TaskAttachmentDto implements ITaskAttachmentDto {
    id!: number;
    addTaskId!: number | undefined;
    document!: string | undefined;

    constructor(data?: ITaskAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addTaskId = _data["addTaskId"];
            this.document = _data["document"];
        }
    }

    static fromJS(data: any): TaskAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addTaskId"] = this.addTaskId;
        data["document"] = this.document;
        return data; 
    }
}

export interface ITaskAttachmentDto {
    id: number;
    addTaskId: number | undefined;
    document: string | undefined;
}

export class MeetingTaskDto implements IMeetingTaskDto {
    id!: number;
    addTaskId!: number | undefined;
    meetingId!: number | undefined;

    constructor(data?: IMeetingTaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addTaskId = _data["addTaskId"];
            this.meetingId = _data["meetingId"];
        }
    }

    static fromJS(data: any): MeetingTaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingTaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addTaskId"] = this.addTaskId;
        data["meetingId"] = this.meetingId;
        return data; 
    }
}

export interface IMeetingTaskDto {
    id: number;
    addTaskId: number | undefined;
    meetingId: number | undefined;
}

export class TaskinfoDto implements ITaskinfoDto {
    tenantId!: number | undefined;
    taskId!: string | undefined;
    taskDescription!: string | undefined;
    taskTitle!: string | undefined;
    frequencys!: Frequency;
    prioritys!: Priority;
    tags!: string | undefined;
    days!: number | undefined;
    startDate!: DateTime | undefined;
    endDate!: DateTime | undefined;
    actualCompleted!: DateTime | undefined;
    taskTypeId!: number | undefined;
    taskTypes!: GetDynamicValueDto[] | undefined;
    linkedToId!: number | undefined;
    linkedList!: GetDynamicValueDto[] | undefined;
    statusId!: number | undefined;
    statuses!: GetDynamicValueDto[] | undefined;
    riskLevelId!: number | undefined;
    riskLevels!: GetDynamicValueDto[] | undefined;
    requestedById!: number | undefined;
    requestedList!: BusinessServiceOwner[] | undefined;
    assignedUserId!: number | undefined;
    assignedUserList!: BusinessServiceOwner[] | undefined;
    assignedToId!: number | undefined;
    assignedToList!: BusinessServiceOwner[] | undefined;
    projectList!: ProjectListsDto[] | undefined;
    meetingList!: MeetingsDto[] | undefined;
    selectedAssociatedProjects!: TaskAssociatedProjectDto[] | undefined;
    removedAssociatedProjects!: number[] | undefined;
    selectedRelatedMembers!: TaskRelatedMemberDto[] | undefined;
    removedRelatedMembers!: number[] | undefined;
    selectedTaskNotifications!: TaskNotificationDto[] | undefined;
    removedNotifications!: number[] | undefined;
    selectedTaskTaskAttachments!: TaskAttachmentDto[] | undefined;
    uploadFiles!: UploadFileDto[] | undefined;
    removedTaskTaskAttachments!: number[] | undefined;
    selectedMeetingTasks!: MeetingTaskDto[] | undefined;
    removedMeetingTasks!: number[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITaskinfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.taskId = _data["taskId"];
            this.taskDescription = _data["taskDescription"];
            this.taskTitle = _data["taskTitle"];
            this.frequencys = _data["frequencys"];
            this.prioritys = _data["prioritys"];
            this.tags = _data["tags"];
            this.days = _data["days"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
            this.actualCompleted = _data["actualCompleted"] ? DateTime.fromISO(_data["actualCompleted"].toString()) : <any>undefined;
            this.taskTypeId = _data["taskTypeId"];
            if (Array.isArray(_data["taskTypes"])) {
                this.taskTypes = [] as any;
                for (let item of _data["taskTypes"])
                    this.taskTypes!.push(GetDynamicValueDto.fromJS(item));
            }
            this.linkedToId = _data["linkedToId"];
            if (Array.isArray(_data["linkedList"])) {
                this.linkedList = [] as any;
                for (let item of _data["linkedList"])
                    this.linkedList!.push(GetDynamicValueDto.fromJS(item));
            }
            this.statusId = _data["statusId"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(GetDynamicValueDto.fromJS(item));
            }
            this.riskLevelId = _data["riskLevelId"];
            if (Array.isArray(_data["riskLevels"])) {
                this.riskLevels = [] as any;
                for (let item of _data["riskLevels"])
                    this.riskLevels!.push(GetDynamicValueDto.fromJS(item));
            }
            this.requestedById = _data["requestedById"];
            if (Array.isArray(_data["requestedList"])) {
                this.requestedList = [] as any;
                for (let item of _data["requestedList"])
                    this.requestedList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.assignedUserId = _data["assignedUserId"];
            if (Array.isArray(_data["assignedUserList"])) {
                this.assignedUserList = [] as any;
                for (let item of _data["assignedUserList"])
                    this.assignedUserList!.push(BusinessServiceOwner.fromJS(item));
            }
            this.assignedToId = _data["assignedToId"];
            if (Array.isArray(_data["assignedToList"])) {
                this.assignedToList = [] as any;
                for (let item of _data["assignedToList"])
                    this.assignedToList!.push(BusinessServiceOwner.fromJS(item));
            }
            if (Array.isArray(_data["projectList"])) {
                this.projectList = [] as any;
                for (let item of _data["projectList"])
                    this.projectList!.push(ProjectListsDto.fromJS(item));
            }
            if (Array.isArray(_data["meetingList"])) {
                this.meetingList = [] as any;
                for (let item of _data["meetingList"])
                    this.meetingList!.push(MeetingsDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedAssociatedProjects"])) {
                this.selectedAssociatedProjects = [] as any;
                for (let item of _data["selectedAssociatedProjects"])
                    this.selectedAssociatedProjects!.push(TaskAssociatedProjectDto.fromJS(item));
            }
            if (Array.isArray(_data["removedAssociatedProjects"])) {
                this.removedAssociatedProjects = [] as any;
                for (let item of _data["removedAssociatedProjects"])
                    this.removedAssociatedProjects!.push(item);
            }
            if (Array.isArray(_data["selectedRelatedMembers"])) {
                this.selectedRelatedMembers = [] as any;
                for (let item of _data["selectedRelatedMembers"])
                    this.selectedRelatedMembers!.push(TaskRelatedMemberDto.fromJS(item));
            }
            if (Array.isArray(_data["removedRelatedMembers"])) {
                this.removedRelatedMembers = [] as any;
                for (let item of _data["removedRelatedMembers"])
                    this.removedRelatedMembers!.push(item);
            }
            if (Array.isArray(_data["selectedTaskNotifications"])) {
                this.selectedTaskNotifications = [] as any;
                for (let item of _data["selectedTaskNotifications"])
                    this.selectedTaskNotifications!.push(TaskNotificationDto.fromJS(item));
            }
            if (Array.isArray(_data["removedNotifications"])) {
                this.removedNotifications = [] as any;
                for (let item of _data["removedNotifications"])
                    this.removedNotifications!.push(item);
            }
            if (Array.isArray(_data["selectedTaskTaskAttachments"])) {
                this.selectedTaskTaskAttachments = [] as any;
                for (let item of _data["selectedTaskTaskAttachments"])
                    this.selectedTaskTaskAttachments!.push(TaskAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["uploadFiles"])) {
                this.uploadFiles = [] as any;
                for (let item of _data["uploadFiles"])
                    this.uploadFiles!.push(UploadFileDto.fromJS(item));
            }
            if (Array.isArray(_data["removedTaskTaskAttachments"])) {
                this.removedTaskTaskAttachments = [] as any;
                for (let item of _data["removedTaskTaskAttachments"])
                    this.removedTaskTaskAttachments!.push(item);
            }
            if (Array.isArray(_data["selectedMeetingTasks"])) {
                this.selectedMeetingTasks = [] as any;
                for (let item of _data["selectedMeetingTasks"])
                    this.selectedMeetingTasks!.push(MeetingTaskDto.fromJS(item));
            }
            if (Array.isArray(_data["removedMeetingTasks"])) {
                this.removedMeetingTasks = [] as any;
                for (let item of _data["removedMeetingTasks"])
                    this.removedMeetingTasks!.push(item);
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaskinfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskinfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["taskId"] = this.taskId;
        data["taskDescription"] = this.taskDescription;
        data["taskTitle"] = this.taskTitle;
        data["frequencys"] = this.frequencys;
        data["prioritys"] = this.prioritys;
        data["tags"] = this.tags;
        data["days"] = this.days;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        data["actualCompleted"] = this.actualCompleted ? this.actualCompleted.toString() : <any>undefined;
        data["taskTypeId"] = this.taskTypeId;
        if (Array.isArray(this.taskTypes)) {
            data["taskTypes"] = [];
            for (let item of this.taskTypes)
                data["taskTypes"].push(item.toJSON());
        }
        data["linkedToId"] = this.linkedToId;
        if (Array.isArray(this.linkedList)) {
            data["linkedList"] = [];
            for (let item of this.linkedList)
                data["linkedList"].push(item.toJSON());
        }
        data["statusId"] = this.statusId;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        data["riskLevelId"] = this.riskLevelId;
        if (Array.isArray(this.riskLevels)) {
            data["riskLevels"] = [];
            for (let item of this.riskLevels)
                data["riskLevels"].push(item.toJSON());
        }
        data["requestedById"] = this.requestedById;
        if (Array.isArray(this.requestedList)) {
            data["requestedList"] = [];
            for (let item of this.requestedList)
                data["requestedList"].push(item.toJSON());
        }
        data["assignedUserId"] = this.assignedUserId;
        if (Array.isArray(this.assignedUserList)) {
            data["assignedUserList"] = [];
            for (let item of this.assignedUserList)
                data["assignedUserList"].push(item.toJSON());
        }
        data["assignedToId"] = this.assignedToId;
        if (Array.isArray(this.assignedToList)) {
            data["assignedToList"] = [];
            for (let item of this.assignedToList)
                data["assignedToList"].push(item.toJSON());
        }
        if (Array.isArray(this.projectList)) {
            data["projectList"] = [];
            for (let item of this.projectList)
                data["projectList"].push(item.toJSON());
        }
        if (Array.isArray(this.meetingList)) {
            data["meetingList"] = [];
            for (let item of this.meetingList)
                data["meetingList"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedAssociatedProjects)) {
            data["selectedAssociatedProjects"] = [];
            for (let item of this.selectedAssociatedProjects)
                data["selectedAssociatedProjects"].push(item.toJSON());
        }
        if (Array.isArray(this.removedAssociatedProjects)) {
            data["removedAssociatedProjects"] = [];
            for (let item of this.removedAssociatedProjects)
                data["removedAssociatedProjects"].push(item);
        }
        if (Array.isArray(this.selectedRelatedMembers)) {
            data["selectedRelatedMembers"] = [];
            for (let item of this.selectedRelatedMembers)
                data["selectedRelatedMembers"].push(item.toJSON());
        }
        if (Array.isArray(this.removedRelatedMembers)) {
            data["removedRelatedMembers"] = [];
            for (let item of this.removedRelatedMembers)
                data["removedRelatedMembers"].push(item);
        }
        if (Array.isArray(this.selectedTaskNotifications)) {
            data["selectedTaskNotifications"] = [];
            for (let item of this.selectedTaskNotifications)
                data["selectedTaskNotifications"].push(item.toJSON());
        }
        if (Array.isArray(this.removedNotifications)) {
            data["removedNotifications"] = [];
            for (let item of this.removedNotifications)
                data["removedNotifications"].push(item);
        }
        if (Array.isArray(this.selectedTaskTaskAttachments)) {
            data["selectedTaskTaskAttachments"] = [];
            for (let item of this.selectedTaskTaskAttachments)
                data["selectedTaskTaskAttachments"].push(item.toJSON());
        }
        if (Array.isArray(this.uploadFiles)) {
            data["uploadFiles"] = [];
            for (let item of this.uploadFiles)
                data["uploadFiles"].push(item.toJSON());
        }
        if (Array.isArray(this.removedTaskTaskAttachments)) {
            data["removedTaskTaskAttachments"] = [];
            for (let item of this.removedTaskTaskAttachments)
                data["removedTaskTaskAttachments"].push(item);
        }
        if (Array.isArray(this.selectedMeetingTasks)) {
            data["selectedMeetingTasks"] = [];
            for (let item of this.selectedMeetingTasks)
                data["selectedMeetingTasks"].push(item.toJSON());
        }
        if (Array.isArray(this.removedMeetingTasks)) {
            data["removedMeetingTasks"] = [];
            for (let item of this.removedMeetingTasks)
                data["removedMeetingTasks"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITaskinfoDto {
    tenantId: number | undefined;
    taskId: string | undefined;
    taskDescription: string | undefined;
    taskTitle: string | undefined;
    frequencys: Frequency;
    prioritys: Priority;
    tags: string | undefined;
    days: number | undefined;
    startDate: DateTime | undefined;
    endDate: DateTime | undefined;
    actualCompleted: DateTime | undefined;
    taskTypeId: number | undefined;
    taskTypes: GetDynamicValueDto[] | undefined;
    linkedToId: number | undefined;
    linkedList: GetDynamicValueDto[] | undefined;
    statusId: number | undefined;
    statuses: GetDynamicValueDto[] | undefined;
    riskLevelId: number | undefined;
    riskLevels: GetDynamicValueDto[] | undefined;
    requestedById: number | undefined;
    requestedList: BusinessServiceOwner[] | undefined;
    assignedUserId: number | undefined;
    assignedUserList: BusinessServiceOwner[] | undefined;
    assignedToId: number | undefined;
    assignedToList: BusinessServiceOwner[] | undefined;
    projectList: ProjectListsDto[] | undefined;
    meetingList: MeetingsDto[] | undefined;
    selectedAssociatedProjects: TaskAssociatedProjectDto[] | undefined;
    removedAssociatedProjects: number[] | undefined;
    selectedRelatedMembers: TaskRelatedMemberDto[] | undefined;
    removedRelatedMembers: number[] | undefined;
    selectedTaskNotifications: TaskNotificationDto[] | undefined;
    removedNotifications: number[] | undefined;
    selectedTaskTaskAttachments: TaskAttachmentDto[] | undefined;
    uploadFiles: UploadFileDto[] | undefined;
    removedTaskTaskAttachments: number[] | undefined;
    selectedMeetingTasks: MeetingTaskDto[] | undefined;
    removedMeetingTasks: number[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class TaskListDto implements ITaskListDto {
    taskId!: string | undefined;
    taskTitle!: string | undefined;
    requestedById!: number | undefined;
    requestedBy!: GetEmployeeForEditDto;
    taskTypeId!: number | undefined;
    taskType!: DynamicPropertyValue;
    assignedUserId!: number | undefined;
    assignedUser!: GetEmployeeForEditDto;
    isActive!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: ITaskListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.taskTitle = _data["taskTitle"];
            this.requestedById = _data["requestedById"];
            this.requestedBy = _data["requestedBy"] ? GetEmployeeForEditDto.fromJS(_data["requestedBy"]) : <any>undefined;
            this.taskTypeId = _data["taskTypeId"];
            this.taskType = _data["taskType"] ? DynamicPropertyValue.fromJS(_data["taskType"]) : <any>undefined;
            this.assignedUserId = _data["assignedUserId"];
            this.assignedUser = _data["assignedUser"] ? GetEmployeeForEditDto.fromJS(_data["assignedUser"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaskListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["taskTitle"] = this.taskTitle;
        data["requestedById"] = this.requestedById;
        data["requestedBy"] = this.requestedBy ? this.requestedBy.toJSON() : <any>undefined;
        data["taskTypeId"] = this.taskTypeId;
        data["taskType"] = this.taskType ? this.taskType.toJSON() : <any>undefined;
        data["assignedUserId"] = this.assignedUserId;
        data["assignedUser"] = this.assignedUser ? this.assignedUser.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITaskListDto {
    taskId: string | undefined;
    taskTitle: string | undefined;
    requestedById: number | undefined;
    requestedBy: GetEmployeeForEditDto;
    taskTypeId: number | undefined;
    taskType: DynamicPropertyValue;
    assignedUserId: number | undefined;
    assignedUser: GetEmployeeForEditDto;
    isActive: boolean;
    creationTime: DateTime;
    id: number;
}

export class PagedResultDtoOfTaskListDto implements IPagedResultDtoOfTaskListDto {
    totalCount!: number;
    items!: TaskListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTaskListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TaskListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTaskListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTaskListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTaskListDto {
    totalCount: number;
    items: TaskListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    subscriptionEndDateUtc!: DateTime | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = _data["editionId"];
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    creationTime: DateTime;
    subscriptionEndDateUtc: DateTime | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[] | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean;
    sendActivationEmail!: boolean;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
            this.connectionString = _data["connectionString"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.editionId = _data["editionId"];
            this.isActive = _data["isActive"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.connectionString = _data["connectionString"];
            this.editionId = _data["editionId"];
            this.isActive = _data["isActive"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id!: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDto {
    id: number;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number;
    closed!: number;
    rate!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.earnings = _data["earnings"];
            this.cases = _data["cases"];
            this.closed = _data["closed"];
            this.rate = _data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number;
    closed: number;
    rate: string | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["memberActivities"])) {
                this.memberActivities = [] as any;
                for (let item of _data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberActivities)) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export enum SalesSummaryDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number;
    profit!: number;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.period = _data["period"];
            this.sales = _data["sales"];
            this.profit = _data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number;
    profit: number;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class GetTopStatsOutput implements IGetTopStatsOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;

    constructor(data?: IGetTopStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
        }
    }

    static fromJS(data: any): GetTopStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTopStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        return data; 
    }
}

export interface IGetTopStatsOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
}

export class GetProfitShareOutput implements IGetProfitShareOutput {
    profitShares!: number[] | undefined;

    constructor(data?: IGetProfitShareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetProfitShareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfitShareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }
}

export interface IGetProfitShareOutput {
    profitShares: number[] | undefined;
}

export class GetDailySalesOutput implements IGetDailySalesOutput {
    dailySales!: number[] | undefined;

    constructor(data?: IGetDailySalesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDailySalesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDailySalesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        return data; 
    }
}

export interface IGetDailySalesOutput {
    dailySales: number[] | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSalesSummaryOutput {
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    salesSummary: SalesSummaryData[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number;
    change!: number[] | undefined;
    averagePrice!: number;
    totalPrice!: number;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryName = _data["countryName"];
            this.sales = _data["sales"];
            if (Array.isArray(_data["change"])) {
                this.change = [] as any;
                for (let item of _data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = _data["averagePrice"];
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (Array.isArray(this.change)) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number;
    change: number[] | undefined;
    averagePrice: number;
    totalPrice: number;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stats"])) {
                this.stats = [] as any;
                for (let item of _data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stats)) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
}

export enum SubscriptionStartType {
    Free = 1,
    Trial = 2,
    Paid = 3,
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: SubscriptionStartType;
    editionId!: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
            this.captchaResponse = _data["captchaResponse"];
            this.subscriptionStartType = _data["subscriptionStartType"];
            this.editionId = _data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data; 
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType;
    editionId: number | undefined;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean;
    isActive!: boolean;
    isEmailConfirmationRequired!: boolean;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.isTenantActive = _data["isTenantActive"];
            this.isActive = _data["isActive"];
            this.isEmailConfirmationRequired = _data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }
}

export interface IRegisterTenantOutput {
    tenantId: number;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType;
    textHtmlColor!: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? IInputType.fromJS(_data["inputType"]) : <any>undefined;
            this.textHtmlColor = _data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto;
    featureValues!: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionSelectDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto;
    featureValues: NameValueDto[] | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allFeatures"])) {
                this.allFeatures = [] as any;
                for (let item of _data["allFeatures"])
                    this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (Array.isArray(_data["editionsWithFeatures"])) {
                this.editionsWithFeatures = [] as any;
                for (let item of _data["editionsWithFeatures"])
                    this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allFeatures)) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (Array.isArray(this.editionsWithFeatures)) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredUserActiveByDefault!: boolean;
    isEmailConfirmationRequiredForLogin!: boolean;
    useCaptchaOnRegistration!: boolean;
    useCaptchaOnLogin!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    allowUsingGravatarProfilePicture!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = _data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.allowUsingGravatarProfilePicture = _data["allowUsingGravatarProfilePicture"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["allowUsingGravatarProfilePicture"] = this.allowUsingGravatarProfilePicture;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredUserActiveByDefault: boolean;
    isEmailConfirmationRequiredForLogin: boolean;
    useCaptchaOnRegistration: boolean;
    useCaptchaOnLogin: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    allowUsingGravatarProfilePicture: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings!: boolean;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.useHostDefaultEmailSettings = _data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean;
    isEnabled!: boolean;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isModuleEnabled = _data["isModuleEnabled"];
            this.isEnabled = _data["isEnabled"];
            this.domain = _data["domain"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean;
    isEnabled: boolean;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalName = _data["legalName"];
            this.address = _data["address"];
            this.taxVatNo = _data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: TenantEmailSettingsEditDto;
    ldap!: LdapSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto;
    otherSettings!: TenantOtherSettingsEditDto;
    externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : <any>undefined;
            this.userManagement = _data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = _data["email"] ? TenantEmailSettingsEditDto.fromJS(_data["email"]) : <any>undefined;
            this.ldap = _data["ldap"] ? LdapSettingsEditDto.fromJS(_data["ldap"]) : <any>undefined;
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? TenantBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
            this.externalLoginProviderSettings = _data["externalLoginProviderSettings"] ? ExternalLoginProviderSettingsEditDto.fromJS(_data["externalLoginProviderSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["externalLoginProviderSettings"] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto;
    otherSettings: TenantOtherSettingsEditDto;
    externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto;
}

export enum SettingScopes {
    Application = 1,
    Tenant = 2,
    User = 4,
    All = 7,
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;
    captchaResponse!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.twoFactorVerificationCode = _data["twoFactorVerificationCode"];
            this.rememberClient = _data["rememberClient"];
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.singleSignIn = _data["singleSignIn"];
            this.returnUrl = _data["returnUrl"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    captchaResponse: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    shouldResetPassword!: boolean;
    passwordResetCode!: string | undefined;
    userId!: number;
    requiresTwoFactorVerification!: boolean;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.shouldResetPassword = _data["shouldResetPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.userId = _data["userId"];
            this.requiresTwoFactorVerification = _data["requiresTwoFactorVerification"];
            if (Array.isArray(_data["twoFactorAuthProviders"])) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of _data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (Array.isArray(this.twoFactorAuthProviders)) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.provider = _data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string]: string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
            if (_data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in _data["additionalParams"]) {
                    if (_data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams![key] = _data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string]: string; } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    waitingForActivation!: boolean;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class TwitterGetRequestTokenResponse implements ITwitterGetRequestTokenResponse {
    token!: string | undefined;
    secret!: string | undefined;
    confirmed!: boolean;
    redirectUrl!: string | undefined;

    constructor(data?: ITwitterGetRequestTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.secret = _data["secret"];
            this.confirmed = _data["confirmed"];
            this.redirectUrl = _data["redirectUrl"];
        }
    }

    static fromJS(data: any): TwitterGetRequestTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterGetRequestTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["secret"] = this.secret;
        data["confirmed"] = this.confirmed;
        data["redirectUrl"] = this.redirectUrl;
        return data; 
    }
}

export interface ITwitterGetRequestTokenResponse {
    token: string | undefined;
    secret: string | undefined;
    confirmed: boolean;
    redirectUrl: string | undefined;
}

export class TwitterGetAccessTokenResponse implements ITwitterGetAccessTokenResponse {
    accessToken!: string | undefined;
    accessTokenSecret!: string | undefined;
    userId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: ITwitterGetAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.accessTokenSecret = _data["accessTokenSecret"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): TwitterGetAccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterGetAccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["accessTokenSecret"] = this.accessTokenSecret;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ITwitterGetAccessTokenResponse {
    accessToken: string | undefined;
    accessTokenSecret: string | undefined;
    userId: string | undefined;
    userName: string | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.profilePictureId = _data["profilePictureId"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean;
    creationTime: DateTime;
    id: number;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean;
    inheritedFromOrganizationUnit!: boolean;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleDisplayName = _data["roleDisplayName"];
            this.isAssigned = _data["isAssigned"];
            this.inheritedFromOrganizationUnit = _data["inheritedFromOrganizationUnit"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        data["inheritedFromOrganizationUnit"] = this.inheritedFromOrganizationUnit;
        return data; 
    }
}

export interface IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;
    inheritedFromOrganizationUnit: boolean;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePictureId = _data["profilePictureId"];
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["allOrganizationUnits"])) {
                this.allOrganizationUnits = [] as any;
                for (let item of _data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (Array.isArray(_data["memberedOrganizationUnits"])) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of _data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.allOrganizationUnits)) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.memberedOrganizationUnits)) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfInt64 {
    id: number;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean;
    setRandomPassword!: boolean;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : new UserEditDto();
            if (Array.isArray(_data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of _data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.setRandomPassword = _data["setRandomPassword"];
            if (Array.isArray(_data["organizationUnits"])) {
                this.organizationUnits = [] as any;
                for (let item of _data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (Array.isArray(this.organizationUnits)) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean;
    setRandomPassword: boolean;
    organizationUnits: number[] | undefined;
}

export class UserDelegationDto implements IUserDelegationDto {
    username!: string | undefined;
    startTime!: DateTime;
    endTime!: DateTime;
    id!: number;

    constructor(data?: IUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserDelegationDto {
    username: string | undefined;
    startTime: DateTime;
    endTime: DateTime;
    id: number;
}

export class PagedResultDtoOfUserDelegationDto implements IPagedResultDtoOfUserDelegationDto {
    totalCount!: number;
    items!: UserDelegationDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDelegationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserDelegationDto {
    totalCount: number;
    items: UserDelegationDto[] | undefined;
}

export class CreateUserDelegationDto implements ICreateUserDelegationDto {
    targetUserId!: number;
    startTime!: DateTime;
    endTime!: DateTime;

    constructor(data?: ICreateUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetUserId = _data["targetUserId"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetUserId"] = this.targetUserId;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        return data; 
    }
}

export interface ICreateUserDelegationDto {
    targetUserId: number;
    startTime: DateTime;
    endTime: DateTime;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.usernameOrEmailAddress = _data["usernameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.username = _data["username"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[] | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: DateTime;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userNameOrEmail = _data["userNameOrEmail"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.result = _data["result"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: DateTime;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class GetVendorListDto implements IGetVendorListDto {
    tenantId!: number | undefined;
    vendorId!: string | undefined;
    vendorName!: string | undefined;
    registrationDate!: DateTime | undefined;
    contactFirstName!: string | undefined;
    contactLastName!: string | undefined;
    email!: string | undefined;
    phoneNumber!: string | undefined;
    cellPhoneNumber!: string | undefined;
    faxNumber!: string | undefined;
    website!: string | undefined;
    description!: string | undefined;
    address!: string | undefined;
    addressLine!: string | undefined;
    state!: string | undefined;
    city!: string | undefined;
    postalCode!: number | undefined;
    countryId!: number | undefined;
    country!: DynamicPropertyValue;
    vendorTypeId!: number | undefined;
    vendorType!: DynamicPropertyValue;
    industryId!: number | undefined;
    industry!: DynamicPropertyValue;
    vendorCriticalRatingId!: number | undefined;
    vendorCriticalRating!: DynamicPropertyValue;
    vendorInitialRatingId!: number | undefined;
    vendorInitialRating!: DynamicPropertyValue;
    id!: number;

    constructor(data?: IGetVendorListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.vendorId = _data["vendorId"];
            this.vendorName = _data["vendorName"];
            this.registrationDate = _data["registrationDate"] ? DateTime.fromISO(_data["registrationDate"].toString()) : <any>undefined;
            this.contactFirstName = _data["contactFirstName"];
            this.contactLastName = _data["contactLastName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.cellPhoneNumber = _data["cellPhoneNumber"];
            this.faxNumber = _data["faxNumber"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.addressLine = _data["addressLine"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? DynamicPropertyValue.fromJS(_data["country"]) : <any>undefined;
            this.vendorTypeId = _data["vendorTypeId"];
            this.vendorType = _data["vendorType"] ? DynamicPropertyValue.fromJS(_data["vendorType"]) : <any>undefined;
            this.industryId = _data["industryId"];
            this.industry = _data["industry"] ? DynamicPropertyValue.fromJS(_data["industry"]) : <any>undefined;
            this.vendorCriticalRatingId = _data["vendorCriticalRatingId"];
            this.vendorCriticalRating = _data["vendorCriticalRating"] ? DynamicPropertyValue.fromJS(_data["vendorCriticalRating"]) : <any>undefined;
            this.vendorInitialRatingId = _data["vendorInitialRatingId"];
            this.vendorInitialRating = _data["vendorInitialRating"] ? DynamicPropertyValue.fromJS(_data["vendorInitialRating"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetVendorListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["vendorId"] = this.vendorId;
        data["vendorName"] = this.vendorName;
        data["registrationDate"] = this.registrationDate ? this.registrationDate.toString() : <any>undefined;
        data["contactFirstName"] = this.contactFirstName;
        data["contactLastName"] = this.contactLastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["cellPhoneNumber"] = this.cellPhoneNumber;
        data["faxNumber"] = this.faxNumber;
        data["website"] = this.website;
        data["description"] = this.description;
        data["address"] = this.address;
        data["addressLine"] = this.addressLine;
        data["state"] = this.state;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["vendorTypeId"] = this.vendorTypeId;
        data["vendorType"] = this.vendorType ? this.vendorType.toJSON() : <any>undefined;
        data["industryId"] = this.industryId;
        data["industry"] = this.industry ? this.industry.toJSON() : <any>undefined;
        data["vendorCriticalRatingId"] = this.vendorCriticalRatingId;
        data["vendorCriticalRating"] = this.vendorCriticalRating ? this.vendorCriticalRating.toJSON() : <any>undefined;
        data["vendorInitialRatingId"] = this.vendorInitialRatingId;
        data["vendorInitialRating"] = this.vendorInitialRating ? this.vendorInitialRating.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetVendorListDto {
    tenantId: number | undefined;
    vendorId: string | undefined;
    vendorName: string | undefined;
    registrationDate: DateTime | undefined;
    contactFirstName: string | undefined;
    contactLastName: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    cellPhoneNumber: string | undefined;
    faxNumber: string | undefined;
    website: string | undefined;
    description: string | undefined;
    address: string | undefined;
    addressLine: string | undefined;
    state: string | undefined;
    city: string | undefined;
    postalCode: number | undefined;
    countryId: number | undefined;
    country: DynamicPropertyValue;
    vendorTypeId: number | undefined;
    vendorType: DynamicPropertyValue;
    industryId: number | undefined;
    industry: DynamicPropertyValue;
    vendorCriticalRatingId: number | undefined;
    vendorCriticalRating: DynamicPropertyValue;
    vendorInitialRatingId: number | undefined;
    vendorInitialRating: DynamicPropertyValue;
    id: number;
}

export class PagedResultDtoOfGetVendorListDto implements IPagedResultDtoOfGetVendorListDto {
    totalCount!: number;
    items!: GetVendorListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetVendorListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetVendorListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetVendorListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetVendorListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetVendorListDto {
    totalCount: number;
    items: GetVendorListDto[] | undefined;
}

export class VendorProductServiceDto implements IVendorProductServiceDto {
    id!: number;
    vendorServiceId!: number | undefined;
    vendorId!: number | undefined;

    constructor(data?: IVendorProductServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vendorServiceId = _data["vendorServiceId"];
            this.vendorId = _data["vendorId"];
        }
    }

    static fromJS(data: any): VendorProductServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProductServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vendorServiceId"] = this.vendorServiceId;
        data["vendorId"] = this.vendorId;
        return data; 
    }
}

export interface IVendorProductServiceDto {
    id: number;
    vendorServiceId: number | undefined;
    vendorId: number | undefined;
}

export class VendorInfoDto implements IVendorInfoDto {
    tenantId!: number | undefined;
    vendorId!: string | undefined;
    vendorName!: string | undefined;
    registrationDate!: DateTime | undefined;
    contactFirstName!: string | undefined;
    contactLastName!: string | undefined;
    email!: string | undefined;
    phoneNumber!: string | undefined;
    cellPhoneNumber!: string | undefined;
    faxNumber!: string | undefined;
    website!: string | undefined;
    description!: string | undefined;
    address!: string | undefined;
    addressLine!: string | undefined;
    state!: string | undefined;
    city!: string | undefined;
    postalCode!: number | undefined;
    countryId!: number | undefined;
    countrys!: CountryDto[] | undefined;
    vendorTypeId!: number | undefined;
    vendorTypes!: GetDynamicValueDto[] | undefined;
    industryId!: number | undefined;
    industrys!: GetDynamicValueDto[] | undefined;
    vendorCriticalRatingId!: number | undefined;
    vendorCriticalRatings!: GetDynamicValueDto[] | undefined;
    vendorInitialRatingId!: number | undefined;
    vendorInitialRatings!: GetDynamicValueDto[] | undefined;
    vendorProductList!: GetDynamicValueDto[] | undefined;
    selectedVendorProductServices!: VendorProductServiceDto[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IVendorInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.vendorId = _data["vendorId"];
            this.vendorName = _data["vendorName"];
            this.registrationDate = _data["registrationDate"] ? DateTime.fromISO(_data["registrationDate"].toString()) : <any>undefined;
            this.contactFirstName = _data["contactFirstName"];
            this.contactLastName = _data["contactLastName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.cellPhoneNumber = _data["cellPhoneNumber"];
            this.faxNumber = _data["faxNumber"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.addressLine = _data["addressLine"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            if (Array.isArray(_data["countrys"])) {
                this.countrys = [] as any;
                for (let item of _data["countrys"])
                    this.countrys!.push(CountryDto.fromJS(item));
            }
            this.vendorTypeId = _data["vendorTypeId"];
            if (Array.isArray(_data["vendorTypes"])) {
                this.vendorTypes = [] as any;
                for (let item of _data["vendorTypes"])
                    this.vendorTypes!.push(GetDynamicValueDto.fromJS(item));
            }
            this.industryId = _data["industryId"];
            if (Array.isArray(_data["industrys"])) {
                this.industrys = [] as any;
                for (let item of _data["industrys"])
                    this.industrys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.vendorCriticalRatingId = _data["vendorCriticalRatingId"];
            if (Array.isArray(_data["vendorCriticalRatings"])) {
                this.vendorCriticalRatings = [] as any;
                for (let item of _data["vendorCriticalRatings"])
                    this.vendorCriticalRatings!.push(GetDynamicValueDto.fromJS(item));
            }
            this.vendorInitialRatingId = _data["vendorInitialRatingId"];
            if (Array.isArray(_data["vendorInitialRatings"])) {
                this.vendorInitialRatings = [] as any;
                for (let item of _data["vendorInitialRatings"])
                    this.vendorInitialRatings!.push(GetDynamicValueDto.fromJS(item));
            }
            if (Array.isArray(_data["vendorProductList"])) {
                this.vendorProductList = [] as any;
                for (let item of _data["vendorProductList"])
                    this.vendorProductList!.push(GetDynamicValueDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedVendorProductServices"])) {
                this.selectedVendorProductServices = [] as any;
                for (let item of _data["selectedVendorProductServices"])
                    this.selectedVendorProductServices!.push(VendorProductServiceDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): VendorInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["vendorId"] = this.vendorId;
        data["vendorName"] = this.vendorName;
        data["registrationDate"] = this.registrationDate ? this.registrationDate.toString() : <any>undefined;
        data["contactFirstName"] = this.contactFirstName;
        data["contactLastName"] = this.contactLastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["cellPhoneNumber"] = this.cellPhoneNumber;
        data["faxNumber"] = this.faxNumber;
        data["website"] = this.website;
        data["description"] = this.description;
        data["address"] = this.address;
        data["addressLine"] = this.addressLine;
        data["state"] = this.state;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        if (Array.isArray(this.countrys)) {
            data["countrys"] = [];
            for (let item of this.countrys)
                data["countrys"].push(item.toJSON());
        }
        data["vendorTypeId"] = this.vendorTypeId;
        if (Array.isArray(this.vendorTypes)) {
            data["vendorTypes"] = [];
            for (let item of this.vendorTypes)
                data["vendorTypes"].push(item.toJSON());
        }
        data["industryId"] = this.industryId;
        if (Array.isArray(this.industrys)) {
            data["industrys"] = [];
            for (let item of this.industrys)
                data["industrys"].push(item.toJSON());
        }
        data["vendorCriticalRatingId"] = this.vendorCriticalRatingId;
        if (Array.isArray(this.vendorCriticalRatings)) {
            data["vendorCriticalRatings"] = [];
            for (let item of this.vendorCriticalRatings)
                data["vendorCriticalRatings"].push(item.toJSON());
        }
        data["vendorInitialRatingId"] = this.vendorInitialRatingId;
        if (Array.isArray(this.vendorInitialRatings)) {
            data["vendorInitialRatings"] = [];
            for (let item of this.vendorInitialRatings)
                data["vendorInitialRatings"].push(item.toJSON());
        }
        if (Array.isArray(this.vendorProductList)) {
            data["vendorProductList"] = [];
            for (let item of this.vendorProductList)
                data["vendorProductList"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedVendorProductServices)) {
            data["selectedVendorProductServices"] = [];
            for (let item of this.selectedVendorProductServices)
                data["selectedVendorProductServices"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IVendorInfoDto {
    tenantId: number | undefined;
    vendorId: string | undefined;
    vendorName: string | undefined;
    registrationDate: DateTime | undefined;
    contactFirstName: string | undefined;
    contactLastName: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    cellPhoneNumber: string | undefined;
    faxNumber: string | undefined;
    website: string | undefined;
    description: string | undefined;
    address: string | undefined;
    addressLine: string | undefined;
    state: string | undefined;
    city: string | undefined;
    postalCode: number | undefined;
    countryId: number | undefined;
    countrys: CountryDto[] | undefined;
    vendorTypeId: number | undefined;
    vendorTypes: GetDynamicValueDto[] | undefined;
    industryId: number | undefined;
    industrys: GetDynamicValueDto[] | undefined;
    vendorCriticalRatingId: number | undefined;
    vendorCriticalRatings: GetDynamicValueDto[] | undefined;
    vendorInitialRatingId: number | undefined;
    vendorInitialRatings: GetDynamicValueDto[] | undefined;
    vendorProductList: GetDynamicValueDto[] | undefined;
    selectedVendorProductServices: VendorProductServiceDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ParentVirtualHostListDto implements IParentVirtualHostListDto {
    id!: number;
    hostedServerNameId!: number | undefined;
    virtualAssetName!: string | undefined;

    constructor(data?: IParentVirtualHostListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hostedServerNameId = _data["hostedServerNameId"];
            this.virtualAssetName = _data["virtualAssetName"];
        }
    }

    static fromJS(data: any): ParentVirtualHostListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentVirtualHostListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hostedServerNameId"] = this.hostedServerNameId;
        data["virtualAssetName"] = this.virtualAssetName;
        return data; 
    }
}

export interface IParentVirtualHostListDto {
    id: number;
    hostedServerNameId: number | undefined;
    virtualAssetName: string | undefined;
}

export class VirtualAssetITserviceDto implements IVirtualAssetITserviceDto {
    id!: number;
    virtualAssetId!: number | undefined;
    itServiceId!: number | undefined;

    constructor(data?: IVirtualAssetITserviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.virtualAssetId = _data["virtualAssetId"];
            this.itServiceId = _data["itServiceId"];
        }
    }

    static fromJS(data: any): VirtualAssetITserviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new VirtualAssetITserviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["virtualAssetId"] = this.virtualAssetId;
        data["itServiceId"] = this.itServiceId;
        return data; 
    }
}

export interface IVirtualAssetITserviceDto {
    id: number;
    virtualAssetId: number | undefined;
    itServiceId: number | undefined;
}

export class VirtualAssetBusinessprocessDto implements IVirtualAssetBusinessprocessDto {
    id!: number;
    virtualAssetId!: number | undefined;
    businessProcessId!: number | undefined;

    constructor(data?: IVirtualAssetBusinessprocessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.virtualAssetId = _data["virtualAssetId"];
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static fromJS(data: any): VirtualAssetBusinessprocessDto {
        data = typeof data === 'object' ? data : {};
        let result = new VirtualAssetBusinessprocessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["virtualAssetId"] = this.virtualAssetId;
        data["businessProcessId"] = this.businessProcessId;
        return data; 
    }
}

export interface IVirtualAssetBusinessprocessDto {
    id: number;
    virtualAssetId: number | undefined;
    businessProcessId: number | undefined;
}

export class VirtualAssetBusinessServiceDto implements IVirtualAssetBusinessServiceDto {
    id!: number;
    virtualAssetId!: number | undefined;
    businessServiceId!: number | undefined;

    constructor(data?: IVirtualAssetBusinessServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.virtualAssetId = _data["virtualAssetId"];
            this.businessServiceId = _data["businessServiceId"];
        }
    }

    static fromJS(data: any): VirtualAssetBusinessServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new VirtualAssetBusinessServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["virtualAssetId"] = this.virtualAssetId;
        data["businessServiceId"] = this.businessServiceId;
        return data; 
    }
}

export interface IVirtualAssetBusinessServiceDto {
    id: number;
    virtualAssetId: number | undefined;
    businessServiceId: number | undefined;
}

export class VirtualAssetDto implements IVirtualAssetDto {
    tenantId!: number | undefined;
    virtualAssetId!: string | undefined;
    virtualAssetName!: string | undefined;
    virtualAssetUniqueIdentity!: string | undefined;
    virtualMachine!: boolean;
    description!: string | undefined;
    parentVirtualHostId!: number | undefined;
    parentVirtualHostList!: ParentVirtualHostListDto[] | undefined;
    hostedServerNameId!: number | undefined;
    hardwareAssetList!: HardwareAsseDetailListDto[] | undefined;
    lockThreatOrganizationId!: number | undefined;
    companyLists!: GetOrganizationDto[] | undefined;
    businessUnitId!: number | undefined;
    businessUnitOwners!: BusinessUnitPrimaryDto[] | undefined;
    businessUnitGaurdianId!: number | undefined;
    businessUnitGaurdians!: BusinessUnitGaurdianDto[] | undefined;
    businessOwnerId!: number | undefined;
    employeesList!: BusinessServiceOwner[] | undefined;
    iTserviceLists!: ITserviceListDto[] | undefined;
    businessServices!: BusinessServiceSDto[] | undefined;
    businessProcess!: BusinessProcessDetailDto[] | undefined;
    confidentialityId!: number | undefined;
    confidentialitys!: GetDynamicValueDto[] | undefined;
    availibilityId!: number | undefined;
    availibilitys!: GetDynamicValueDto[] | undefined;
    integrityId!: number | undefined;
    integritys!: GetDynamicValueDto[] | undefined;
    othersId!: number | undefined;
    otheres!: GetDynamicValueDto[] | undefined;
    selectedVirtualAssetITservices!: VirtualAssetITserviceDto[] | undefined;
    selectedVirtualAssetBusinessprocess!: VirtualAssetBusinessprocessDto[] | undefined;
    selectedVirtualAssetBusinessServices!: VirtualAssetBusinessServiceDto[] | undefined;
    removedVirtualAssetITservice!: number[] | undefined;
    removedVirtualAssetBusinessprocess!: number[] | undefined;
    removedVirtualAssetBusinessServices!: number[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IVirtualAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.virtualAssetId = _data["virtualAssetId"];
            this.virtualAssetName = _data["virtualAssetName"];
            this.virtualAssetUniqueIdentity = _data["virtualAssetUniqueIdentity"];
            this.virtualMachine = _data["virtualMachine"];
            this.description = _data["description"];
            this.parentVirtualHostId = _data["parentVirtualHostId"];
            if (Array.isArray(_data["parentVirtualHostList"])) {
                this.parentVirtualHostList = [] as any;
                for (let item of _data["parentVirtualHostList"])
                    this.parentVirtualHostList!.push(ParentVirtualHostListDto.fromJS(item));
            }
            this.hostedServerNameId = _data["hostedServerNameId"];
            if (Array.isArray(_data["hardwareAssetList"])) {
                this.hardwareAssetList = [] as any;
                for (let item of _data["hardwareAssetList"])
                    this.hardwareAssetList!.push(HardwareAsseDetailListDto.fromJS(item));
            }
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            if (Array.isArray(_data["companyLists"])) {
                this.companyLists = [] as any;
                for (let item of _data["companyLists"])
                    this.companyLists!.push(GetOrganizationDto.fromJS(item));
            }
            this.businessUnitId = _data["businessUnitId"];
            if (Array.isArray(_data["businessUnitOwners"])) {
                this.businessUnitOwners = [] as any;
                for (let item of _data["businessUnitOwners"])
                    this.businessUnitOwners!.push(BusinessUnitPrimaryDto.fromJS(item));
            }
            this.businessUnitGaurdianId = _data["businessUnitGaurdianId"];
            if (Array.isArray(_data["businessUnitGaurdians"])) {
                this.businessUnitGaurdians = [] as any;
                for (let item of _data["businessUnitGaurdians"])
                    this.businessUnitGaurdians!.push(BusinessUnitGaurdianDto.fromJS(item));
            }
            this.businessOwnerId = _data["businessOwnerId"];
            if (Array.isArray(_data["employeesList"])) {
                this.employeesList = [] as any;
                for (let item of _data["employeesList"])
                    this.employeesList!.push(BusinessServiceOwner.fromJS(item));
            }
            if (Array.isArray(_data["iTserviceLists"])) {
                this.iTserviceLists = [] as any;
                for (let item of _data["iTserviceLists"])
                    this.iTserviceLists!.push(ITserviceListDto.fromJS(item));
            }
            if (Array.isArray(_data["businessServices"])) {
                this.businessServices = [] as any;
                for (let item of _data["businessServices"])
                    this.businessServices!.push(BusinessServiceSDto.fromJS(item));
            }
            if (Array.isArray(_data["businessProcess"])) {
                this.businessProcess = [] as any;
                for (let item of _data["businessProcess"])
                    this.businessProcess!.push(BusinessProcessDetailDto.fromJS(item));
            }
            this.confidentialityId = _data["confidentialityId"];
            if (Array.isArray(_data["confidentialitys"])) {
                this.confidentialitys = [] as any;
                for (let item of _data["confidentialitys"])
                    this.confidentialitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.availibilityId = _data["availibilityId"];
            if (Array.isArray(_data["availibilitys"])) {
                this.availibilitys = [] as any;
                for (let item of _data["availibilitys"])
                    this.availibilitys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.integrityId = _data["integrityId"];
            if (Array.isArray(_data["integritys"])) {
                this.integritys = [] as any;
                for (let item of _data["integritys"])
                    this.integritys!.push(GetDynamicValueDto.fromJS(item));
            }
            this.othersId = _data["othersId"];
            if (Array.isArray(_data["otheres"])) {
                this.otheres = [] as any;
                for (let item of _data["otheres"])
                    this.otheres!.push(GetDynamicValueDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedVirtualAssetITservices"])) {
                this.selectedVirtualAssetITservices = [] as any;
                for (let item of _data["selectedVirtualAssetITservices"])
                    this.selectedVirtualAssetITservices!.push(VirtualAssetITserviceDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedVirtualAssetBusinessprocess"])) {
                this.selectedVirtualAssetBusinessprocess = [] as any;
                for (let item of _data["selectedVirtualAssetBusinessprocess"])
                    this.selectedVirtualAssetBusinessprocess!.push(VirtualAssetBusinessprocessDto.fromJS(item));
            }
            if (Array.isArray(_data["selectedVirtualAssetBusinessServices"])) {
                this.selectedVirtualAssetBusinessServices = [] as any;
                for (let item of _data["selectedVirtualAssetBusinessServices"])
                    this.selectedVirtualAssetBusinessServices!.push(VirtualAssetBusinessServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["removedVirtualAssetITservice"])) {
                this.removedVirtualAssetITservice = [] as any;
                for (let item of _data["removedVirtualAssetITservice"])
                    this.removedVirtualAssetITservice!.push(item);
            }
            if (Array.isArray(_data["removedVirtualAssetBusinessprocess"])) {
                this.removedVirtualAssetBusinessprocess = [] as any;
                for (let item of _data["removedVirtualAssetBusinessprocess"])
                    this.removedVirtualAssetBusinessprocess!.push(item);
            }
            if (Array.isArray(_data["removedVirtualAssetBusinessServices"])) {
                this.removedVirtualAssetBusinessServices = [] as any;
                for (let item of _data["removedVirtualAssetBusinessServices"])
                    this.removedVirtualAssetBusinessServices!.push(item);
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): VirtualAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new VirtualAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["virtualAssetId"] = this.virtualAssetId;
        data["virtualAssetName"] = this.virtualAssetName;
        data["virtualAssetUniqueIdentity"] = this.virtualAssetUniqueIdentity;
        data["virtualMachine"] = this.virtualMachine;
        data["description"] = this.description;
        data["parentVirtualHostId"] = this.parentVirtualHostId;
        if (Array.isArray(this.parentVirtualHostList)) {
            data["parentVirtualHostList"] = [];
            for (let item of this.parentVirtualHostList)
                data["parentVirtualHostList"].push(item.toJSON());
        }
        data["hostedServerNameId"] = this.hostedServerNameId;
        if (Array.isArray(this.hardwareAssetList)) {
            data["hardwareAssetList"] = [];
            for (let item of this.hardwareAssetList)
                data["hardwareAssetList"].push(item.toJSON());
        }
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        if (Array.isArray(this.companyLists)) {
            data["companyLists"] = [];
            for (let item of this.companyLists)
                data["companyLists"].push(item.toJSON());
        }
        data["businessUnitId"] = this.businessUnitId;
        if (Array.isArray(this.businessUnitOwners)) {
            data["businessUnitOwners"] = [];
            for (let item of this.businessUnitOwners)
                data["businessUnitOwners"].push(item.toJSON());
        }
        data["businessUnitGaurdianId"] = this.businessUnitGaurdianId;
        if (Array.isArray(this.businessUnitGaurdians)) {
            data["businessUnitGaurdians"] = [];
            for (let item of this.businessUnitGaurdians)
                data["businessUnitGaurdians"].push(item.toJSON());
        }
        data["businessOwnerId"] = this.businessOwnerId;
        if (Array.isArray(this.employeesList)) {
            data["employeesList"] = [];
            for (let item of this.employeesList)
                data["employeesList"].push(item.toJSON());
        }
        if (Array.isArray(this.iTserviceLists)) {
            data["iTserviceLists"] = [];
            for (let item of this.iTserviceLists)
                data["iTserviceLists"].push(item.toJSON());
        }
        if (Array.isArray(this.businessServices)) {
            data["businessServices"] = [];
            for (let item of this.businessServices)
                data["businessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.businessProcess)) {
            data["businessProcess"] = [];
            for (let item of this.businessProcess)
                data["businessProcess"].push(item.toJSON());
        }
        data["confidentialityId"] = this.confidentialityId;
        if (Array.isArray(this.confidentialitys)) {
            data["confidentialitys"] = [];
            for (let item of this.confidentialitys)
                data["confidentialitys"].push(item.toJSON());
        }
        data["availibilityId"] = this.availibilityId;
        if (Array.isArray(this.availibilitys)) {
            data["availibilitys"] = [];
            for (let item of this.availibilitys)
                data["availibilitys"].push(item.toJSON());
        }
        data["integrityId"] = this.integrityId;
        if (Array.isArray(this.integritys)) {
            data["integritys"] = [];
            for (let item of this.integritys)
                data["integritys"].push(item.toJSON());
        }
        data["othersId"] = this.othersId;
        if (Array.isArray(this.otheres)) {
            data["otheres"] = [];
            for (let item of this.otheres)
                data["otheres"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedVirtualAssetITservices)) {
            data["selectedVirtualAssetITservices"] = [];
            for (let item of this.selectedVirtualAssetITservices)
                data["selectedVirtualAssetITservices"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedVirtualAssetBusinessprocess)) {
            data["selectedVirtualAssetBusinessprocess"] = [];
            for (let item of this.selectedVirtualAssetBusinessprocess)
                data["selectedVirtualAssetBusinessprocess"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedVirtualAssetBusinessServices)) {
            data["selectedVirtualAssetBusinessServices"] = [];
            for (let item of this.selectedVirtualAssetBusinessServices)
                data["selectedVirtualAssetBusinessServices"].push(item.toJSON());
        }
        if (Array.isArray(this.removedVirtualAssetITservice)) {
            data["removedVirtualAssetITservice"] = [];
            for (let item of this.removedVirtualAssetITservice)
                data["removedVirtualAssetITservice"].push(item);
        }
        if (Array.isArray(this.removedVirtualAssetBusinessprocess)) {
            data["removedVirtualAssetBusinessprocess"] = [];
            for (let item of this.removedVirtualAssetBusinessprocess)
                data["removedVirtualAssetBusinessprocess"].push(item);
        }
        if (Array.isArray(this.removedVirtualAssetBusinessServices)) {
            data["removedVirtualAssetBusinessServices"] = [];
            for (let item of this.removedVirtualAssetBusinessServices)
                data["removedVirtualAssetBusinessServices"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IVirtualAssetDto {
    tenantId: number | undefined;
    virtualAssetId: string | undefined;
    virtualAssetName: string | undefined;
    virtualAssetUniqueIdentity: string | undefined;
    virtualMachine: boolean;
    description: string | undefined;
    parentVirtualHostId: number | undefined;
    parentVirtualHostList: ParentVirtualHostListDto[] | undefined;
    hostedServerNameId: number | undefined;
    hardwareAssetList: HardwareAsseDetailListDto[] | undefined;
    lockThreatOrganizationId: number | undefined;
    companyLists: GetOrganizationDto[] | undefined;
    businessUnitId: number | undefined;
    businessUnitOwners: BusinessUnitPrimaryDto[] | undefined;
    businessUnitGaurdianId: number | undefined;
    businessUnitGaurdians: BusinessUnitGaurdianDto[] | undefined;
    businessOwnerId: number | undefined;
    employeesList: BusinessServiceOwner[] | undefined;
    iTserviceLists: ITserviceListDto[] | undefined;
    businessServices: BusinessServiceSDto[] | undefined;
    businessProcess: BusinessProcessDetailDto[] | undefined;
    confidentialityId: number | undefined;
    confidentialitys: GetDynamicValueDto[] | undefined;
    availibilityId: number | undefined;
    availibilitys: GetDynamicValueDto[] | undefined;
    integrityId: number | undefined;
    integritys: GetDynamicValueDto[] | undefined;
    othersId: number | undefined;
    otheres: GetDynamicValueDto[] | undefined;
    selectedVirtualAssetITservices: VirtualAssetITserviceDto[] | undefined;
    selectedVirtualAssetBusinessprocess: VirtualAssetBusinessprocessDto[] | undefined;
    selectedVirtualAssetBusinessServices: VirtualAssetBusinessServiceDto[] | undefined;
    removedVirtualAssetITservice: number[] | undefined;
    removedVirtualAssetBusinessprocess: number[] | undefined;
    removedVirtualAssetBusinessServices: number[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class VirtualAssetListDto implements IVirtualAssetListDto {
    tenantId!: number | undefined;
    virtualAssetId!: string | undefined;
    virtualAssetName!: string | undefined;
    virtualAssetUniqueIdentity!: string | undefined;
    virtualMachine!: boolean;
    description!: string | undefined;
    parentVirtualHostId!: number | undefined;
    hostedServerNameId!: number | undefined;
    hostedServerName!: HardwareAsseDetailListDto;
    lockThreatOrganizationId!: number | undefined;
    lockThreatOrganization!: GetOrganizationDto;
    businessUnitId!: number | undefined;
    businessUnit!: BusinessUnitPrimaryDto;
    businessUnitGaurdianId!: number | undefined;
    businessUnitGaurdian!: BusinessUnitGaurdianDto;
    confidentialityId!: number | undefined;
    confidentiality!: DynamicPropertyValue;
    availibilityId!: number | undefined;
    availibility!: DynamicPropertyValue;
    integrityId!: number | undefined;
    integrity!: DynamicPropertyValue;
    othersId!: number | undefined;
    others!: DynamicPropertyValue;
    id!: number;

    constructor(data?: IVirtualAssetListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.virtualAssetId = _data["virtualAssetId"];
            this.virtualAssetName = _data["virtualAssetName"];
            this.virtualAssetUniqueIdentity = _data["virtualAssetUniqueIdentity"];
            this.virtualMachine = _data["virtualMachine"];
            this.description = _data["description"];
            this.parentVirtualHostId = _data["parentVirtualHostId"];
            this.hostedServerNameId = _data["hostedServerNameId"];
            this.hostedServerName = _data["hostedServerName"] ? HardwareAsseDetailListDto.fromJS(_data["hostedServerName"]) : <any>undefined;
            this.lockThreatOrganizationId = _data["lockThreatOrganizationId"];
            this.lockThreatOrganization = _data["lockThreatOrganization"] ? GetOrganizationDto.fromJS(_data["lockThreatOrganization"]) : <any>undefined;
            this.businessUnitId = _data["businessUnitId"];
            this.businessUnit = _data["businessUnit"] ? BusinessUnitPrimaryDto.fromJS(_data["businessUnit"]) : <any>undefined;
            this.businessUnitGaurdianId = _data["businessUnitGaurdianId"];
            this.businessUnitGaurdian = _data["businessUnitGaurdian"] ? BusinessUnitGaurdianDto.fromJS(_data["businessUnitGaurdian"]) : <any>undefined;
            this.confidentialityId = _data["confidentialityId"];
            this.confidentiality = _data["confidentiality"] ? DynamicPropertyValue.fromJS(_data["confidentiality"]) : <any>undefined;
            this.availibilityId = _data["availibilityId"];
            this.availibility = _data["availibility"] ? DynamicPropertyValue.fromJS(_data["availibility"]) : <any>undefined;
            this.integrityId = _data["integrityId"];
            this.integrity = _data["integrity"] ? DynamicPropertyValue.fromJS(_data["integrity"]) : <any>undefined;
            this.othersId = _data["othersId"];
            this.others = _data["others"] ? DynamicPropertyValue.fromJS(_data["others"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): VirtualAssetListDto {
        data = typeof data === 'object' ? data : {};
        let result = new VirtualAssetListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["virtualAssetId"] = this.virtualAssetId;
        data["virtualAssetName"] = this.virtualAssetName;
        data["virtualAssetUniqueIdentity"] = this.virtualAssetUniqueIdentity;
        data["virtualMachine"] = this.virtualMachine;
        data["description"] = this.description;
        data["parentVirtualHostId"] = this.parentVirtualHostId;
        data["hostedServerNameId"] = this.hostedServerNameId;
        data["hostedServerName"] = this.hostedServerName ? this.hostedServerName.toJSON() : <any>undefined;
        data["lockThreatOrganizationId"] = this.lockThreatOrganizationId;
        data["lockThreatOrganization"] = this.lockThreatOrganization ? this.lockThreatOrganization.toJSON() : <any>undefined;
        data["businessUnitId"] = this.businessUnitId;
        data["businessUnit"] = this.businessUnit ? this.businessUnit.toJSON() : <any>undefined;
        data["businessUnitGaurdianId"] = this.businessUnitGaurdianId;
        data["businessUnitGaurdian"] = this.businessUnitGaurdian ? this.businessUnitGaurdian.toJSON() : <any>undefined;
        data["confidentialityId"] = this.confidentialityId;
        data["confidentiality"] = this.confidentiality ? this.confidentiality.toJSON() : <any>undefined;
        data["availibilityId"] = this.availibilityId;
        data["availibility"] = this.availibility ? this.availibility.toJSON() : <any>undefined;
        data["integrityId"] = this.integrityId;
        data["integrity"] = this.integrity ? this.integrity.toJSON() : <any>undefined;
        data["othersId"] = this.othersId;
        data["others"] = this.others ? this.others.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IVirtualAssetListDto {
    tenantId: number | undefined;
    virtualAssetId: string | undefined;
    virtualAssetName: string | undefined;
    virtualAssetUniqueIdentity: string | undefined;
    virtualMachine: boolean;
    description: string | undefined;
    parentVirtualHostId: number | undefined;
    hostedServerNameId: number | undefined;
    hostedServerName: HardwareAsseDetailListDto;
    lockThreatOrganizationId: number | undefined;
    lockThreatOrganization: GetOrganizationDto;
    businessUnitId: number | undefined;
    businessUnit: BusinessUnitPrimaryDto;
    businessUnitGaurdianId: number | undefined;
    businessUnitGaurdian: BusinessUnitGaurdianDto;
    confidentialityId: number | undefined;
    confidentiality: DynamicPropertyValue;
    availibilityId: number | undefined;
    availibility: DynamicPropertyValue;
    integrityId: number | undefined;
    integrity: DynamicPropertyValue;
    othersId: number | undefined;
    others: DynamicPropertyValue;
    id: number;
}

export class PagedResultDtoOfVirtualAssetListDto implements IPagedResultDtoOfVirtualAssetListDto {
    totalCount!: number;
    items!: VirtualAssetListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfVirtualAssetListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VirtualAssetListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfVirtualAssetListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfVirtualAssetListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfVirtualAssetListDto {
    totalCount: number;
    items: VirtualAssetListDto[] | undefined;
}

export class WebhookEvent implements IWebhookEvent {
    webhookName!: string;
    data!: string | undefined;
    creationTime!: DateTime;
    tenantId!: number | undefined;
    isDeleted!: boolean;
    deletionTime!: DateTime | undefined;
    id!: string;

    constructor(data?: IWebhookEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookEvent {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWebhookEvent {
    webhookName: string;
    data: string | undefined;
    creationTime: DateTime;
    tenantId: number | undefined;
    isDeleted: boolean;
    deletionTime: DateTime | undefined;
    id: string;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 301,
    MovedPermanently = 302,
    Moved = 303,
    Found = 304,
    Redirect = 305,
    SeeOther = 306,
    RedirectMethod = 307,
    NotModified = 308,
    UseProxy = 400,
    Unused = 401,
    TemporaryRedirect = 402,
    RedirectKeepVerb = 403,
    PermanentRedirect = 404,
    BadRequest = 405,
    Unauthorized = 406,
    PaymentRequired = 407,
    Forbidden = 408,
    NotFound = 409,
    MethodNotAllowed = 410,
    NotAcceptable = 411,
    ProxyAuthenticationRequired = 412,
    RequestTimeout = 413,
    Conflict = 414,
    Gone = 415,
    LengthRequired = 416,
    PreconditionFailed = 417,
    RequestEntityTooLarge = 421,
    RequestUriTooLong = 422,
    UnsupportedMediaType = 423,
    RequestedRangeNotSatisfiable = 424,
    ExpectationFailed = 426,
    MisdirectedRequest = 428,
    UnprocessableEntity = 429,
    Locked = 431,
    FailedDependency = 451,
    UpgradeRequired = 500,
    PreconditionRequired = 501,
    TooManyRequests = 502,
    RequestHeaderFieldsTooLarge = 503,
    UnavailableForLegalReasons = 504,
    InternalServerError = 505,
    NotImplemented = 506,
    BadGateway = 507,
    ServiceUnavailable = 508,
    GatewayTimeout = 510,
    HttpVersionNotSupported = 511,
}

export class GetAllSendAttemptsOutput implements IGetAllSendAttemptsOutput {
    id!: string;
    webhookEventId!: string;
    webhookName!: string | undefined;
    data!: string | undefined;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: DateTime;

    constructor(data?: IGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookEventId = _data["webhookEventId"];
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookEventId"] = this.webhookEventId;
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IGetAllSendAttemptsOutput {
    id: string;
    webhookEventId: string;
    webhookName: string | undefined;
    data: string | undefined;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: DateTime;
}

export class PagedResultDtoOfGetAllSendAttemptsOutput implements IPagedResultDtoOfGetAllSendAttemptsOutput {
    totalCount!: number;
    items!: GetAllSendAttemptsOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAllSendAttemptsOutput {
    totalCount: number;
    items: GetAllSendAttemptsOutput[] | undefined;
}

export class GetAllSendAttemptsOfWebhookEventOutput implements IGetAllSendAttemptsOfWebhookEventOutput {
    id!: string;
    webhookUri!: string | undefined;
    webhookSubscriptionId!: string;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: DateTime;
    lastModificationTime!: DateTime | undefined;

    constructor(data?: IGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookUri = _data["webhookUri"];
            this.webhookSubscriptionId = _data["webhookSubscriptionId"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookUri"] = this.webhookUri;
        data["webhookSubscriptionId"] = this.webhookSubscriptionId;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IGetAllSendAttemptsOfWebhookEventOutput {
    id: string;
    webhookUri: string | undefined;
    webhookSubscriptionId: string;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: DateTime;
    lastModificationTime: DateTime | undefined;
}

export class ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput implements IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    items!: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOfWebhookEventOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    items: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;
}

export class GetAllSubscriptionsOutput implements IGetAllSubscriptionsOutput {
    webhookUri!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    id!: string;

    constructor(data?: IGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webhookUri = _data["webhookUri"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webhookUri"] = this.webhookUri;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetAllSubscriptionsOutput {
    webhookUri: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    id: string;
}

export class ListResultDtoOfGetAllSubscriptionsOutput implements IListResultDtoOfGetAllSubscriptionsOutput {
    items!: GetAllSubscriptionsOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSubscriptionsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfGetAllSubscriptionsOutput {
    items: GetAllSubscriptionsOutput[] | undefined;
}

export class WebhookSubscription implements IWebhookSubscription {
    tenantId!: number | undefined;
    webhookUri!: string | undefined;
    secret!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    headers!: { [key: string]: string; } | undefined;
    id!: string;

    constructor(data?: IWebhookSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.webhookUri = _data["webhookUri"];
            this.secret = _data["secret"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        this.headers![key] = _data["headers"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["webhookUri"] = this.webhookUri;
        data["secret"] = this.secret;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    data["headers"][key] = this.headers[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IWebhookSubscription {
    tenantId: number | undefined;
    webhookUri: string | undefined;
    secret: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    headers: { [key: string]: string; } | undefined;
    id: string;
}

export class ActivateWebhookSubscriptionInput implements IActivateWebhookSubscriptionInput {
    subscriptionId!: string;
    isActive!: boolean;

    constructor(data?: IActivateWebhookSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ActivateWebhookSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateWebhookSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IActivateWebhookSubscriptionInput {
    subscriptionId: string;
    isActive: boolean;
}

export class GetAllAvailableWebhooksOutput implements IGetAllAvailableWebhooksOutput {
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }
}

export interface IGetAllAvailableWebhooksOutput {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class ListResultDtoOfGetAllAvailableWebhooksOutput implements IListResultDtoOfGetAllAvailableWebhooksOutput {
    items!: GetAllAvailableWebhooksOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllAvailableWebhooksOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfGetAllAvailableWebhooksOutput {
    items: GetAllAvailableWebhooksOutput[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["latestWebLogLines"])) {
                this.latestWebLogLines = [] as any;
                for (let item of _data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.latestWebLogLines)) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class AdditionalData implements IAdditionalData {
    paypal!: { [key: string]: string; };
    stripe!: { [key: string]: string; };

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["Paypal"]) {
                this.paypal = {} as any;
                for (let key in _data["Paypal"]) {
                    if (_data["Paypal"].hasOwnProperty(key))
                        this.paypal![key] = _data["Paypal"][key];
                }
            }
            if (_data["Stripe"]) {
                this.stripe = {} as any;
                for (let key in _data["Stripe"]) {
                    if (_data["Stripe"].hasOwnProperty(key))
                        this.stripe![key] = _data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    data["Stripe"][key] = this.stripe[key];
            }
        }
        return data; 
    }
}

export interface IAdditionalData {
    paypal: { [key: string]: string; };
    stripe: { [key: string]: string; };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}